{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Harneet Programming Language - Beginner's Guide","text":"<p>Welcome to Harneet! This guide will teach you everything you need to know about the Harneet programming language, designed especially for newcomers to programming. Inspired by golang and some python! </p>"},{"location":"#what-is-harneet","title":"\ud83c\udf1f What is Harneet?","text":"<p>Harneet is a simple, easy-to-learn programming language that's perfect for beginners. It has clean syntax inspired by Go and includes basic programming concepts like variables, math, and decision-making.</p> <p>Think of Harneet as a friendly way to learn programming fundamentals before moving on to more complex languages.</p> <p>Please note that Harneet is still being actively worked on and features that you would normally see in other programming languages are still not present in Harneet.Definitely not to be used in Production!!</p>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"#installation-running-programs","title":"Installation &amp; Running Programs","text":"<ol> <li> <p>Build Harneet (one-time setup):    <pre><code>just build\n# This creates the 'harneet' program\n</code></pre></p> </li> <li> <p>Try the interactive mode (REPL):    <pre><code>just repl\n# Type commands and see results immediately\n</code></pre></p> </li> <li> <p>Run a program file:    <pre><code>./harneet examples/hello.ha\n# Runs code from a file (uses .ha extension)\n</code></pre></p> </li> </ol>"},{"location":"#example-1-your-first-program","title":"Example 1: Your First Program","text":"<p>Let's start with the classic \"Hello, World!\" program:</p> First Program<pre><code>package main\nimport fmt\nfmt.Println(\"Hello, World!\")\n</code></pre> <p>What this does: - <code>import fmt</code> loads the formatting module (needed for printing) - <code>fmt.Println()</code> is a command that prints text to the screen - The text inside quotes <code>\"Hello, World!\"</code> is what gets printed - Every statement in Harneet can be on its own line</p> <p>Try it yourself: 1. Save this code in a file called <code>hello.ha</code> 2. Run it with: <code>./harneet hello.ha</code></p>"},{"location":"#example-2-simple-calculator","title":"Example 2: Simple Calculator","text":"Simple Calculator<pre><code>package main\nvar num1 int = 15\nvar num2 int = 4\n\nfmt.Println(\"Number 1:\", num1)\nfmt.Println(\"Number 2:\", num2)\nfmt.Println(\"Sum:\", num1 + num2)\nfmt.Println(\"Difference:\", num1 - num2)\nfmt.Println(\"Product:\", num1 * num2)\nfmt.Println(\"Division:\", num1 / num2)\nfmt.Println(\"Remainder:\", num1 % num2)\n</code></pre>"},{"location":"#example-3-grade-checker","title":"Example 3: Grade Checker","text":"Grade Checker<pre><code>package main\nvar score int = 85\n\nfmt.Println(\"Your score:\", score)\n\nif score &gt;= 90 {\n    fmt.Println(\"Grade: A - Excellent!\")\n}\n\nif score &gt;= 80 and score &lt; 90 {\n    fmt.Println(\"Grade: B - Good job!\")\n}\n\nif score &gt;= 70 and score &lt; 80 {\n    fmt.Println(\"Grade: C - Not bad!\")\n}\n\nif score &lt; 70 {\n    fmt.Println(\"Grade: F - Study more!\")\n}\n</code></pre>"},{"location":"#tips-for-success","title":"\ud83d\udd27 Tips for Success","text":"<ol> <li>Start small - Begin with simple programs and add complexity gradually</li> <li>Experiment - Try changing values and see what happens</li> <li>Use the REPL - Test small pieces of code interactively</li> <li>Read error messages - They tell you what went wrong</li> <li>Practice daily - Even 10 minutes a day helps!</li> </ol>"},{"location":"#common-beginner-mistakes","title":"\ud83d\udc1b Common Beginner Mistakes","text":""},{"location":"#mistake-1-missing-quotes-for-text","title":"Mistake 1: Missing quotes for text","text":"<pre><code>// Wrong:\npackage main\nfmt.Println(Hello)\n\n// Right:\nfmt.Println(\"Hello\")\n</code></pre>"},{"location":"#mistake-2-using-instead-of","title":"Mistake 2: Using = instead of ==","text":"<pre><code>// Wrong (assigns value):\nif x = 5 {\n\n// Right (compares):\nif x == 5 {\n</code></pre>"},{"location":"#mistake-3-trying-to-use-a-single-variable-for-functions-that-return-multiple-values","title":"Mistake 3: Trying to use a single variable for functions that return multiple values","text":"<pre><code>// Wrong (shows helpful error message):\npackage main\nvar result = math.Abs(-42)\n\n// Right (handle both result and error):\nvar result, err = math.Abs(-42)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result)\n}\n</code></pre>"},{"location":"#getting-help","title":"\ud83d\udd17 Getting Help","text":"<ul> <li>Run examples: <code>just test</code> runs all example programs</li> <li>Try interactive mode: <code>just repl</code> for experimenting</li> <li>Check the documentation: Read <code>CLAUDE.md</code> for technical details</li> <li>Practice: The <code>examples/</code> folder has more programs to study</li> </ul>"},{"location":"#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You now know the basics of the Harneet programming language! That said, there are still more things to learn. We encourage you to go through the remaining of this document, to know more Harneet Programming language. Remember: - Programming is like learning a new language - it takes practice - Every expert was once a beginner - The most important thing is to keep experimenting and having fun!</p> <p>Happy coding! \ud83d\ude80</p>"},{"location":"any_type/","title":"The <code>any</code> Type","text":"<p>Harneet supports the <code>any</code> type as a top type (supertype of all types) with strict, one-way assignability rules. This design preserves Harneet's strong typing while enabling flexibility at dynamic boundaries like JSON, OS, regex, and external APIs.</p>"},{"location":"any_type/#quick-start","title":"Quick Start","text":"<pre><code>import fmt\nimport cast\n\n// \u2705 Upcast to any - ALLOWED\nvar x any = 42\nvar y any = \"hello\"\n\nfmt.Println(x)  // Prints: 42\n\n// \u2705 Explicit narrowing - REQUIRED\nvar num, err = cast.ToInt(x)\nif err == None {\n    fmt.Printf(\"Number: %d\\n\", num)\n}\n</code></pre>"},{"location":"any_type/#core-principles","title":"Core Principles","text":""},{"location":"any_type/#strict-assignability-rules","title":"Strict Assignability Rules","text":"<p>The <code>any</code> type follows these fundamental rules:</p> Direction Allowed? Description T \u2192 any \u2705 YES Any concrete type can be assigned to <code>any</code> (upcast) any \u2192 T \u274c NO Cannot assign <code>any</code> to concrete type without explicit cast (downcast) <p>This one-way assignability prevents type safety violations while allowing flexibility where needed.</p>"},{"location":"any_type/#basic-usage","title":"Basic Usage","text":""},{"location":"any_type/#variable-declaration","title":"Variable Declaration","text":"<pre><code>// Declare any variables - accepts all types\nvar dynamic any = 100\nvar flexible any = \"can be anything\"\n\n// Any type accepts all values\ndynamic = \"now a string\"\ndynamic = true\ndynamic = [1, 2, 3]\ndynamic = {\"name\": \"Alice\"}\n</code></pre>"},{"location":"any_type/#function-parameters","title":"Function Parameters","text":"<pre><code>import fmt\n\n// Function accepting any type\nfunction printValue(val any) {\n    fmt.Printf(\"Value: %v\\n\", val)\n}\n\n// Works with all types\nprintValue(42)\nprintValue(\"hello\")\nprintValue(true)\nprintValue([1, 2, 3])\nprintValue({\"key\": \"value\"})\n</code></pre>"},{"location":"any_type/#function-returns","title":"Function Returns","text":"<pre><code>import cast\n\n// Function returning any\nfunction getDynamic(flag bool) any {\n    if flag {\n        return 42\n    } else {\n        return \"forty-two\"\n    }\n}\n\n// Must narrow with explicit cast\nvar result = getDynamic(true)\nvar num, err = cast.ToInt(result)\nif err == None {\n    fmt.Printf(\"Number: %d\\n\", num)\n}\n</code></pre>"},{"location":"any_type/#explicit-narrowing","title":"Explicit Narrowing","text":"<p>The <code>cast</code> module provides type-safe narrowing from <code>any</code> to concrete types.</p>"},{"location":"any_type/#available-cast-functions","title":"Available Cast Functions","text":"Function Purpose Example <code>cast.ToInt(any)</code> Convert to integer <code>var n, err = cast.ToInt(x)</code> <code>cast.ToString(any)</code> Convert to string <code>var s, err = cast.ToString(x)</code> <code>cast.ToBool(any)</code> Convert to boolean <code>var b, err = cast.ToBool(x)</code> <code>cast.ToFloat(any)</code> Convert to float <code>var f, err = cast.ToFloat(x)</code> <code>cast.ToArray(any)</code> Convert to array <code>var a, err = cast.ToArray(x)</code> <code>cast.ToMap(any)</code> Convert to map <code>var m, err = cast.ToMap(x)</code> <code>cast.CanCast(any, type)</code> Check if possible <code>var ok, _ = cast.CanCast(x, \"int\")</code>"},{"location":"any_type/#narrowing-examples","title":"Narrowing Examples","text":"<pre><code>import cast\n\nvar mystery any = \"12345\"\n\n// Method 1: Direct conversion\nvar num, err = cast.ToInt(mystery)\nif err == None {\n    fmt.Printf(\"Converted: %d\\n\", num)\n}\n\n// Method 2: Preflight check\nvar canConvert, _ = cast.CanCast(mystery, \"int\")\nif canConvert {\n    var num, _ = cast.ToInt(mystery)\n    fmt.Printf(\"Safe to use: %d\\n\", num)\n}\n</code></pre>"},{"location":"any_type/#best-practices","title":"Best Practices","text":""},{"location":"any_type/#when-to-use-any","title":"\u2705 When to Use <code>any</code>","text":"<p>Use <code>any</code> at dynamic boundaries:</p> <p>1. JSON Parsing <pre><code>import json\nimport cast\n\nvar jsonStr = \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 25}\"\nvar data, _ = json.Unmarshal(jsonStr)\n\n// Narrow immediately\nvar obj, _ = cast.ToMap(data)\nvar name, _ = cast.ToString(obj[\"name\"])\nvar age, _ = cast.ToInt(obj[\"age\"])\n</code></pre></p> <p>2. External APIs <pre><code>function processAPIResponse(response any) {\n    var data, err = cast.ToMap(response)\n    if err != None {\n        fmt.Println(\"Invalid response format\")\n        return\n    }\n    // Process typed data...\n}\n</code></pre></p> <p>3. Configuration Management <pre><code>var config = {\n    \"port\": 8080,\n    \"host\": \"localhost\",\n    \"debug\": true,\n    \"timeout\": 30.5\n}\n\nfunction getConfigValue(key string) any {\n    return config[key]\n}\n\n// Narrow when retrieving\nvar port, _ = cast.ToInt(getConfigValue(\"port\"))\n</code></pre></p> <p>4. Generic Utilities <pre><code>function logValue(key string, value any) {\n    fmt.Printf(\"%s: %v\\n\", key, value)\n}\n\nlogValue(\"count\", 42)\nlogValue(\"name\", \"Alice\")\nlogValue(\"active\", true)\n</code></pre></p>"},{"location":"any_type/#when-to-avoid-any","title":"\u274c When to Avoid <code>any</code>","text":"<p>Don't use <code>any</code> for:</p> <ol> <li> <p>Internal Business Logic <pre><code>// \u274c Bad - loses type safety\nfunction calculateTotal(items any) any { ... }\n\n// \u2705 Good - maintains type safety\nfunction calculateTotal(items []Item) float64 { ... }\n</code></pre></p> </li> <li> <p>Public APIs <pre><code>// \u274c Bad - unclear contract\nfunction createUser(data any) any { ... }\n\n// \u2705 Good - clear contract\nfunction createUser(name string, age int) User { ... }\n</code></pre></p> </li> <li> <p>Data Structures <pre><code>// \u274c Bad - no type safety\nvar users []any\n\n// \u2705 Good - typed collection\nvar users []User\n</code></pre></p> </li> </ol>"},{"location":"any_type/#design-patterns","title":"Design Patterns","text":""},{"location":"any_type/#pattern-1-early-narrowing","title":"Pattern 1: Early Narrowing","text":"<p>Narrow at the boundary, keep core typed:</p> <pre><code>import cast\n\nfunction processConfig(config any) {\n    // Narrow immediately at boundary\n    var configMap, err = cast.ToMap(config)\n    if err != None {\n        fmt.Println(\"Error: config must be a map\")\n        return\n    }\n\n    // Extract and narrow individual fields\n    var port, _ = cast.ToInt(configMap[\"port\"])\n    var host, _ = cast.ToString(configMap[\"host\"])\n    var debug, _ = cast.ToBool(configMap[\"debug\"])\n\n    // Core logic uses concrete types\n    startServer(host, port, debug)\n}\n</code></pre>"},{"location":"any_type/#pattern-2-type-guards","title":"Pattern 2: Type Guards","text":"<p>Try each type in order:</p> <pre><code>import cast\n\nfunction handleDynamic(val any) {\n    // Try integer first\n    var asInt, intErr = cast.ToInt(val)\n    if intErr == None {\n        fmt.Printf(\"Handling integer: %d\\n\", asInt)\n        return\n    }\n\n    // Try string next\n    var asString, strErr = cast.ToString(val)\n    if strErr == None {\n        fmt.Printf(\"Handling string: %s\\n\", asString)\n        return\n    }\n\n    // Try boolean\n    var asBool, boolErr = cast.ToBool(val)\n    if boolErr == None {\n        fmt.Printf(\"Handling boolean: %v\\n\", asBool)\n        return\n    }\n\n    fmt.Println(\"Unsupported type\")\n}\n</code></pre>"},{"location":"any_type/#pattern-3-api-response-processing","title":"Pattern 3: API Response Processing","text":"<p>Process dynamic JSON data:</p> <pre><code>import json\nimport cast\n\nfunction fetchUserData(apiResponse string) {\n    // Parse JSON (returns any)\n    var data, err = json.Unmarshal(apiResponse)\n    if err != None {\n        return\n    }\n\n    // Narrow to map\n    var userMap, mapErr = cast.ToMap(data)\n    if mapErr != None {\n        return\n    }\n\n    // Extract and narrow fields\n    var id, _ = cast.ToInt(userMap[\"id\"])\n    var name, _ = cast.ToString(userMap[\"name\"])\n    var email, _ = cast.ToString(userMap[\"email\"])\n    var active, _ = cast.ToBool(userMap[\"active\"])\n\n    // Use typed data in core logic\n    processUser(id, name, email, active)\n}\n</code></pre>"},{"location":"any_type/#type-safety-guarantees","title":"Type Safety Guarantees","text":""},{"location":"any_type/#compile-time-enforcement","title":"Compile-Time Enforcement","text":"<pre><code>var x any = 42\nvar y int = x  // \u274c COMPILE ERROR: cannot assign any to int\n\n// Must use explicit cast\nvar y, err = cast.ToInt(x)  // \u2705 OK\n</code></pre>"},{"location":"any_type/#runtime-validation","title":"Runtime Validation","text":"<pre><code>var x any = \"not a number\"\nvar y, err = cast.ToInt(x)  // \u2705 Returns error, doesn't panic\n\nif err != None {\n    fmt.Println(err)\n    // Output: cast.ToInt: cannot convert string \"not a number\" to integer\n}\n</code></pre>"},{"location":"any_type/#no-implicit-conversions","title":"No Implicit Conversions","text":"<pre><code>var config any = {\"port\": \"8080\"}\nvar configMap, _ = cast.ToMap(config)\n\n// \u274c This would fail - port is string, not int\nvar port, err = cast.ToInt(configMap[\"port\"])\n\n// \u2705 This works - convert string to int\nvar portStr, _ = cast.ToString(configMap[\"port\"])\nvar port, err = cast.ToInt(portStr)\n</code></pre>"},{"location":"any_type/#real-world-examples","title":"Real-World Examples","text":""},{"location":"any_type/#example-1-configuration-system","title":"Example 1: Configuration System","text":"<pre><code>import cast\nimport os\n\nfunction loadConfig() {\n    var config = {\n        \"port\": 8080,\n        \"host\": \"0.0.0.0\",\n        \"debug\": false,\n        \"timeout\": 30.5\n    }\n\n    // Override from environment\n    var portEnv, _ = os.Getenv(\"PORT\")\n    if portEnv != \"\" {\n        var port, err = cast.ToInt(portEnv)\n        if err == None {\n            config[\"port\"] = port\n        }\n    }\n\n    return config\n}\n\nfunction startApp() {\n    var cfg = loadConfig()\n\n    // Narrow configuration values\n    var port, _ = cast.ToInt(cfg[\"port\"])\n    var host, _ = cast.ToString(cfg[\"host\"])\n    var debug, _ = cast.ToBool(cfg[\"debug\"])\n\n    fmt.Printf(\"Starting server on %s:%d (debug: %v)\\n\", host, port, debug)\n}\n</code></pre>"},{"location":"any_type/#example-2-dynamic-command-handler","title":"Example 2: Dynamic Command Handler","text":"<pre><code>import cast\n\nfunction executeCommand(cmd string, args any) {\n    if cmd == \"add\" {\n        var nums, err = cast.ToArray(args)\n        if err != None {\n            fmt.Println(\"add command requires array of numbers\")\n            return\n        }\n\n        var sum = 0\n        for num in nums {\n            var n, _ = cast.ToInt(num)\n            sum = sum + n\n        }\n        fmt.Printf(\"Sum: %d\\n\", sum)\n\n    } else if cmd == \"greet\" {\n        var name, err = cast.ToString(args)\n        if err != None {\n            fmt.Println(\"greet command requires string name\")\n            return\n        }\n        fmt.Printf(\"Hello, %s!\\n\", name)\n\n    } else if cmd == \"info\" {\n        var data, err = cast.ToMap(args)\n        if err != None {\n            fmt.Println(\"info command requires map\")\n            return\n        }\n\n        for key, value in data {\n            fmt.Printf(\"%s: %v\\n\", key, value)\n        }\n    }\n}\n\n// Usage\nexecuteCommand(\"add\", [1, 2, 3, 4, 5])\nexecuteCommand(\"greet\", \"Alice\")\nexecuteCommand(\"info\", {\"version\": \"1.0\", \"author\": \"Harneet\"})\n</code></pre>"},{"location":"any_type/#example-3-json-api-client","title":"Example 3: JSON API Client","text":"<pre><code>import json\nimport cast\nimport http\n\nfunction fetchUser(userId int) {\n    var url = fmt.Sprintf(\"https://api.example.com/users/%d\", userId)\n    var response, _ = http.Get(url)\n\n    // Parse JSON response\n    var data, err = json.Unmarshal(response.Body)\n    if err != None {\n        fmt.Println(\"Failed to parse response\")\n        return\n    }\n\n    // Narrow to map\n    var userMap, _ = cast.ToMap(data)\n\n    // Extract user fields\n    var id, _ = cast.ToInt(userMap[\"id\"])\n    var name, _ = cast.ToString(userMap[\"name\"])\n    var email, _ = cast.ToString(userMap[\"email\"])\n    var age, _ = cast.ToInt(userMap[\"age\"])\n\n    // Use typed data\n    fmt.Printf(\"User %d: %s &lt;%s&gt; (age: %d)\\n\", id, name, email, age)\n}\n</code></pre>"},{"location":"any_type/#comparison-with-other-languages","title":"Comparison with Other Languages","text":"Language Type Behavior Harneet <code>any</code> Top type Strict: requires explicit cast for downcast TypeScript <code>any</code> Top type Permissive: allows implicit conversions Go <code>interface{}</code> Empty interface Requires type assertion Python <code>Any</code> Type hint Runtime only, no compile-time enforcement Java <code>Object</code> Root class Requires explicit cast <p>Harneet's approach: - \u2705 Stricter than TypeScript (better safety) - \u2705 Cleaner syntax than Go (no type assertions) - \u2705 Compile-time enforcement unlike Python - \u2705 Integrated cast module (easier than Java)</p>"},{"location":"any_type/#summary","title":"Summary","text":"<p>The <code>any</code> type in Harneet provides:</p> <p>\u2705 Flexibility - Handle dynamic data at boundaries \u2705 Type Safety - Explicit conversions required \u2705 Clarity - Clear upcast/downcast rules \u2705 Integration - Works seamlessly with cast module \u2705 Best Practices - Documented patterns \u2705 No Surprises - Predictable behavior  </p> <p>Remember: Use <code>any</code> at boundaries (JSON, OS, APIs), but keep core logic typed!</p>"},{"location":"any_type/#see-also","title":"See Also","text":"<ul> <li>Type System &amp; Safety - Overview of Harneet's type system</li> <li>Cast Module - Type conversion functions</li> <li>JSON Module - JSON parsing and serialization</li> <li>Error Handling - Error handling patterns</li> </ul>"},{"location":"command_line/","title":"Command Line Interface (CLI)","text":"<p>The Harneet interpreter provides a command-line interface (CLI) for running files, starting an interactive session (REPL), and performing other utility tasks. This section details the available flags and their usage.</p>"},{"location":"command_line/#flags","title":"Flags","text":""},{"location":"command_line/#-debug-or-d","title":"<code>--debug</code> (or <code>-d</code>)","text":"<ul> <li>Type: Boolean</li> <li>Usage: <code>harneet --debug [filename.ha]</code> or <code>harneet -d --repl</code></li> <li>Description: Enables debug logging, which provides detailed information about the interpreter's internal operations. When this flag is active, a timestamped log file is created in the <code>logs/</code> directory, capturing each step of the execution process, from lexical analysis to evaluation. This is an invaluable tool for understanding how the interpreter processes your code and for debugging the interpreter itself.</li> </ul>"},{"location":"command_line/#-repl-or-r","title":"<code>--repl</code> (or <code>-r</code>)","text":"<ul> <li>Type: Boolean</li> <li>Usage: <code>harneet --repl</code> or <code>harneet -r</code></li> <li>Description: Starts the Read-Eval-Print Loop (REPL), an interactive mode where you can enter and execute Harneet code line by line. The REPL is perfect for experimenting with the language, testing small code snippets, and getting immediate feedback. To exit the REPL, type <code>exit</code> and press Enter.</li> </ul>"},{"location":"command_line/#-scan","title":"<code>--scan</code>","text":"<ul> <li>Type: String (directory path)</li> <li>Usage: <code>harneet --scan &lt;directory_path&gt;</code></li> <li>Description: Scans the specified directory recursively and lists and executes all files with the <code>.ha</code> extension. This is a utility feature that helps you quickly find all Harneet source files within a project.</li> </ul>"},{"location":"command_line/#examples","title":"Examples","text":"<ul> <li> <p>Run a file:     <pre><code>harneet program.ha\n</code></pre></p> </li> <li> <p>Run a file with debug logging:     <pre><code>harneet --debug program.ha\n</code></pre></p> </li> <li> <p>Start the REPL:     <pre><code>harneet --repl\n</code></pre></p> </li> <li> <p>Start the REPL with debug logging:     <pre><code>harneet --repl --debug\n</code></pre></p> </li> <li> <p>Scan a directory for <code>.ha</code> files and execute the files:     <pre><code>harneet --scan ./my_project\n</code></pre></p> </li> </ul>"},{"location":"comprehensive_examples/","title":"Comprehensive Language Examples","text":"<p>This page provides a collection of examples that demonstrate various features of the Harneet programming language.</p>"},{"location":"comprehensive_examples/#array-operations","title":"Array Operations","text":"Array Operations<pre><code>package main\nimport fmt, arrays\n\nvar nums = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\nvar mixed = [1, \"hello\", 3.14, true]\n\n// Array operations\nvar length, _ = arrays.length(nums)\nvar contains, _ = arrays.contains(names, \"Alice\")\nvar newArray, _ = arrays.push(nums, 6)\nvar sortedNums, _ = arrays.sort([3, 1, 4, 1, 5])\n\nfmt.Println(\"Length:\", length)\nfmt.Println(\"Contains Alice:\", contains)\nfmt.Println(\"New array:\", newArray)\nfmt.Println(\"Sorted:\", sortedNums)\n</code></pre>"},{"location":"comprehensive_examples/#concurrency-patterns","title":"Concurrency Patterns","text":"<p>This section provides comprehensive examples using <code>do</code>, <code>await(task)</code>, and <code>sleep(ms)</code> for practical concurrency.</p>"},{"location":"comprehensive_examples/#parallel-map-pmap","title":"Parallel Map (pmap)","text":"Parallel map with do/await<pre><code>package main\nimport fmt\nimport arrays\n\nfunction square(n int) int {\n    sleep(20) // simulate work\n    return n * n\n}\n\nvar values = [1, 2, 3, 4, 5]\n\n// Spawn tasks\nvar tasks = []\nfor v in values {\n    var newTasks, _ = arrays.push(tasks, do square(v))\n    tasks = newTasks\n}\n\n// Gather results\nvar results = []\nfor t in tasks {\n    var newResults, _ = arrays.push(results, await(t))\n    results = newResults\n}\n\nfmt.Println(\"pmap squares:\", results) // [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"comprehensive_examples/#concurrency-limit-batching","title":"Concurrency Limit (Batching)","text":"<p>Run tasks in batches to limit concurrency when you don\u2019t need fine-grained completion order.</p> Batch-limited parallel map<pre><code>package main\nimport fmt\nimport arrays\n\nfunction pmapLimited(values array, f function(any) any, limit int) array {\n    var out = []\n    var i = 0\n    while i &lt; len(values) {\n        // Make a batch up to 'limit'\n        var batch = []\n        var j = 0\n        while j &lt; limit &amp;&amp; (i+j) &lt; len(values) {\n            var v = values[i+j]\n            var batch2, _ = arrays.push(batch, do f(v))\n            batch = batch2\n            j = j + 1\n        }\n\n        // Drain the batch\n        for t in batch {\n            var out2, _ = arrays.push(out, await(t))\n            out = out2\n        }\n\n        i = i + j\n    }\n    return out\n}\n\nfunction slowInc(x int) int { sleep(30); return x + 1 }\n\nvar data = [1,2,3,4,5,6,7,8]\nvar res = pmapLimited(data, slowInc, 3)\nfmt.Println(\"limited concurrency result:\", res)\n</code></pre>"},{"location":"comprehensive_examples/#pipeline-staged-concurrency","title":"Pipeline (Staged Concurrency)","text":"<p>Process values through multiple stages, synchronizing between stages.</p> Staged pipeline with barriers<pre><code>package main\nimport fmt\nimport arrays\n\nfunction stage1(x int) int { sleep(20); return x * 2 }\nfunction stage2(x int) int { sleep(20); return x + 10 }\n\nvar input = [1,2,3,4]\n\n// Stage 1\nvar t1 = []\nfor v in input { var t1b, _ = arrays.push(t1, do stage1(v)); t1 = t1b }\nvar r1 = []\nfor t in t1 { var r1b, _ = arrays.push(r1, await(t)); r1 = r1b }\n\n// Stage 2\nvar t2 = []\nfor v in r1 { var t2b, _ = arrays.push(t2, do stage2(v)); t2 = t2b }\nvar r2 = []\nfor t in t2 { var r2b, _ = arrays.push(r2, await(t)); r2 = r2b }\n\nfmt.Println(\"pipeline output:\", r2) // For [1,2,3,4]: [(1*2)+10,...] =&gt; [12,14,16,18]\n</code></pre>"},{"location":"comprehensive_examples/#retry-with-exponential-backoff","title":"Retry with Exponential Backoff","text":"<p>Implement robust retries using <code>sleep()</code>; errors flow through regular return values.</p> Retry with exponential backoff<pre><code>package main\nimport fmt\nimport errors\n\n// Simulated flaky function\nfunction maybeFetch(id int) (string, error) {\n    if id % 2 == 1 { return (\"\", errors.New(\"transient error\")) }\n    sleep(20)\n    return (fmt.Sprintf(\"item-%d\", id), None)\n}\n\nfunction fetchWithRetry(id, maxRetries int) (string, error) {\n    var backoff = 50\n    var attempt = 0\n    while attempt &lt;= maxRetries {\n        var task = do maybeFetch(id)\n        var val, err = await(task)\n        if err == None { return (val, None) }\n        if attempt == maxRetries { return (\"\", err) }\n        sleep(backoff)\n        backoff = backoff * 2\n        attempt = attempt + 1\n    }\n    return (\"\", errors.New(\"unreachable\"))\n}\n\nvar v, err = fetchWithRetry(3, 3)\nif err != None { fmt.Println(\"failed:\", err) }\nelse { fmt.Println(\"ok:\", v) }\n</code></pre>"},{"location":"comprehensive_examples/#staggered-completion-and-ordering","title":"Staggered Completion and Ordering","text":"<p>Await order controls when you observe task results.</p> Staggered completion<pre><code>package main\nimport fmt\n\nfunction work(name string, ms int) string { sleep(ms); return name }\n\nvar tA = do work(\"A\", 200)\nvar tB = do work(\"B\", 20)\n\n// Awaiting A first blocks longer\nvar a = await(tA)\nvar b = await(tB)\nfmt.Printf(\"ordered await: %s %s\\n\", a, b)\n\n// Alternatively, await B first to proceed sooner\nvar tA2 = do work(\"A\", 200)\nvar tB2 = do work(\"B\", 20)\nvar b2 = await(tB2)\nvar a2 = await(tA2)\nfmt.Printf(\"reordered await: %s %s\\n\", a2, b2)\n</code></pre>"},{"location":"comprehensive_examples/#exec-examples","title":"Exec Examples","text":"<p>This section provides examples of using the <code>exec</code> module to launch applications and run commands on macOS.</p>"},{"location":"comprehensive_examples/#open-terminalapp","title":"Open Terminal.app","text":"Open Terminal.app<pre><code>package main\nimport exec\nimport fmt\n\nvar code, err = exec.RunCode(\"open\", \"-a\", \"Terminal\")\nif err != None {\n    fmt.Println(\"open Terminal failed:\", err)\n} else {\n    fmt.Println(\"Terminal launched, exit code:\", code)\n}\n</code></pre>"},{"location":"comprehensive_examples/#open-terminal-at-current-directory","title":"Open Terminal at current directory","text":"Open Terminal at current directory<pre><code>package main\nimport exec\nimport fmt\n\nvar code, err = exec.RunCode(\"open\", \"-a\", \"Terminal\", \".\")\nif err != None {\n    fmt.Println(\"open Terminal at . failed:\", err)\n} else {\n    fmt.Println(\"Terminal opened at current directory\")\n}\n</code></pre>"},{"location":"comprehensive_examples/#open-iterm-if-installed","title":"Open iTerm (if installed)","text":"Open iTerm<pre><code>package main\nimport exec\nimport fmt\n\nvar code, err = exec.RunCode(\"open\", \"-a\", \"iTerm\")\nif err != None {\n    fmt.Println(\"open iTerm failed:\", err)\n}\n</code></pre>"},{"location":"comprehensive_examples/#run-a-command-in-terminal-via-applescript","title":"Run a command in Terminal via AppleScript","text":"Run Terminal command via AppleScript<pre><code>package main\nimport exec\nimport fmt\n\nvar script = \"osascript -e 'tell application \\\"Terminal\\\" to do script \\\"echo hello from Harneet; ls -la; exit\\\"'\"\n\nvar code, err = exec.RunCode(\"/bin/sh\", \"-c\", script)\nif err != None {\n    fmt.Println(\"osascript failed:\", err)\n} else {\n    fmt.Println(\"Terminal launched to run command\")\n}\n</code></pre>"},{"location":"comprehensive_examples/#shellstdout-run-commands-within-current-process","title":"ShellStdout: run commands within current process","text":"ShellStdout example<pre><code>package main\nimport exec\nimport fmt\n\nvar out, err = exec.ShellStdout(\"echo shell-in-process; uname -a\")\nif err != None {\n    fmt.Println(\"ShellStdout error:\", err)\n} else {\n    fmt.Println(\"stdout:\", out)\n}\n</code></pre>"},{"location":"comprehensive_examples/#runwithoptions-set-env-and-working-directory","title":"RunWithOptions: set env and working directory","text":"RunWithOptions with env and cwd<pre><code>package main\nimport exec\nimport fmt\n\nvar args = [\"-c\", \"pwd; echo $MYVAR; ls -1 | head -5\"]\nvar envs = [\"MYVAR=hello_from_exec\"]\n\nvar out, err = exec.RunWithOptionsStdout(\"/bin/sh\", args, envs, \"/tmp\")\nif err != None {\n    fmt.Println(\"RunWithOptions error:\", err)\n} else {\n    fmt.Println(\"stdout:\", out)\n}\n</code></pre>"},{"location":"comprehensive_examples/#json-processing","title":"JSON Processing","text":"JSON processing<pre><code>package main\nimport json, fmt\n\nvar data = [\"apple\", \"banana\", \"cherry\"]\nvar jsonString, err = json.Marshal(data)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n    return\n}\n\nfmt.Println(\"JSON:\", jsonString)\n\nvar parsed, parseErr = json.Unmarshal(jsonString)\nif parseErr != None {\n    fmt.Println(\"Parse error:\", parseErr)\n    return\n}\n\nfmt.Println(\"Parsed back:\", parsed)\n</code></pre>"},{"location":"comprehensive_examples/#file-operations","title":"File Operations","text":"File Operations<pre><code>package main\nimport file, fmt\n\nvar content = \"Hello, World!\\nThis is Harneet!\"\nvar writeErr = file.Write(\"example.txt\", content)\nif writeErr != None {\n    fmt.Println(\"Write error:\", writeErr)\n    return\n}\n\nvar readContent, readErr = file.Read(\"example.txt\")\nif readErr != None {\n    fmt.Println(\"Read error:\", readErr)\n    return\n}\n\nfmt.Println(\"File content:\", readContent)\n</code></pre>"},{"location":"comprehensive_examples/#advanced-function-usage","title":"Advanced Function Usage","text":"Functions Usage<pre><code>package main\nimport fmt\n\n// Regular function with multiple returns\nfunction processData(data string) (string, string, bool) {\n    if data == \"\" {\n        return \"\", \"empty data\", false\n    }\n    return data.Upper(), \"\", true\n}\n\n// Arrow function for simple operations\nvar multiply = (a, b) =&gt; a * b\nvar greet = name =&gt; \"Hello, \" + name\n\n// Using functions\nvar result, error, success = processData(\"hello world\")\nif success {\n    fmt.Println(\"Result:\", result)\n} else {\n    fmt.Println(\"Error:\", error)\n}\n\nfmt.Println(\"Product:\", multiply(6, 7))\nfmt.Println(\"Greeting:\", greet(\"Alice\"))\n</code></pre>"},{"location":"comprehensive_examples/#file-io-examples","title":"File I/O Examples","text":"<p>This section provides comprehensive examples of file input/output operations.</p>"},{"location":"comprehensive_examples/#reading-writing-and-appending-files","title":"Reading, Writing, and Appending Files","text":"File I/O examples<pre><code>package main\nimport fmt\nimport file\nimport os\n\n// Create a new file and write content to it\nvar fileName = \"test_file.txt\"\nvar initialContent = \"Hello from Harneet!\"\nvar writeErr = file.Write(fileName, initialContent)\nif writeErr != None {\n    fmt.Println(\"Error writing to file:\", writeErr)\n    return\n}\nfmt.Println(\"Successfully wrote to\", fileName)\n\n// Read the content of the file\nvar content, readErr = file.Read(fileName)\nif readErr != None {\n    fmt.Println(\"Error reading file:\", readErr)\n    return\n}\nfmt.Println(\"Content of\", fileName, \":\", content)\n\n// Append content to the file\nvar appendedContent = \"\\nThis is a new line.\"\nvar appendErr = file.Append(fileName, appendedContent)\nif appendErr != None {\n    fmt.Println(\"Error appending to file:\", appendErr)\n    return\n}\nfmt.Println(\"Successfully appended to\", fileName)\n\n// Read the file again to see the appended content\nvar newContent, readAgainErr = file.Read(fileName)\nif readAgainErr != None {\n    fmt.Println(\"Error reading file again:\", readAgainErr)\n    return\n}\nfmt.Println(\"New content of\", fileName, \":\", newContent)\n\n// Clean up the created file\nos.Remove(fileName)\n</code></pre>"},{"location":"comprehensive_examples/#datetime-examples","title":"Datetime Examples","text":"<p>This section provides comprehensive examples of date and time operations.</p>"},{"location":"comprehensive_examples/#timezone-conversions-and-formatting","title":"Timezone Conversions and Formatting","text":"DateTime examples<pre><code>package main\nimport fmt\nimport datetime\n\n// Get the current time in UTC\nvar nowUTC, _ = datetime.Now()\nfmt.Println(\"Current UTC time (Unix):\", nowUTC)\n\n// Format the UTC time\nvar formattedUTC, _ = datetime.Format(nowUTC, \"RFC3339\")\nfmt.Println(\"Formatted UTC time:\", formattedUTC)\n\n// Convert to a different timezone\nvar newYorkTime, _ = datetime.ConvertTZ(nowUTC, \"UTC\", \"America/New_York\")\nvar formattedNY, _ = datetime.Format(newYorkTime, \"Kitchen\")\nfmt.Println(\"New York time:\", formattedNY)\n\n// Get the system's timezone\nvar systemTZ, _ = datetime.GetSystemTZ()\nfmt.Println(\"System timezone:\", systemTZ)\n</code></pre>"},{"location":"comprehensive_examples/#cron-job-scheduling","title":"Cron Job Scheduling","text":"Cron Job Scheduling<pre><code>package main\nimport fmt\nimport datetime\nimport time\n\n// Schedule a cron job to run every 2 seconds\nvar cronID = \"my_cron_job\"\nvar cronExpr = \"*/2 * * * * *\" // Every 2 seconds\nvar scheduleErr, _ = datetime.ScheduleCron(cronID, cronExpr)\nif scheduleErr != None {\n    fmt.Println(\"Error scheduling cron job:\", scheduleErr)\n    return\n}\nfmt.Println(\"Scheduled cron job with ID:\", cronID)\n\n// Let the cron job run for a few seconds\nfmt.Println(\"Waiting for cron job to run...\")\ntime.Sleep(5)\n\n// Stop the cron job\nvar stopErr, _ = datetime.StopCron(cronID)\nif stopErr != None {\n    fmt.Println(\"Error stopping cron job:\", stopErr)\n} else {\n    fmt.Println(\"Stopped cron job with ID:\", cronID)\n}\n</code></pre>"},{"location":"comprehensive_examples/#logging-examples","title":"Logging Examples","text":"<p>This section provides comprehensive examples of logging.</p>"},{"location":"comprehensive_examples/#logging-at-different-levels","title":"Logging at Different Levels","text":"Logging in Harneet<pre><code>package main\nimport log\n\nlog.Debug(\"This is a debug message.\")\nlog.Info(\"This is an info message.\")\nlog.Warn(\"This is a warning message.\")\nlog.Error(\"This is an error message.\")\n</code></pre>"},{"location":"comprehensive_examples/#setting-log-level","title":"Setting Log Level","text":"Setting up log levels<pre><code>package main\nimport log\n\n// Set the log level to WARN\nlog.SetLevel(\"WARN\")\n\nlog.Debug(\"This message will not be printed.\")\nlog.Info(\"This message will also not be printed.\")\nlog.Warn(\"This is a warning message that will be printed.\")\nlog.Error(\"This is an error message that will also be printed.\")\n\n// Reset log level to default (DEBUG)\nlog.SetLevel(\"DEBUG\")\n</code></pre>"},{"location":"comprehensive_examples/#redirecting-log-output-to-a-file","title":"Redirecting Log Output to a File","text":"Redirecting log outputs<pre><code>package main\nimport log\nimport file\nimport os\n\nvar logFile = \"app.log\"\n\n// Redirect log output to a file\nlog.SetOutput(logFile)\n\nlog.Info(\"This message will be written to the log file.\")\n\n// Reset log output to standard output\nlog.SetOutput(\"\")\n\n// Read the log file to verify the content\nvar logContent, _ = file.Read(logFile)\nfmt.Println(\"Log file content:\", logContent)\n\n// Clean up the log file\nos.Remove(logFile)\n</code></pre>"},{"location":"comprehensive_examples/#os-module-examples","title":"OS Module Examples","text":"<p>This section provides comprehensive examples of interacting with the operating system.</p>"},{"location":"comprehensive_examples/#device-information-and-drive-information","title":"Device Information and Drive Information","text":"Getting Device Information<pre><code>package main\nimport fmt\nimport os\n\n// List all connected devices\nvar devices, err = os.ListDevices()\nif err != None {\n    fmt.Println(\"Error listing devices:\", err)\n} else {\n    fmt.Println(\"Connected Devices:\", devices)\n}\n\n// Get detailed information about a specific device (example: first device in the list)\nif devices != None &amp;&amp; arrays.length(devices) &gt; 0 {\n    var firstDevice = devices[0]\n    var deviceInfo, err2 = os.GetDeviceInfo(firstDevice)\n    if err2 != None {\n        fmt.Println(\"Error getting device info for\", firstDevice, \":\", err2)\n    } else {\n        fmt.Println(\"Device Info for\", firstDevice, \":\", deviceInfo)\n    }\n} else {\n    fmt.Println(\"No devices found to get detailed information.\")\n}\n</code></pre>"},{"location":"error_handling_system/","title":"Error Handling System","text":"<p>Harneet implements a comprehensive Go-style error handling system that emphasizes explicit error checking and prevents silent failures.</p>"},{"location":"error_handling_system/#core-principles","title":"Core Principles","text":"<ol> <li>No Silent Failures: All functions that can fail return an error value.</li> <li>Explicit Error Checking: Errors must be explicitly checked using the <code>if err != None</code> pattern.</li> <li>Multiple Return Values: Functions return <code>(result, error)</code> tuples.</li> <li>Error Propagation: Errors bubble up through the call stack unless handled.</li> </ol>"},{"location":"error_handling_system/#syntax","title":"Syntax","text":""},{"location":"error_handling_system/#multiple-return-values","title":"Multiple Return Values","text":"<pre><code>package main\nvar result, err = strings.ToInt(\"123\")\nvar content, err = file.Read(\"config.txt\")\nvar x, y, err = someFunction()\n</code></pre>"},{"location":"error_handling_system/#error-checking-pattern","title":"Error Checking Pattern","text":"<pre><code>package main\nvar value, err = riskyFunction()\nif err != None {\n    fmt.Println(\"Error occurred:\", err)\n    return err // Propagate error up\n}\n// Safe to use value here\nfmt.Println(\"Success:\", value)\n</code></pre>"},{"location":"error_handling_system/#built-in-error-types","title":"Built-in Error Types","text":"<ul> <li>None: Represents no error (similar to Go's nil).</li> <li>Error Values: First-class error objects with descriptive messages.</li> </ul>"},{"location":"error_handling_system/#standard-library-error-handling","title":"Standard Library Error Handling","text":"<p>All standard library functions return errors:</p> <pre><code>// String conversion with error handling\npackage main\nvar num, err = strings.ToInt(\"invalid\")\nif err != None {\n    fmt.Println(\"Conversion failed:\", err)\n    // Handle error appropriately\n}\n\n// Math operations with error checking\nvar result, err = math.Pow(2, 64) // May overflow\nif err != None {\n    fmt.Println(\"Math error:\", err)\n}\n</code></pre>"},{"location":"error_handling_system/#error-categories","title":"Error Categories","text":"<ul> <li>TypeError: Type conversion or mismatch errors</li> <li>ValueError: Invalid values (division by zero, invalid conversions)</li> <li>RangeError: Values outside acceptable ranges</li> <li>ArithmeticError: Mathematical operation errors</li> </ul>"},{"location":"error_handling_system/#runtime-assertions","title":"Runtime Assertions","text":"<p>The <code>assert</code> module provides runtime assertions for testing and debugging.</p> <pre><code>package main\nimport assert\n\n// Development-time checks that panic on failure\nassert.Assert(x &gt; 0, \"x must be positive\")\nassert.AssertEq(actual, expected, \"values should match\")\nassert.AssertNe(result, None, \"result should not be None\")\n</code></pre>"},{"location":"error_handling_system/#stack-trace-system","title":"Stack Trace System","text":"<p>Harneet provides comprehensive stack trace information for all runtime errors, making debugging fast and efficient.</p>"},{"location":"error_handling_system/#features","title":"Features","text":"<ul> <li>Precise Location: Exact file name, line number, and column position</li> <li>Call Hierarchy: Complete function call stack showing execution path</li> <li>Error Context: Clear error messages with full debugging information</li> <li>Multi-level Traces: Nested function calls show complete call chain</li> </ul>"},{"location":"error_handling_system/#stack-trace-format","title":"Stack Trace Format","text":"<p>When an error occurs, Harneet displays detailed debugging information:</p> <pre><code>ERROR: division by zero\nStack trace:\n  at &lt;program&gt; (examples/myfile.ha:5:22)\n  at math.Max (examples/myfile.ha:5:33)\n</code></pre>"},{"location":"error_handling_system/#stack-trace-components","title":"Stack Trace Components","text":"<p>Each stack frame includes: - Function Name: <code>&lt;program&gt;</code> for top-level code, <code>module.function</code> for library calls - File Location: Complete file path relative to execution directory - Position: Exact <code>line:column</code> where error occurred or call was made</p>"},{"location":"error_handling_system/#error-types-with-stack-traces","title":"Error Types with Stack Traces","text":""},{"location":"error_handling_system/#arithmetic-errors","title":"Arithmetic Errors","text":"<pre><code>package main\nvar result = 10 / 0  // Division by zero\n// Output:\n// ERROR: division by zero\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:1:15)\n</code></pre>"},{"location":"error_handling_system/#identifier-errors","title":"Identifier Errors","text":"<pre><code>package main\nvar x = undefinedVariable  // Variable not found\n// Output:\n// ERROR: identifier not found: undefinedVariable\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:1:8)\n</code></pre>"},{"location":"error_handling_system/#function-call-errors","title":"Function Call Errors","text":"<pre><code>package main\nimport math\nvar result = math.Max(42, 10 / 0)  // Error in nested call\n// Output:\n// ERROR: division by zero\n// Stack trace:\n//   at &lt;program&gt; (myfile.ha:2:22)\n//   at math.Max (myfile.ha:2:33)\n</code></pre>"},{"location":"error_handling_system/#type-conversion-errors","title":"Type Conversion Errors","text":"<pre><code>package main\nimport strings\nvar num, err = strings.ToInt(\"not_a_number\")\nif err != None {\n    // Error is handled gracefully with descriptive message\n    fmt.Println(\"Error:\", err)\n}\n</code></pre>"},{"location":"error_handling_system/#parser-errors","title":"Parser Errors","text":"<pre><code>package main\nvar x = 42 +   // Incomplete expression (syntax error)\n// Output:\n// Woops! Sincere apologies, but we ran into some errors while running the program!\n// Stack trace:\n//  parser errors:\n//    no prefix parse function for DIVIDE found\n//    no prefix parse function for ERROR_TYPE found\n//    no prefix parse function for ILLEGAL found\n</code></pre>"},{"location":"error_handling_system/#benefits","title":"Benefits","text":"<ul> <li>Immediate Location: Know exactly where errors occur</li> <li>Call Context: Understand how execution reached the error</li> <li>File Information: No guessing which file contains the problem</li> <li>Debugging Speed: Quick navigation to problem areas</li> </ul>"},{"location":"modules/","title":"Module System","text":"<p>Harneet supports a comprehensive module system with Go.mod integration for external dependencies and version management.</p>"},{"location":"modules/#overview","title":"Overview","text":"<p>The module system provides:</p> <ul> <li>go.mod integration - Standard Go module files for dependency management</li> <li>External module resolution - Automatic downloading and caching of dependencies</li> <li>Version management - Semantic versioning support</li> <li>Import path mapping - Clean import syntax for external modules</li> <li>Module caching - Efficient local caching in <code>imports/</code> directory</li> </ul>"},{"location":"modules/#project-structure","title":"Project Structure","text":"<pre><code>myproject/\n\u251c\u2500\u2500 go.mod              # Module definition and dependencies\n\u251c\u2500\u2500 main.ha             # Main application file\n\u251c\u2500\u2500 imports/            # Downloaded external modules (auto-generated)\n\u2502   \u251c\u2500\u2500 github.com/example/utils@v1.0.0/\n\u2502   \u2514\u2500\u2500 github.com/example/math@v1.2.0/\n\u2514\u2500\u2500 local/              # Local packages\n    \u2514\u2500\u2500 mypackage/\n</code></pre>"},{"location":"modules/#gomod-file","title":"go.mod File","text":"<p>Create a <code>go.mod</code> file in your project root:</p> <pre><code>module example.com/myproject\n\ngo 1.21\n\nrequire (\n    github.com/example/utils v1.0.0\n    github.com/example/math v1.2.0\n)\n</code></pre>"},{"location":"modules/#import-syntax","title":"Import Syntax","text":""},{"location":"modules/#external-modules","title":"External Modules","text":"<pre><code>import \"github.com/example/utils\" as utils\nimport \"github.com/example/math\" as math\n\nfunction main() {\n    var result = utils.FormatString(\"Hello, %s!\", \"World\")\n    var sum = math.Add(10, 20)\n}\n</code></pre>"},{"location":"modules/#local-packages","title":"Local Packages","text":"<pre><code>import \"./local/mypackage\" as pkg\nimport \"../shared/common\" as common\n</code></pre> <p>HMOD Tool</p> <p>HMOD tool is not needed. We are stil working on bringing go packages to Harneet. Kindly stay tuned. As of today , you dont need HMOD tool</p>"},{"location":"modules/#module-management-tool","title":"Module Management Tool","text":"<p>Use the <code>hmod</code> tool to manage dependencies:</p>"},{"location":"modules/#initialize-a-project","title":"Initialize a Project","text":"<pre><code>hmod init --module example.com/myproject\n</code></pre>"},{"location":"modules/#add-dependencies","title":"Add Dependencies","text":"<pre><code>hmod require --module github.com/example/utils --version v1.0.0\n</code></pre>"},{"location":"modules/#download-dependencies","title":"Download Dependencies","text":"<pre><code>hmod download\n</code></pre>"},{"location":"modules/#list-dependencies","title":"List Dependencies","text":"<pre><code>hmod list\n</code></pre>"},{"location":"modules/#clean-cache","title":"Clean Cache","text":"<pre><code>hmod clean\n</code></pre>"},{"location":"modules/#module-resolution","title":"Module Resolution","text":"<p>The module system resolves imports in the following order:</p> <ol> <li>Standard Library - Built-in modules (fmt, json, os, etc.)</li> <li>External Modules - Modules listed in go.mod</li> <li>Local Packages - Relative path imports (./package, ../package)</li> </ol>"},{"location":"modules/#external-module-resolution","title":"External Module Resolution","text":"<p>For import <code>github.com/example/utils/strings</code>:</p> <ol> <li>Parse go.mod to find matching module <code>github.com/example/utils v1.0.0</code></li> <li>Check if module exists in <code>imports/github.com/example/utils@v1.0.0/</code></li> <li>If not found, download module automatically</li> <li>Resolve subpath: <code>imports/github.com/example/utils@v1.0.0/strings/</code></li> </ol>"},{"location":"modules/#version-management","title":"Version Management","text":""},{"location":"modules/#semantic-versioning","title":"Semantic Versioning","text":"<p>Harneet follows semantic versioning (semver):</p> <pre><code>require (\n    github.com/example/utils v1.0.0    // Exact version\n    github.com/example/math v1.2.0     // Exact version\n)\n</code></pre>"},{"location":"modules/#version-constraints","title":"Version Constraints","text":"<p>Currently supported: - Exact versions: <code>v1.0.0</code> - Pre-release: <code>v1.0.0-alpha.1</code> - Build metadata: <code>v1.0.0+build.1</code></p>"},{"location":"modules/#module-downloading","title":"Module Downloading","text":"<p>The module manager supports multiple download methods:</p>"},{"location":"modules/#go-module-cache","title":"Go Module Cache","text":"<pre><code># Uses go mod download when available\ngo mod download github.com/example/utils@v1.0.0\n</code></pre>"},{"location":"modules/#git-clone-fallback","title":"Git Clone Fallback","text":"<pre><code># Falls back to git clone for repositories\ngit clone --depth 1 --branch v1.0.0 https://github.com/example/utils.git\n</code></pre>"},{"location":"modules/#supported-hosting","title":"Supported Hosting","text":"<ul> <li>GitHub: <code>github.com/user/repo</code></li> <li>GitLab: <code>gitlab.com/user/repo</code></li> <li>Bitbucket: <code>bitbucket.org/user/repo</code></li> <li>Custom: Any git-accessible repository</li> </ul>"},{"location":"modules/#module-caching","title":"Module Caching","text":"<p>Downloaded modules are cached in the <code>imports/</code> directory:</p> <pre><code>imports/\n\u251c\u2500\u2500 github.com/example/utils@v1.0.0/\n\u2502   \u251c\u2500\u2500 strings/\n\u2502   \u2502   \u2514\u2500\u2500 strings.ha\n\u2502   \u2514\u2500\u2500 format/\n\u2502       \u2514\u2500\u2500 format.ha\n\u2514\u2500\u2500 github.com/example/math@v1.2.0/\n    \u251c\u2500\u2500 basic/\n    \u2502   \u2514\u2500\u2500 math.ha\n    \u2514\u2500\u2500 advanced/\n        \u2514\u2500\u2500 calc.ha\n</code></pre>"},{"location":"modules/#cache-management","title":"Cache Management","text":"<ul> <li>Automatic: Modules downloaded on first import</li> <li>Manual: Use <code>harneet-mod download</code> to pre-download</li> <li>Cleanup: Use <code>harneet-mod clean</code> to remove cache</li> </ul>"},{"location":"modules/#package-structure","title":"Package Structure","text":"<p>External modules should follow Harneet package conventions:</p>"},{"location":"modules/#package-declaration","title":"Package Declaration","text":"<pre><code>// strings/strings.ha\npackage strings\n\n// Exported function (uppercase)\nfunction FormatString(template string, args ...interface{}) string {\n    // Implementation\n}\n\n// Private function (lowercase)\nfunction helper(s string) string {\n    // Implementation\n}\n</code></pre>"},{"location":"modules/#exports","title":"Exports","text":"<p>Only uppercase identifiers are exported:</p> <pre><code>// Exported\nvar DefaultTimeout int = 30\nfunction ProcessData() {}\ntype User struct {}\n\n// Not exported\nvar internalConfig = {}\nfunction parseInternal() {}\ntype privateType struct {}\n</code></pre>"},{"location":"modules/#integration-examples","title":"Integration Examples","text":""},{"location":"modules/#configuration-management-with-viper","title":"Configuration Management with Viper","text":"<pre><code>// go.mod\nmodule example.com/sample-project\n\nrequire (\n    github.com/spf13/viper v1.17.0\n    github.com/fatih/color v1.15.0\n)\n</code></pre> <pre><code>// main.ha\npackage main\n\nimport fmt\nimport \"github.com/spf13/viper\" as viper\nimport \"github.com/fatih/color\" as color\n\nfunction init() {\n    viper.SetConfigName(\"config\")\n    viper.SetConfigType(\"toml\")\n    viper.AddConfigPath(\".\")\n}\n\nfunction main() {\n    var green = color.New(color.FgGreen).SprintFunc()\n\n    var err = viper.ReadInConfig()\n    if err != nil {\n        fmt.Printf(\"Error reading config: %v\\n\", err)\n        return\n    }\n\n    var appName = viper.GetString(\"app.name\")\n    var port = viper.GetInt(\"app.port\")\n\n    fmt.Printf(\"%s App: %s running on port %d\\n\", green(\"\u2705\"), appName, port)\n}\n</code></pre>"},{"location":"modules/#cli-tool","title":"CLI Tool","text":"<pre><code>// go.mod\nmodule example.com/cli-tool\n\nrequire (\n    github.com/urfave/cli/v2 v2.25.0\n    github.com/fatih/color v1.15.0\n)\n</code></pre> <pre><code>// main.ha\npackage main\n\nimport \"github.com/urfave/cli/v2\" as cli\nimport \"github.com/fatih/color\" as color\n\nfunction main() {\n    var app = cli.NewApp()\n    app.Name = \"mytool\"\n\n    color.Green(\"CLI tool ready!\")\n}\n</code></pre>"},{"location":"modules/#best-practices","title":"Best Practices","text":""},{"location":"modules/#module-organization","title":"Module Organization","text":"<ol> <li>Single Purpose: Each module should have a clear, single purpose</li> <li>Clear Exports: Export only necessary functions and types</li> <li>Documentation: Document exported functions and types</li> <li>Versioning: Use semantic versioning for releases</li> </ol>"},{"location":"modules/#import-management","title":"Import Management","text":"<ol> <li>Group Imports: Group standard library, external, and local imports</li> <li>Meaningful Aliases: Use clear, descriptive import aliases</li> <li>Avoid Conflicts: Prevent naming conflicts with aliases</li> </ol> <pre><code>// Good import grouping\nimport fmt\nimport json\n\nimport \"github.com/example/utils\" as utils\nimport \"github.com/example/math\" as math\n\nimport \"./local/database\" as db\nimport \"../shared/config\" as config\n</code></pre>"},{"location":"modules/#dependency-management","title":"Dependency Management","text":"<ol> <li>Pin Versions: Use exact versions in production</li> <li>Regular Updates: Keep dependencies updated</li> <li>Security: Review dependencies for security issues</li> <li>Minimal Dependencies: Only add necessary dependencies</li> </ol>"},{"location":"modules/#error-handling","title":"Error Handling","text":""},{"location":"modules/#module-not-found","title":"Module Not Found","text":"<pre><code>ERROR: module or package 'github.com/example/missing' not found\n</code></pre> <p>Solution: Add module to go.mod and run <code>harneet-mod download</code></p>"},{"location":"modules/#version-conflicts","title":"Version Conflicts","text":"<pre><code>ERROR: version conflict for github.com/example/utils\n</code></pre> <p>Solution: Update go.mod with compatible versions</p>"},{"location":"modules/#download-failures","title":"Download Failures","text":"<pre><code>ERROR: failed to download module github.com/example/utils: git clone failed\n</code></pre> <p>Solution: Check network connectivity and repository access</p>"},{"location":"modules/#advanced-features","title":"Advanced Features","text":""},{"location":"modules/#module-replacement","title":"Module Replacement","text":"<pre><code>// go.mod\nreplace github.com/example/utils =&gt; ./local/utils\n</code></pre>"},{"location":"modules/#indirect-dependencies","title":"Indirect Dependencies","text":"<pre><code>require (\n    github.com/example/utils v1.0.0\n    github.com/example/math v1.2.0 // indirect\n)\n</code></pre>"},{"location":"modules/#build-constraints","title":"Build Constraints","text":"<pre><code>// +build linux darwin\n\npackage platform\n\n// Platform-specific code\n</code></pre>"},{"location":"modules/#migration-guide","title":"Migration Guide","text":""},{"location":"modules/#from-local-packages","title":"From Local Packages","text":"<ol> <li>Create go.mod file</li> <li>Move packages to external repositories</li> <li>Update import paths</li> <li>Use harneet-mod to manage dependencies</li> </ol>"},{"location":"modules/#from-other-languages","title":"From Other Languages","text":"<ol> <li>Identify equivalent Harneet packages</li> <li>Create go.mod with dependencies</li> <li>Adapt import syntax</li> <li>Update function calls to match Harneet conventions</li> </ol>"},{"location":"modules/#troubleshooting","title":"Troubleshooting","text":""},{"location":"modules/#common-issues","title":"Common Issues","text":"<ol> <li>Import cycles: Reorganize package dependencies</li> <li>Version conflicts: Update to compatible versions</li> <li>Missing modules: Add to go.mod and download</li> <li>Permission errors: Check file system permissions</li> </ol>"},{"location":"modules/#debug-mode","title":"Debug Mode","text":"<pre><code>HARNEET_DEBUG=1 ./harneet main.ha\n</code></pre>"},{"location":"modules/#verbose-logging","title":"Verbose Logging","text":"<pre><code>hmod download --verbose\n</code></pre> <p>This module system brings enterprise-level dependency management to Harneet while maintaining simplicity and Go-like familiarity.</p>"},{"location":"type_system_safety/","title":"Type System &amp; Safety","text":"<p>Harneet features a robust and comprehensive type system designed to ensure code correctness and prevent runtime errors through static analysis.</p>"},{"location":"type_system_safety/#comprehensive-type-checking","title":"Comprehensive Type Checking","text":"<ul> <li> <p>Static Type Analysis: Harneet performs complete type checking during the parsing phase, catching type-related errors before runtime.</p> <pre><code>```harneet\n// Example: Type mismatch caught at compile time\nvar num int = \"hello\" // Error: Cannot assign string to int\n```\n</code></pre> </li> <li> <p>Function Parameter Validation: Automatic type checking ensures that function calls provide arguments matching the declared parameter types, with detailed error messages for mismatches.</p> <pre><code>```harneet\nfunction add(a int, b int) int {\n    return a + b\n}\nvar result = add(10, \"hello\") // Error: Argument 'hello' (string) cannot be assigned to parameter 'b' (int)\n```\n</code></pre> </li> <li> <p>Variable Type Declarations: Explicit type annotations (e.g., <code>var x int = 42</code>) allow for compile-time validation, ensuring type consistency.</p> <pre><code>```harneet\nvar age int = 30\n// var age string = \"thirty\" // Error: Cannot re-declare 'age' with a different type\n```\n</code></pre> </li> <li> <p>Return Type Validation: Functions must return values that match their declared return types.</p> <pre><code>```harneet\nfunction getNumber() int {\n    return \"hello\" // Error: Function declared to return int, but returning string\n}\n```\n</code></pre> </li> <li> <p>Array Type Consistency: Arrays can be type-safe (e.g., <code>int[]</code>, <code>string[]</code>, <code>bool[]</code>), with validation of element types.</p> <pre><code>```harneet\nvar numbers = [1, 2, 3] // Inferred as int[]\n// numbers = [1, \"hello\"] // Error: Cannot assign string to int[] array\n```\n</code></pre> </li> <li> <p>Advanced Type Inference: The language features sophisticated type inference for expressions, arrays, and function calls, reducing the need for explicit type declarations.</p> <pre><code>```harneet\nvar inferredNum = 10          // inferred as int\nvar inferredStr = \"Harneet\"   // inferred as string\nvar inferredBool = true       // inferred as bool\n```\n</code></pre> </li> <li> <p>Type Compatibility: Smart type compatibility rules are applied for numeric types and safe conversions.</p> <pre><code>```harneet\nvar intVal int = 10\nvar floatVal float64 = intVal // int can be assigned to float64\n// var anotherInt int = floatVal // Error: float64 cannot be assigned to int without explicit conversion\n```\n</code></pre> </li> <li> <p>Enhanced Error Messages: Detailed error messages provide helpful suggestions and precise locations for type-related issues.</p> <pre><code>```harneet\n// Example of an enhanced error message\n// Calling a function with wrong argument type might produce:\n// Error: Argument 'hello' (string) cannot be assigned to parameter 'b' (int) in function 'add' at line 5, column 12.\n// Suggestion: Ensure argument type matches parameter type.\n```\n</code></pre> </li> <li> <p>Zero Runtime Type Errors: Static analysis aims to prevent type-related errors from occurring at runtime.</p> <pre><code>```harneet\n// Because of static analysis, code like this will not even run:\n// var x int = \"abc\" // Caught at compile time, preventing runtime crash\n```\n</code></pre> </li> <li> <p>Zero Value Type Safety: All declared variables automatically receive appropriate zero values for their respective types, ensuring predictable behavior.</p> <pre><code>```harneet\nvar defaultInt int       // defaultInt is 0\nvar defaultString string // defaultString is \"\"\nvar defaultBool bool     // defaultBool is false\n```\n</code></pre> </li> </ul>"},{"location":"type_system_safety/#development-features","title":"Development Features","text":"<p>The type system is complemented by several development features that aid in debugging and code quality.</p> <ul> <li>REPL Support: The interactive Read-Eval-Print Loop (REPL) provides immediate feedback on type correctness during development.</li> <li>Debug Mode: A comprehensive logging system with a <code>-debug</code> flag helps in tracing type-related issues.</li> <li>Stack Traces: Detailed error traces with source locations provide context for type errors.</li> <li>Import Analysis: The system detects unused and duplicate imports, promoting cleaner code.</li> <li>Error Suggestions: Helpful error messages often include suggestions for fixing type-related problems.</li> </ul>"},{"location":"type_system_safety/#the-any-type","title":"The <code>any</code> Type","text":"<p>Harneet supports the <code>any</code> type as a top type (supertype of all types) with strict, one-way assignability rules. This design preserves Harneet's strong typing while enabling flexibility at dynamic boundaries like JSON, OS, regex, and external APIs.</p>"},{"location":"type_system_safety/#strict-assignability-rules","title":"Strict Assignability Rules","text":"<p>The <code>any</code> type follows these strict rules:</p> <ul> <li>T \u2192 any (Upcast): \u2705 ALLOWED - Any concrete type can be assigned to <code>any</code></li> <li>any \u2192 T (Downcast): \u274c FORBIDDEN - Requires explicit cast using the <code>cast</code> module</li> </ul> <p>This one-way assignability prevents type safety violations while allowing flexibility where needed.</p> <pre><code>// \u2705 Upcast to any - ALLOWED\nvar anyInt any = 42\nvar anyString any = \"hello\"\nvar anyMap any = {\"key\": \"value\"}\n\n// \u274c Downcast without cast - FORBIDDEN\nvar x any = 42\nvar num int = x  // COMPILE ERROR: cannot assign any to int\n\n// \u2705 Explicit cast - REQUIRED for downcast\nvar num, err = cast.ToInt(x)  // OK\nif err == None {\n    fmt.Printf(\"Number: %d\\n\", num)\n}\n</code></pre>"},{"location":"type_system_safety/#when-to-use-any","title":"When to Use <code>any</code>","text":"<p>\u2705 Good Use Cases:</p> <ol> <li> <p>JSON Parsing - Dynamic JSON data     <pre><code>var data, _ = json.Unmarshal(jsonString)\nvar userMap, _ = cast.ToMap(data)\n</code></pre></p> </li> <li> <p>External APIs - Heterogeneous system data     <pre><code>function processAPIResponse(response any) {\n    var data, _ = cast.ToMap(response)\n    // Process typed data...\n}\n</code></pre></p> </li> <li> <p>Configuration - Dynamic config values     <pre><code>var config = {\n    \"port\": 8080,\n    \"host\": \"localhost\",\n    \"debug\": true\n}\n</code></pre></p> </li> <li> <p>Generic Utilities - Flexible helper functions     <pre><code>function logValue(key string, value any) {\n    fmt.Printf(\"%s: %v\\n\", key, value)\n}\n</code></pre></p> </li> </ol> <p>\u274c Avoid Using <code>any</code>:</p> <ol> <li>Internal business logic - Use precise types</li> <li>Public APIs - Prefer concrete types for clarity</li> <li>Data structures - Use typed collections</li> </ol>"},{"location":"type_system_safety/#explicit-narrowing","title":"Explicit Narrowing","text":"<p>The <code>cast</code> module provides type-safe narrowing from <code>any</code> to concrete types:</p> <pre><code>import cast\n\nvar mystery any = \"12345\"\n\n// Method 1: Direct conversion\nvar num, err = cast.ToInt(mystery)\nif err == None {\n    fmt.Printf(\"Converted: %d\\n\", num)\n}\n\n// Method 2: Preflight check\nvar canConvert, _ = cast.CanCast(mystery, \"int\")\nif canConvert {\n    var num, _ = cast.ToInt(mystery)\n    // Safe to use num\n}\n</code></pre> <p>Available Cast Functions: - <code>cast.ToInt(any)</code> - Convert to integer - <code>cast.ToString(any)</code> - Convert to string - <code>cast.ToBool(any)</code> - Convert to boolean - <code>cast.ToFloat(any)</code> - Convert to float - <code>cast.ToArray(any)</code> - Convert to array - <code>cast.ToMap(any)</code> - Convert to map - <code>cast.CanCast(any, type)</code> - Check if conversion is possible</p>"},{"location":"type_system_safety/#best-practices","title":"Best Practices","text":"<p>Early Narrowing Pattern (Recommended):</p> <pre><code>import cast\n\n// Good: Narrow at boundary, keep core typed\nfunction processConfig(config any) {\n    // Narrow immediately\n    var configMap, err = cast.ToMap(config)\n    if err != None {\n        fmt.Println(\"Error: config must be a map\")\n        return\n    }\n\n    // Now work with typed data\n    var port, _ = cast.ToInt(configMap[\"port\"])\n    var host, _ = cast.ToString(configMap[\"host\"])\n\n    // Core logic uses concrete types\n    startServer(host, port)\n}\n</code></pre> <p>Type Guard Pattern:</p> <pre><code>function handleDynamic(val any) {\n    // Try each type in order\n    var asInt, intErr = cast.ToInt(val)\n    if intErr == None {\n        handleInteger(asInt)\n        return\n    }\n\n    var asString, strErr = cast.ToString(val)\n    if strErr == None {\n        handleString(asString)\n        return\n    }\n\n    fmt.Println(\"Unsupported type\")\n}\n</code></pre>"},{"location":"type_system_safety/#type-safety-guarantees","title":"Type Safety Guarantees","text":"<p>The <code>any</code> type maintains Harneet's strong type safety through:</p> <ol> <li>Compile-Time Enforcement - Cannot assign <code>any</code> to concrete types without explicit cast</li> <li>Runtime Validation - Cast functions validate conversions and return errors</li> <li>No Implicit Conversions - All narrowing must be explicit</li> <li>Clear Error Messages - Detailed feedback when conversions fail</li> </ol> <pre><code>var x any = \"not a number\"\nvar y, err = cast.ToInt(x)\n// err contains: \"cannot convert string \\\"not a number\\\" to integer\"\n</code></pre>"},{"location":"type_system_safety/#zero-values-system","title":"Zero Values System","text":"<p>Harneet automatically initializes all declared variables to their \"zero value\" if no explicit value is provided. This ensures that variables always have a defined state.</p> <pre><code>// All integer types initialize to 0\nvar intVal int           // 0\nvar int8Val int8         // 0\nvar int16Val int16       // 0\nvar int32Val int32       // 0\nvar int64Val int64       // 0\nvar uintVal uint         // 0\nvar uint8Val uint8       // 0\nvar uint16Val uint16     // 0\nvar uint32Val uint32     // 0\nvar uint64Val uint64     // 0\nvar uintptrVal uintptr   // 0\n\n// Float types initialize to 0.0\nvar float32Val float32   // 0.0\nvar float64Val float64   // 0.0\n\n// String type initializes to empty string\nvar stringVal string     // \"\"\n\n// Boolean type initializes to false\nvar boolVal bool         // false\n\n// Mixed zero value and explicit assignments\nvar zeroInt int          // 0 (zero value)\nvar assignedInt int = 42 // 42 (explicit value)\n</code></pre>"},{"location":"type_system_safety/#multiple-assignment-examples","title":"Multiple Assignment Examples","text":"<p>The type system works seamlessly with multiple assignment, ensuring type safety even when multiple values are returned or assigned.</p> <pre><code>// Function returns (traditional tuple assignment)\nvar result, err = math.Abs(-42)\nvar upper, upperErr = strings.Upper(\"hello\")\n\n// Multiple expressions with explicit types\nvar name string, age int, score float64 = \"Alice\", 25, 98.5\nvar x int, y int, z int = 10, 20, 30\n\n// Mixed explicit and inferred types\nvar first string, second, third int = \"test\", 42, 100\n\n// Short assignment with multiple expressions\na, b, c := \"hello\", 123, true\ncoordinates := 1.0, 2.0, 3.0\n\n// Blank identifier support\nvar value, _ = math.Max(10, 5)  // Discard error\nvar _, important, _ = \"ignore\", \"keep\", \"ignore\"\n</code></pre>"},{"location":"functions/advanced_features/","title":"Advanced Function Features","text":"<p>Harneet functions support several advanced features that make them powerful and flexible.</p>"},{"location":"functions/advanced_features/#multiple-return-values","title":"Multiple Return Values","text":"<p>A function can return multiple values. This is particularly useful for returning a result and an error, which is a common pattern in Harneet.</p> Function returning multiple return values<pre><code>package main\nimport fmt\n\nfunction divide(a float64, b float64) (float64, string) {\n    if b == 0 {\n        return 0.0, \"division by zero\"\n    }\n    return a / b, \"\"\n}\n\nvar result, err = divide(10, 2)\nif err != \"\" {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 5\n}\n\nvar result2, err2 = divide(10, 0)\nif err2 != \"\" {\n    fmt.Println(\"Error:\", err2) // Output: Error: division by zero\n} else {\n    fmt.Println(\"Result:\", result2)\n}\n</code></pre>"},{"location":"functions/advanced_features/#closures-and-function-returns","title":"Closures and Function Returns","text":"<p>Functions in Harneet are closures, which means they can access variables from their enclosing scope. This enables powerful patterns when returning functions.</p>"},{"location":"functions/advanced_features/#basic-closure","title":"Basic Closure","text":"Closure example in Harneet<pre><code>package main\nimport fmt\n\nfunction outer() function() {\n    var x = 10\n    function inner() {\n        fmt.Println(x)\n    }\n    return inner\n}\n\nvar closure = outer()\nclosure() // Output: 10\n</code></pre>"},{"location":"functions/advanced_features/#closure-with-state-capture","title":"Closure with State Capture","text":"Closure capturing state<pre><code>package main\nimport fmt\n\nfunction createCounter(start int) function() int {\n    var count = start\n    function increment() int {\n        count = count + 1\n        return count\n    }\n    return increment\n}\n\nvar counter1 = createCounter(0)\nvar counter2 = createCounter(100)\n\nfmt.Println(counter1()) // Output: 1\nfmt.Println(counter1()) // Output: 2\nfmt.Println(counter2()) // Output: 101\nfmt.Println(counter1()) // Output: 3\n</code></pre>"},{"location":"functions/advanced_features/#factory-functions","title":"Factory Functions","text":"Factory function pattern<pre><code>package main\nimport fmt\n\nfunction createValidator(minLength int) function(string) bool {\n    function validate(input string) bool {\n        // Note: In a real implementation, you'd have string length function\n        // This is a simplified example\n        return input != \"\"  // Simplified validation\n    }\n    return validate\n}\n\nvar passwordValidator = createValidator(8)\nvar usernameValidator = createValidator(3)\n\nfmt.Println(passwordValidator(\"secret\"))    // Output: true\nfmt.Println(usernameValidator(\"\"))          // Output: false\n</code></pre>"},{"location":"functions/advanced_features/#first-class-functions","title":"First-Class Functions","text":"<p>Functions are first-class citizens in Harneet, which means they can be treated like any other value. They can be assigned to variables, passed as arguments to other functions, and returned from functions.</p> Functions are first class<pre><code>package main\nimport fmt\n\nfunction apply(f function(int) int, value int) int {\n    return f(value)\n}\n\nfunction double(x int) int {\n    return x * 2\n}\n\nvar result = apply(double, 5)\nfmt.Println(result) // Output: 10\n</code></pre>"},{"location":"functions/advanced_features/#assigning-functions-to-variables","title":"Assigning functions to variables","text":"<p>Like in most other languages, you can assign functions to a variable. The following code demonstrates that</p> Assigning functions to variables<pre><code>package main\nimport fmt\n\nfunction greet() {\n    fmt.Println(\"Hello World\")\n}\n\nx := greet // here we assign the function to a variable\nx() //now we call it\n</code></pre>"},{"location":"functions/arrow_functions/","title":"Arrow Functions","text":"<p>Harneet supports ES6-style arrow functions, which provide a more concise syntax for writing functions.</p>"},{"location":"functions/arrow_functions/#syntax","title":"Syntax","text":""},{"location":"functions/arrow_functions/#single-parameter","title":"Single parameter","text":"<p>If there is only one parameter, the parentheses are optional.</p> <pre><code>package main\nvar double = x =&gt; x * 2\n</code></pre>"},{"location":"functions/arrow_functions/#multiple-parameters","title":"Multiple parameters","text":"<p>If there are multiple parameters, the parentheses are required.</p> <pre><code>package main\nvar add = (a, b) =&gt; a + b\n</code></pre> <p>Avoid using return</p> <p>If you are using an inline arrow function, and you are using <code>return</code> it will raise an arror. For example the following will create an error <pre><code>    var double = x =&gt; return x *2\n</code></pre> If you still want to use return, you are encouraged to use <code>block body</code> variant. In block body you must use return to return values.</p>"},{"location":"functions/arrow_functions/#block-body","title":"Block body","text":"<p>For a multi-line function body, you can use a block body with an explicit <code>return</code> statement.</p> <pre><code>package main\nvar complex = (x, y) =&gt; {\n    var result = x + y\n    return result * 2\n}\n</code></pre>"},{"location":"functions/arrow_functions/#examples","title":"Examples","text":"<pre><code>package main\nimport fmt\n\nvar double = x =&gt; x * 2\nfmt.Println(double(5)) // Output: 10\n\nvar add = (a, b) =&gt; a + b\nfmt.Println(add(5, 10)) // Output: 15\n\nvar complex = (x, y) =&gt; {\n    var result = x + y\n    return result * 2\n}\nfmt.Println(complex(5, 10)) // Output: 30\n</code></pre>"},{"location":"functions/functional/","title":"Functional Programming in Harneet","text":"<p>Harneet is Haskell-inspired, not Haskell-like: it aims to offer practical, type-safe functional patterns without the steep learning curve. You get first-class functions, higher-order functions, closures, and composition patterns while keeping imperative ergonomics.</p> <ul> <li>\"Haskell-inspired\" rather than \"Haskell-like\"</li> <li>\"Functionally powerful\" rather than \"purely functional\"</li> <li>\"Type-safe functional\" rather than \"academic functional\"</li> </ul> <p>This guide shows composition, piping, map/filter/reduce, and a simple chaining pipeline you can copy into your projects.</p>"},{"location":"functions/functional/#composition","title":"Composition","text":"<p>Use typed helpers for predictable, type-checked composition.</p> <pre><code>package main\nimport fmt\n\n// composeInt(f, g): returns x -&gt; f(g(x)) where f,g: int-&gt;int\nfunction composeInt(f function(int) int, g function(int) int) function(int) int {\n    return function(x int) int { return f(g(x)) }\n}\n\n// composeStrInt(f, g): returns x -&gt; f(g(x)) where g: int-&gt;int, f: int-&gt;string\nfunction composeStrInt(f function(int) string, g function(int) int) function(int) string {\n    return function(x int) string { return f(g(x)) }\n}\n\nfunction inc(n int) int { return n + 1 }\nfunction double(n int) int { return n * 2 }\nfunction toString(n int) string { return fmt.Sprintf(\"%d\", n) }\n\nvar incAfterDouble = composeInt(inc, double)\nfmt.Printf(\"composeInt(inc, double)(3) = %d\\n\", incAfterDouble(3))  // 7\n\nvar toStrAfterIncAfterDouble = composeStrInt(toString, composeInt(inc, double))\nfmt.Printf(\"composeStrInt(toString, composeInt(inc, double))(5) = %s\\n\", toStrAfterIncAfterDouble(5))\n</code></pre>"},{"location":"functions/functional/#piping","title":"Piping","text":"<p>Left-to-right application with a typed helper. This example uses <code>int -&gt; int</code> functions.</p> <pre><code>// pipeInt(x, f1, f2, ...) applies int-&gt;int functions in order\npackage main\nfunction pipeInt(x int, fns array) int {\n    var result = x\n    for fn in fns { result = fn(result) }\n    return result\n}\n\nfunction inc(n int) int { return n + 1 }\nfunction double(n int) int { return n * 2 }\n\nfmt.Printf(\"pipeInt(3, [double, inc]) = %d\\n\", pipeInt(3, [double, inc]))  // 7\n</code></pre>"},{"location":"functions/functional/#map-filter-reduce-typed-helpers","title":"Map / Filter / Reduce (typed helpers)","text":"<p>Use typed helpers for int arrays. These examples rely on the standard <code>arrays</code> module for safe appends.</p> <pre><code>package main\nimport fmt\nimport arrays\n\nfunction mapInt(arr array, f function(int) int) array {\n    var out = []\n    for x in arr {\n        var next, err = arrays.push(out, f(x))\n        if err == None { out = next }\n    }\n    return out\n}\n\nfunction filterInt(arr array, p function(int) bool) array {\n    var out = []\n    for x in arr {\n        if p(x) {\n            var next, err = arrays.push(out, x)\n            if err == None { out = next }\n        }\n    }\n    return out\n}\n\nfunction reduceInt(arr array, init int, f function(int, int) int) int {\n    var acc = init\n    for x in arr { acc = f(acc, x) }\n    return acc\n}\n\nfunction inc(n int) int { return n + 1 }\nfunction isEven(n int) bool { return n % 2 == 0 }\nfunction sum(a int, b int) int { return a + b }\n\nvar nums = [1, 2, 3, 4, 5]\nvar mapped = mapInt(nums, inc)          // [2,3,4,5,6]\nvar evens  = filterInt(mapped, isEven)  // [2,4,6]\nvar total  = reduceInt(evens, 0, sum)   // 12\n\nfmt.Printf(\"mapped: %s\\n\", mapped)\nfmt.Printf(\"evens: %s\\n\", evens)\nfmt.Printf(\"sum: %d\\n\", total)\n</code></pre>"},{"location":"functions/functional/#chaining-pipeline","title":"Chaining Pipeline","text":"<p>A deterministic pipeline (map -&gt; filter -&gt; reduce) without anonymous inline lambdas (works well with current parser).</p> <pre><code>package main\nimport fmt\nimport arrays\n\nfunction composeInt(f function(int) int, g function(int) int) function(int) int {\n    return function(x int) int { return f(g(x)) }\n}\n\nfunction mapInt(arr array, f function(int) int) array {\n    var out = []\n    for x in arr {\n        var next, err = arrays.push(out, f(x))\n        if err == None { out = next }\n    }\n    return out\n}\n\nfunction filterInt(arr array, p function(int) bool) array {\n    var out = []\n    for x in arr {\n        if p(x) {\n            var next, err = arrays.push(out, x)\n            if err == None { out = next }\n        }\n    }\n    return out\n}\n\nfunction reduceInt(arr array, init int, f function(int, int) int) int {\n    var acc = init\n    for x in arr { acc = f(acc, x) }\n    return acc\n}\n\nfunction inc(n int) int { return n + 1 }\nfunction square(n int) int { return n * n }\nfunction isOdd(n int) bool { return n % 2 == 1 }\nfunction add(a int, b int) int { return a + b }\n\nvar data = [1,2,3,4,5]\nvar squareAfterInc = composeInt(square, inc)\n\nvar mapped = mapInt(data, squareAfterInc)\nvar filtered = filterInt(mapped, isOdd)\nvar result = reduceInt(filtered, 0, add)\n\nfmt.Printf(\"result = %d\\n\", result)\n</code></pre>"},{"location":"functions/functional/#tips","title":"Tips","text":"<ul> <li>Prefer typed helpers over <code>any</code> when composing functions; this works best with the current type checker.</li> <li>Use <code>arrays.push</code> rather than <code>append</code>\u2014Harneet\u2019s stdlib provides an array module with safe operations and error tuples.</li> <li>If you want <code>compose</code>/<code>pipe</code> that work across multiple types, create additional typed variants (e.g., <code>composeStrInt</code>, <code>composeFloat</code>, etc.).</li> </ul>"},{"location":"functions/functional/#see-also","title":"See Also","text":"<ul> <li>Examples in repo:</li> <li><code>examples/functional/compose.ha</code></li> <li><code>examples/functional/map_filter_reduce.ha</code></li> <li><code>examples/functional/chaining_demo.ha</code></li> <li>Standard library: <code>site/docs/stdlib/arrays.md</code></li> <li>Functions overview: <code>site/docs/functions/introduction.md</code></li> </ul>"},{"location":"functions/introduction/","title":"Introduction to Functions","text":"<p>Functions are reusable blocks of code that perform a specific task. They are a fundamental building block of Harneet programs and support advanced features like returning other functions, closures, and higher-order programming.</p>"},{"location":"functions/introduction/#declaration-syntax","title":"Declaration Syntax","text":"<p>The basic syntax for declaring a function is as follows:</p> <pre><code>package main\nfunction functionName(param1 type1, param2 type2) returnType {\n    // function body\n    return value\n}\n</code></pre> <ul> <li><code>function</code>: The keyword to declare a function.</li> <li><code>functionName</code>: The name of the function.</li> <li><code>(param1 type1, param2 type2)</code>: The list of parameters with their types.</li> <li><code>returnType</code>: The type of the value returned by the function.</li> <li><code>{ ... }</code>: The body of the function containing the code to be executed.</li> <li><code>return</code>: The keyword to return a value from the function.</li> </ul>"},{"location":"functions/introduction/#basic-examples","title":"Basic Examples","text":""},{"location":"functions/introduction/#function-with-a-single-return-value","title":"Function with a single return value","text":"<pre><code>package main\nimport fmt\n\nfunction square(x int) int {\n    return x * x\n}\n\nvar result = square(5)\nfmt.Println(result) // Output: 25\n</code></pre>"},{"location":"functions/introduction/#function-with-no-parameters","title":"Function with no parameters","text":"<pre><code>package main\nimport fmt\n\nfunction getAnswer() int {\n    return 42\n}\n\nvar answer = getAnswer()\nfmt.Println(answer) // Output: 42\n</code></pre>"},{"location":"functions/introduction/#function-with-no-return-value","title":"Function with no return value","text":"<pre><code>package main\nimport fmt\n\nfunction printMessage() {\n    fmt.Println(\"Hello, Harneet!\")\n}\n\nprintMessage() // Output: Hello, Harneet!\n</code></pre>"},{"location":"functions/introduction/#returning-functions","title":"Returning Functions","text":"<p>Harneet supports returning functions from other functions, enabling powerful functional programming patterns like closures and higher-order functions.</p>"},{"location":"functions/introduction/#basic-function-return","title":"Basic Function Return","text":"<pre><code>package main\nimport fmt\n\nfunction getGreeter() function(string) string {\n    function greet(name string) string {\n        return \"Hello, \" + name + \"!\"\n    }\n    return greet\n}\n\nvar greeter = getGreeter()\nvar message = greeter(\"World\")\nfmt.Println(message) // Output: Hello, World!\n</code></pre>"},{"location":"functions/introduction/#closures-with-variable-capture","title":"Closures with Variable Capture","text":"<p>Functions can capture variables from their enclosing scope, creating closures:</p> <pre><code>package main\nimport fmt\n\nfunction createAdder(x int) function(int) int {\n    function inner(y int) int {\n        return x + y  // Captures 'x' from outer scope\n    }\n    return inner\n}\n\nvar add5 = createAdder(5)\nvar result = add5(3)\nfmt.Println(result) // Output: 8\n</code></pre>"},{"location":"functions/introduction/#returning-arrow-functions","title":"Returning Arrow Functions","text":"<p>You can also return arrow functions for more concise syntax:</p> <pre><code>package main\nimport fmt\n\nfunction createMultiplier(factor int) function(int) int {\n    return x =&gt; x * factor\n}\n\nvar double = createMultiplier(2)\nvar triple = createMultiplier(3)\n\nfmt.Printf(\"Double 5: %d\\n\", double(5))   // Output: Double 5: 10\nfmt.Printf(\"Triple 4: %d\\n\", triple(4))  // Output: Triple 4: 12\n</code></pre>"},{"location":"functions/introduction/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions can return functions that themselves return functions, enabling complex functional patterns:</p> <pre><code>package main\nimport fmt\n\nfunction createCalculator() function(string) function(int, int) int {\n    function getOperation(op string) function(int, int) int {\n        if op == \"add\" {\n            return (a, b) =&gt; a + b\n        } else if op == \"subtract\" {\n            return (a, b) =&gt; a - b\n        } else {\n            return (a, b) =&gt; a * b\n        }\n    }\n    return getOperation\n}\n\nvar calculator = createCalculator()\nvar addFunc = calculator(\"add\")\nvar subFunc = calculator(\"subtract\")\n\nfmt.Printf(\"10 + 5 = %d\\n\", addFunc(10, 5))  // Output: 10 + 5 = 15\nfmt.Printf(\"10 - 5 = %d\\n\", subFunc(10, 5))  // Output: 10 - 5 = 5\n</code></pre>"},{"location":"functions/introduction/#conditional-function-returns","title":"Conditional Function Returns","text":"<p>Functions can return different functions based on runtime conditions:</p> <pre><code>package main\nimport fmt\n\nfunction createMathOperation(operation string) function(int, int) int {\n    if operation == \"add\" {\n        function add(a int, b int) int {\n            return a + b\n        }\n        return add\n    } else {\n        function multiply(a int, b int) int {\n            return a * b\n        }\n        return multiply\n    }\n}\n\nvar addOp = createMathOperation(\"add\")\nvar multiplyOp = createMathOperation(\"multiply\")\n\nfmt.Printf(\"Add: %d\\n\", addOp(10, 20))        // Output: Add: 30\nfmt.Printf(\"Multiply: %d\\n\", multiplyOp(4, 5)) // Output: Multiply: 20\n</code></pre>"},{"location":"functions/introduction/#function-type-annotations","title":"Function Type Annotations","text":"<p>Harneet provides comprehensive support for function type annotations, enabling strong type safety for higher-order functions and functional programming patterns.</p>"},{"location":"functions/introduction/#function-parameters-with-function-types","title":"Function Parameters with Function Types","text":"<p>You can specify function types as parameters, enabling type-safe higher-order functions:</p> <pre><code>package main\nimport fmt\n\n// Function that takes another function as a parameter\nfunction apply(f function(int) int, value int) int {\n    return f(value)\n}\n\n// Function that takes multiple function parameters\nfunction compose(f function(int) int, g function(int) int, value int) int {\n    return f(g(value))\n}\n\n// Test functions\nfunction double(x int) int {\n    return x * 2\n}\n\nfunction addTen(x int) int {\n    return x + 10\n}\n\n// Usage with full type validation\nvar result1 = apply(double, 5)           // Output: 10\nvar result2 = compose(double, addTen, 5) // Output: 30\n\nfmt.Printf(\"apply(double, 5) = %d\\n\", result1)\nfmt.Printf(\"compose(double, addTen, 5) = %d\\n\", result2)\n</code></pre>"},{"location":"functions/introduction/#function-variables-with-type-annotations","title":"Function Variables with Type Annotations","text":"<p>Variables can be declared with specific function types:</p> <pre><code>package main\nimport fmt\n\n// Declare a function variable with a specific signature\nvar handler function(int) int\n\n// Helper function\nfunction increment(x int) int {\n    return x + 1\n}\n\n// Assign function to typed variable\nhandler = increment\n\n// Use the function variable\nvar result = handler(7)\nfmt.Printf(\"handler(7) = %d\\n\", result) // Output: 8\n</code></pre>"},{"location":"functions/introduction/#multiple-parameter-function-types","title":"Multiple Parameter Function Types","text":"<p>Function types can specify multiple parameters and different return types:</p> <pre><code>package main\nimport fmt\n\n// Function expecting a binary operation\nfunction calculate(op function(int, int) int, a int, b int) int {\n    return op(a, b)\n}\n\n// Function expecting a string transformation\nfunction transform(fn function(string) string, text string) string {\n    return fn(text)\n}\n\n// Test functions\nfunction add(x int, y int) int {\n    return x + y\n}\n\nfunction toUpper(s string) string {\n    return \"[UPPER]\" + s\n}\n\n// Usage with type validation\nvar sum = calculate(add, 10, 5)\nvar upper = transform(toUpper, \"hello\")\n\nfmt.Printf(\"calculate(add, 10, 5) = %d\\n\", sum)      // Output: 15\nfmt.Printf(\"transform(toUpper, \\\"hello\\\") = %s\\n\", upper) // Output: [UPPER]hello\n</code></pre>"},{"location":"functions/introduction/#arrow-functions-with-type-annotations","title":"Arrow Functions with Type Annotations","text":"<p>Arrow functions work seamlessly with function type annotations:</p> <pre><code>package main\nimport fmt\n\n// Function expecting a function parameter\nfunction processNumbers(processor function(int) int, numbers []int) []int {\n    var results []int\n    for _, num := range numbers {\n        results = append(results, processor(num))\n    }\n    return results\n}\n\n// Arrow functions can be passed directly\nvar doubled = processNumbers(x =&gt; x * 2, [1, 2, 3, 4])\nvar squared = processNumbers(x =&gt; x * x, [1, 2, 3, 4])\n\nfmt.Printf(\"Doubled: %v\\n\", doubled) // Output: [2, 4, 6, 8]\nfmt.Printf(\"Squared: %v\\n\", squared) // Output: [1, 4, 9, 16]\n</code></pre>"},{"location":"functions/introduction/#type-safety-and-error-detection","title":"Type Safety and Error Detection","text":"<p>Harneet's function type system provides comprehensive compile-time validation:</p> <pre><code>package main\nimport fmt\n\nfunction apply(f function(int) int, value int) int {\n    return f(value)\n}\n\nfunction double(x int) int {\n    return x * 2\n}\n\nfunction toUpper(s string) string {\n    return \"[UPPER]\" + s\n}\n\n// \u2705 This works - correct types\nvar result1 = apply(double, 5)\n\n// \u274c These would cause compile-time errors:\n// apply(toUpper, 5)     // Error: toUpper expects string, not int\n// apply(5, 10)          // Error: 5 is not a function\n// apply(double, \"text\") // Error: double expects int, not string\n</code></pre>"},{"location":"functions/introduction/#advanced-function-type-patterns","title":"Advanced Function Type Patterns","text":""},{"location":"functions/introduction/#factory-functions-with-type-safety","title":"Factory Functions with Type Safety","text":"<pre><code>package main\nimport fmt\n\n// Factory function returning typed function\nfunction createValidator(minLength int) function(string) bool {\n    function validate(input string) bool {\n        // In practice, you'd check string length\n        return input != \"\"\n    }\n    return validate\n}\n\n// Type-safe usage\nvar passwordValidator = createValidator(8)\nvar isValid = passwordValidator(\"mypassword\")\nfmt.Printf(\"Password valid: %t\\n\", isValid)\n</code></pre>"},{"location":"functions/introduction/#callback-pattern-with-type-validation","title":"Callback Pattern with Type Validation","text":"<pre><code>package main\nimport fmt\n\n// Function with callback parameter\nfunction processData(data int, callback function(int) int, errorHandler function(string)) int {\n    if data &lt; 0 {\n        errorHandler(\"Invalid data: negative number\")\n        return 0\n    }\n    return callback(data)\n}\n\n// Callback functions\nfunction processValue(x int) int {\n    return x * 2\n}\n\nfunction handleError(msg string) {\n    fmt.Printf(\"Error: %s\\n\", msg)\n}\n\n// Type-safe callback usage\nvar result = processData(10, processValue, handleError)\nfmt.Printf(\"Processed result: %d\\n\", result)\n</code></pre>"},{"location":"functions/introduction/#key-benefits","title":"Key Benefits","text":""},{"location":"functions/introduction/#type-safety","title":"\ud83d\udd12 Type Safety","text":"<ul> <li>Compile-time validation of function signatures</li> <li>Prevention of runtime type errors</li> <li>Clear error messages for type mismatches</li> </ul>"},{"location":"functions/introduction/#performance","title":"\ud83d\ude80 Performance","text":"<ul> <li>No runtime type checking overhead</li> <li>Optimized function calls</li> <li>Early error detection</li> </ul>"},{"location":"functions/introduction/#code-clarity","title":"\ud83d\udcd6 Code Clarity","text":"<ul> <li>Self-documenting function interfaces</li> <li>Clear expectations for function parameters</li> <li>Better IDE support and tooling</li> </ul>"},{"location":"functions/introduction/#flexibility","title":"\ud83d\udd27 Flexibility","text":"<ul> <li>Works with all function types (named, anonymous, arrow)</li> <li>Supports complex nested function signatures</li> <li>Compatible with existing code patterns</li> </ul> <p>The function type system in Harneet provides the perfect balance of type safety and flexibility, enabling robust functional programming while maintaining code clarity and performance.</p>"},{"location":"general/arrays/","title":"Arrays","text":"<p>Arrays are ordered collections of elements. They are a versatile data structure for storing lists of values.</p>"},{"location":"general/arrays/#array-literals","title":"Array Literals","text":"<p>You can create an array using an array literal:</p> <pre><code>package main\nvar numbers = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"general/arrays/#mixed-types","title":"Mixed Types","text":"<p>Arrays in Harneet can hold elements of different types.</p> <pre><code>package main\nvar mixed = [1, \"hello\", 3.14, true]\n</code></pre>"},{"location":"general/arrays/#nested-arrays","title":"Nested Arrays","text":"<p>You can create nested arrays (arrays of arrays).</p> <pre><code>package main\nvar matrix = [[1, 2], [3, 4]]\n</code></pre>"},{"location":"general/arrays/#slicing","title":"Slicing","text":"<p>Harneet supports Go-like slicing on arrays, typed arrays, and strings using the <code>s[a:b]</code> syntax (also <code>[:b]</code>, <code>[a:]</code>, and <code>[:]</code>). Indices are integers, clamped to valid bounds; the slice is half-open (<code>a</code> inclusive, <code>b</code> exclusive); if <code>a &gt; b</code>, the result is empty.</p> <p>See the Slicing section for full semantics and examples: arrays module documentation.</p>"},{"location":"general/arrays/#array-operations","title":"Array Operations","text":"<p>For a comprehensive list of functions to manipulate arrays, see the <code>arrays</code> module documentation.</p>"},{"location":"general/block_structure/","title":"Block Structure","text":"<p>Harneet uses curly braces <code>{}</code> to define blocks of code. These blocks group statements together.</p>"},{"location":"general/block_structure/#blocks","title":"Blocks","text":"<ul> <li>Purpose: Blocks are used to group statements, typically associated with control flow statements (like <code>if</code>, <code>for</code>, <code>switch</code>) or function definitions.</li> <li>Syntax: Statements within a block are enclosed in curly braces <code>{}</code>.</li> </ul> <pre><code>package main\nif condition {\n    // statements inside the block\n    fmt.Println(\"Condition is true\")\n}\n</code></pre>"},{"location":"general/block_structure/#statement-terminators","title":"Statement Terminators","text":"<p>Harneet supports both newlines and semicolons as statement terminators. You can use either, or mix them.</p> <ul> <li>Newline: A new line implicitly terminates a statement.</li> <li>Semicolon: A semicolon <code>;</code> explicitly terminates a statement.</li> </ul> <pre><code>// Using newlines\npackage main\nvar x = 10\nvar y = 20\n\n// Using semicolons\nvar a = 1; var b = 2;\n</code></pre>"},{"location":"general/block_structure/#indentation","title":"Indentation","text":"<p>Indentation is not syntactically significant in Harneet (unlike Python), but it is highly recommended for readability and maintaining consistent code style.</p>"},{"location":"general/comments/","title":"Comments","text":"<p>Harneet implement C-style comments, the best commenting system ever to be used by humankind. Comments are used to add explanatory notes to your code. They are ignored by the interpreter.</p> <p>There are two types of comments - </p>"},{"location":"general/comments/#line-comments","title":"Line Comments","text":"<p>Line comments start with <code>//</code>. Everything from <code>//</code> to the end of the line is a comment.</p> <pre><code>// This is a line comment\npackage main\nvar x = 42 // This is also a line comment\n</code></pre>"},{"location":"general/comments/#block-comments","title":"Block Comments","text":"<p>Block comments start with <code>/*</code> and end with <code>*/</code>. They can span multiple lines.</p> <pre><code>/*\nThis is a block comment.\nIt can span multiple lines.\n*/\npackage main\nvar y = 10\n</code></pre>"},{"location":"general/concurrency/","title":"Concurrency: do, await, sleep","text":"<p>Harneet provides a simple, readable concurrency model inspired by Go\u2019s goroutines and modern async/await syntax:</p> <ul> <li>do spawns work concurrently and returns immediately with a Task handle.</li> <li>await(task) blocks until the Task completes and returns the function\u2019s result.</li> <li>sleep(ms) suspends the current task for the given milliseconds.</li> </ul> <p>Under the hood, a <code>do</code> expression runs your call in a lightweight task and returns a <code>Task</code> object you can <code>await</code> later.</p>"},{"location":"general/concurrency/#quick-start","title":"Quick start","text":"<pre><code>package main\nimport fmt\n\nfunction work(name string, ms int) string {\n    fmt.Printf(\"start %s\\n\", name)\n    sleep(ms)\n    fmt.Printf(\"done  %s\\n\", name)\n    return name\n}\n\nfmt.Println(\"\\n=== Concurrency Demo: do / await / sleep ===\")\n\nvar t1 = do work(\"A\", 150)\nvar t2 = do work(\"B\", 60)\n\nvar r2 = await(t2)   // B likely finishes first\nvar r1 = await(t1)\n\nfmt.Printf(\"Results: %s %s\\n\", r1, r2)\nfmt.Println(\"\u2705 Concurrency example complete!\\n\")\n</code></pre> <p>What happens: - <code>do work(...)</code> starts immediately and returns a <code>Task</code> handle without waiting. - <code>await(task)</code> waits for completion and yields the underlying return value. - <code>sleep(ms)</code> pauses the running task only.</p>"},{"location":"general/concurrency/#api-reference","title":"API reference","text":"<ul> <li>do  \u2192 Task <li>Starts the call concurrently and returns a <code>Task</code> handle.</li> <li> <p>Example: <code>var t = do fetch(url)</code></p> </li> <li> <p>await(task: Task) \u2192 any</p> </li> <li>Waits for the task to finish and returns the call\u2019s result (or <code>None</code>).</li> <li> <p>Example: <code>var data = await(t)</code></p> </li> <li> <p>sleep(ms: int) \u2192 None</p> </li> <li>Suspends the current task for <code>ms</code> milliseconds (must be non-negative).</li> <li>Example: <code>sleep(100)</code></li> <p>Notes: - Errors are returned by your function in the normal way (e.g., tuples <code>(value, error)</code>), and <code>await()</code> simply yields that same return value. There is no separate \u201crejection\u201d channel. - Task inspection prints whether a task is pending or done with its result.</p>"},{"location":"general/concurrency/#patterns","title":"Patterns","text":""},{"location":"general/concurrency/#1-fan-out-fan-in","title":"1) Fan-out / fan-in","text":"<p>Spawn many tasks, then gather results:</p> <pre><code>import fmt\n\nfunction square(n int) int {\n    sleep(30) // simulate work\n    return n * n\n}\n\nvar nums = [1, 2, 3, 4, 5]\nvar tasks = []\nfor n in nums { tasks = append(tasks, do square(n)) }\n\nvar results = []\nfor t in tasks { results = append(results, await(t)) }\n\nfmt.Printf(\"squares: %v\\n\", results)  // [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"general/concurrency/#2-parallel-map-helper","title":"2) Parallel map helper","text":"<pre><code>function pmap(values array, f function(any) any) array {\n    var tasks = []\n    for v in values { tasks = append(tasks, do f(v)) }\n\n    var out = []\n    for t in tasks { out = append(out, await(t)) }\n    return out\n}\n\nfunction inc(x int) int { return x + 1 }\n\nvar res = pmap([1,2,3,4], inc)\n// res = [2,3,4,5]\n</code></pre>"},{"location":"general/concurrency/#3-handling-errors-with-tuples","title":"3) Handling errors with tuples","text":"<p>If your function returns <code>(value, error)</code>, just await and handle the tuple:</p> <pre><code>import fmt\n\nfunction fetch(id int) (string, error) {\n    if id &lt; 0 { return (\"\", errors.New(\"bad id\")) }\n    sleep(20)\n    return (fmt.Sprintf(\"item-%d\", id), None)\n}\n\nvar t = do fetch(42)\nvar item, err = await(t)\nif err != None { fmt.Printf(\"error: %v\\n\", err) }\nelse { fmt.Printf(\"ok: %s\\n\", item) }\n</code></pre>"},{"location":"general/concurrency/#4-staggered-completion","title":"4) Staggered completion","text":"<p>Tasks can complete in any order; await determines when you observe results:</p> <pre><code>var t1 = do work(\"A\", 200)\nvar t2 = do work(\"B\", 20)\n\n// If you await t1 first, you\u2019ll block until A is done\nvar r1 = await(t1)\nvar r2 = await(t2)\n</code></pre>"},{"location":"general/concurrency/#scheduler-api","title":"Scheduler API","text":"<p>Harneet includes a small, developer-friendly scheduler API for orchestrating tasks and handling timeouts and cancellation. It is designed to be type-safe and never swallow errors.</p>"},{"location":"general/concurrency/#overview","title":"Overview","text":"<ul> <li>TaskGroup: group and operate on multiple tasks together</li> <li>Methods: <code>add(task)</code>, <code>addAll(array)</code>, <code>awaitAll() -&gt; array</code>, <code>awaitAny() -&gt; (index int, result any)</code>, <code>len() -&gt; int</code>, <code>clear()</code>, <code>tasks() -&gt; array</code></li> <li>Timeouts: <code>awaitWithTimeout(task, ms) -&gt; (result any, error)</code></li> <li>Cancellation: cooperative token primitives</li> <li><code>newCancelToken() -&gt; CancelToken</code></li> <li><code>cancel(token)</code></li> <li><code>isCancelled(token) -&gt; bool</code></li> <li><code>sleepUntil(ms, token) -&gt; (None, error)</code></li> </ul>"},{"location":"general/concurrency/#examples","title":"Examples","text":"<pre><code>import fmt\n\nfunction work(name string, ms int) string {\n    sleep(ms)\n    return name\n}\n\n// 1) Grouping tasks\nvar g = newGroup()\nvar t1 = do work(\"A\", 120)\nvar t2 = do work(\"B\", 40)\ng.add(t1).add(t2)\n\nvar idx, first = g.awaitAny()     // returns (index, result)\nfmt.Printf(\"first: %d %v\\n\", idx, first)\n\nvar all = g.awaitAll()            // returns [result1, result2]\nfmt.Println(all)\n\n// 2) Timeout awaiting a task\nvar slow = do work(\"SLOW\", 200)\nvar value, err = awaitWithTimeout(slow, 75)\nif err != None { fmt.Printf(\"timeout: %v\\n\", err) }\nelse { fmt.Printf(\"value: %v\\n\", value) }\n\n// 3) Cancellation\nfunction cancellable(name string, ms int, token any) (string, error) {\n    var _, e = sleepUntil(ms, token)\n    if e != None { return (\"\", e) }\n    return (name, None)\n}\n\nvar tok = newCancelToken()\nvar tc = do cancellable(\"X\", 200, tok)\ncancel(tok)\nvar res, cerr = await(tc)\nif cerr != None { fmt.Printf(\"cancelled: %v\\n\", cerr) }\n</code></pre>"},{"location":"general/concurrency/#design-notes","title":"Design notes","text":"<ul> <li>Concurrency is implemented via lightweight tasks; <code>do</code> is analogous to spawning a goroutine.</li> <li><code>await()</code> acts like a join on a single task and returns the task\u2019s result.</li> <li><code>sleep()</code> blocks only the current task, not the whole program.</li> <li>Built-in timeouts and cancellation are available:</li> <li><code>awaitWithTimeout(task, ms)</code> produces <code>(result, error)</code> and never swallows errors.</li> <li><code>newCancelToken()</code> + <code>cancel()</code> enable cooperative cancellation; pair with <code>sleepUntil(ms, token)</code>.</li> </ul>"},{"location":"general/concurrency/#see-also","title":"See also","text":"<ul> <li>Example file: <code>examples/concurrency/do_await_sleep_test.ha</code></li> <li>Control flow: <code>site/docs/general/control_flow.md</code></li> </ul>"},{"location":"general/const/","title":"Const Declarations","text":"<p>Harneet supports Go-like const declarations for creating immutable values. Constants are evaluated at compile time and cannot be reassigned after declaration.</p>"},{"location":"general/const/#basic-syntax","title":"Basic Syntax","text":"<pre><code>const PI = 3.14159\nconst MaxRetries = 5\nconst AppName = \"Harneet Lang\"\nconst IsDebug = true\n</code></pre>"},{"location":"general/const/#type-inference-and-explicit-types","title":"Type Inference and Explicit Types","text":"<p>Constants support both type inference and explicit type annotations:</p> <pre><code>// Type inference (recommended)\nconst InferredInt = 42\nconst InferredFloat = 3.14\nconst InferredString = \"hello\"\nconst InferredBool = true\n\n// Explicit type annotations\nconst ExplicitInt int = 42\nconst ExplicitFloat float64 = 3.14\nconst ExplicitString string = \"hello\"\nconst ExplicitBool bool = true\n</code></pre>"},{"location":"general/const/#immutability","title":"Immutability","text":"<p>Constants are immutable and cannot be reassigned:</p> <pre><code>const ReadOnlyValue = 42\n\nfunction main() {\n    // This will cause a compile-time error\n    ReadOnlyValue = 100  // Error: cannot assign to const variable 'ReadOnlyValue'\n}\n</code></pre>"},{"location":"general/const/#expression-evaluation","title":"Expression Evaluation","text":"<p>Constants can be initialized with expressions:</p> <pre><code>const Sum = 10 + 20 + 30\nconst Product = 5 * 6\nconst Concatenated = \"Hello\" + \" \" + \"World\"\nconst LogicalResult = true and false\n</code></pre>"},{"location":"general/const/#export-rules-go-like-convention","title":"Export Rules (Go-like Convention)","text":"<p>Constants follow Go-like export conventions based on naming:</p> <pre><code>// Exported (accessible from other packages)\nconst ExportedConstant = \"This can be accessed from other packages\"\nconst PI = 3.14159\nconst MaxConnections = 100\n\n// Package-private (not exported)\nconst privateConstant = \"This is package-private\"\nconst debugMode = true\n</code></pre> <p>Constants with title-case names (starting with uppercase letter) are exported and can be accessed from other packages.</p>"},{"location":"general/const/#usage-examples","title":"Usage Examples","text":""},{"location":"general/const/#mathematical-constants","title":"Mathematical Constants","text":"<pre><code>const PI = 3.14159265359\nconst E = 2.71828182846\nconst GoldenRatio = 1.61803398875\n\nfunction calculateCircleArea(radius float64) float64 {\n    return PI * radius * radius\n}\n</code></pre>"},{"location":"general/const/#configuration-constants","title":"Configuration Constants","text":"<pre><code>const MaxConnections = 100\nconst DefaultTimeout = 30\nconst ServerName = \"Harneet Server\"\nconst EnableLogging = true\n\nfunction getServerConfig() {\n    fmt.Printf(\"Server: %s\\n\", ServerName)\n    fmt.Printf(\"Max Connections: %d\\n\", MaxConnections)\n    fmt.Printf(\"Timeout: %d seconds\\n\", DefaultTimeout)\n    fmt.Printf(\"Logging: %t\\n\", EnableLogging)\n}\n</code></pre>"},{"location":"general/const/#string-constants","title":"String Constants","text":"<pre><code>const WelcomeMessage = \"Welcome to Harneet!\"\nconst ErrorPrefix = \"[ERROR]\"\nconst SuccessPrefix = \"[SUCCESS]\"\n\nfunction logSuccess(message string) {\n    fmt.Printf(\"%s %s\\n\", SuccessPrefix, message)\n}\n</code></pre>"},{"location":"general/const/#differences-from-variables","title":"Differences from Variables","text":"Feature Variables (<code>var</code>) Constants (<code>const</code>) Mutability Mutable Immutable Zero Values Supported Not supported (must have value) Reassignment Allowed Compile-time error Scope Block/function scope Block/function scope Export Rules Same (title-case) Same (title-case)"},{"location":"general/const/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive names: <code>MaxRetries</code> instead of <code>MAX_RETRIES</code></li> <li>Group related constants: Keep configuration constants together</li> <li>Use type inference: Let the compiler infer types when obvious</li> <li>Follow export conventions: Use title-case for exported constants</li> <li>Prefer constants for fixed values: Use constants for values that never change</li> </ol>"},{"location":"general/const/#error-cases","title":"Error Cases","text":"<pre><code>// Error: const declaration must have a value\nconst MissingValue  // \u274c Error\n\n// Error: cannot assign to const variable\nconst Value = 42\nValue = 100  // \u274c Error\n\n// Error: type mismatch\nconst TypeMismatch int = \"string\"  // \u274c Error\n</code></pre>"},{"location":"general/const/#integration-with-other-features","title":"Integration with Other Features","text":"<p>Constants work seamlessly with other Harneet features:</p> <ul> <li>Functions: Can be used as default parameter values</li> <li>Control Flow: Can be used in if conditions and loop bounds</li> <li>Expressions: Can be used in any expression context</li> <li>Type System: Full type checking and inference support</li> <li>Modules: Export/import following Go-like conventions</li> </ul>"},{"location":"general/control_flow/","title":"Control Flow Structures","text":"<p>Harneet provides a variety of control flow structures to direct the execution of your program.</p>"},{"location":"general/control_flow/#control-flow-rules","title":"Control Flow Rules","text":"<ol> <li>If Conditions: Must evaluate to a truthy or falsy value</li> <li>Case Matching: Exact value equality (==) is used for case comparison</li> <li>Type Consistency: All cases in a switch must use the same data type</li> <li>Default Case: Optional catch-all for unmatched values</li> <li>Multi-Value Cases: Use comma-separated values: <code>case 1, 2, 3 { }</code></li> <li>No Fall-through: Each case block executes independently (like Go, unlike C)</li> </ol>"},{"location":"general/control_flow/#if-else-statements","title":"If-Else Statements","text":"<p>If-else statements allow you to execute code conditionally.</p>"},{"location":"general/control_flow/#basic-if-else","title":"Basic If-Else","text":"<pre><code>package main\nx := 15\nif x &gt; 10 {\n    fmt.Println(\"Greater than 10\")\n} else {\n    fmt.Println(\"10 or less\")\n}\n</code></pre>"},{"location":"general/control_flow/#else-if-chaining","title":"Else-If Chaining","text":"<pre><code>package main\nscore := 85\nif score &gt;= 90 {\n    fmt.Println(\"Grade: A\")\n} else if score &gt;= 80 {\n    fmt.Println(\"Grade: B\") \n} else if score &gt;= 70 {\n    fmt.Println(\"Grade: C\")\n} else if score &gt;= 60 {\n    fmt.Println(\"Grade: D\")\n} else {\n    fmt.Println(\"Grade: F\")\n}\n</code></pre>"},{"location":"general/control_flow/#switch-statements","title":"Switch Statements","text":"<p>Switch statements provide a way to execute different code blocks based on the value of an expression.</p> <p>Use pattern matching</p> <p>Though <code>switches</code> are present in Harneet, we urge you to use Pattern matching. Pattern matching is a safe way of creating conditional flows when compared to <code>switches</code>. See more here.</p>"},{"location":"general/control_flow/#supported-types-in-switch","title":"Supported Types in Switch","text":"<ul> <li>Integers: <code>case 1, 2, 3 { ... }</code></li> <li>Strings: <code>case \"hello\", \"world\" { ... }</code></li> <li>Mixed types not supported: Each switch statement must use consistent types</li> </ul>"},{"location":"general/control_flow/#integer-switch","title":"Integer Switch","text":"<pre><code>package main\nday := 3\nswitch day {\ncase 1 {\n    fmt.Println(\"Monday\")\n}\ncase 2 {\n    fmt.Println(\"Tuesday\")\n}\ncase 3 {\n    fmt.Println(\"Wednesday\")\n}\ndefault {\n    fmt.Println(\"Other day\")\n}\n}\n</code></pre>"},{"location":"general/control_flow/#string-switch","title":"String Switch","text":"<pre><code>package main\nname := \"Alice\"\nswitch name {\ncase \"Bob\" {\n    fmt.Println(\"Hello Bob!\")\n}\ncase \"Alice\" {\n    fmt.Println(\"Hello Alice!\")\n}\ncase \"Charlie\" {\n    fmt.Println(\"Hello Charlie!\")\n}\ndefault {\n    fmt.Println(\"Hello stranger!\")\n}\n}\n</code></pre>"},{"location":"general/control_flow/#multi-value-cases","title":"Multi-Value Cases","text":"<pre><code>package main\nday := 6\nswitch day {\ncase 1 {\n    fmt.Println(\"Monday\")\n}\ncase 2, 3 {\n    fmt.Println(\"Tuesday or Wednesday\")\n}\ncase 4, 5 {\n    fmt.Println(\"Thursday or Friday\")\n}\ncase 6, 7 {\n    fmt.Println(\"Weekend\")\n}\ndefault {\n    fmt.Println(\"Invalid day\")\n}\n}\n</code></pre>"},{"location":"general/control_flow/#for-loops","title":"For Loops","text":"<p>Harneet uses a single <code>for</code> construct (like Go) that covers multiple patterns:</p> <ul> <li>C-style counted loop: <code>for i := 0; i &lt; 10; i++ { ... }</code></li> <li>Condition-only loop (while-style): <code>for condition { ... }</code></li> <li>For-in loops for iterables: Modern iteration with Python-like syntax</li> <li>Range loops: <code>for i in range(10) { ... }</code></li> <li>Array iteration: <code>for item in array { ... }</code> or <code>for i, item in array { ... }</code></li> <li>Map iteration: <code>for key in map { ... }</code> or <code>for key, value in map { ... }</code></li> <li>Enumeration: <code>for pair in enumerate(array) { ... }</code></li> </ul> <p>There is no separate <code>while</code> keyword.</p>"},{"location":"general/control_flow/#c-style-for-loop","title":"C-style For Loop","text":"<pre><code>package main\nfor i := 0; i &lt; 10; i = i + 1 {\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"general/control_flow/#condition-only-for-loop-while-style","title":"Condition-only For Loop (while-style)","text":"<p>Use a <code>for</code> with only a condition to loop while it remains true.</p> <pre><code>// Loop while the condition holds\npackage main\ni := 0\nfor i &lt; 3 {\n    fmt.Println(\"i:\", i)\n    i = i + 1\n}\n\n// Example: drain a queue\nimport collections\nq := collections.new_queue()\nq.enqueue(\"a\")\nq.enqueue(\"b\")\n\nfor !q.is_empty() {\n    fmt.Println(\"dequeued:\", q.dequeue())\n}\n</code></pre>"},{"location":"general/control_flow/#for-in-loops","title":"For-in Loops","text":"<p>Harneet provides comprehensive for-in loop functionality for iterating over various data structures with Python-like syntax and Go-like performance.</p>"},{"location":"general/control_flow/#range-loops","title":"Range Loops","text":"<p>Use <code>range(n)</code> to iterate over a sequence of numbers from 0 to n-1:</p> <pre><code>// Basic range loop\npackage main\nfor i in range(5) {\n    fmt.Printf(\"Number: %d\\n\", i)  // Prints 0, 1, 2, 3, 4\n}\n\n// Range with different variable name\nfor count in range(3) {\n    fmt.Printf(\"Count: %d\\n\", count)\n}\n</code></pre>"},{"location":"general/control_flow/#array-iteration","title":"Array Iteration","text":"<p>Iterate over array elements with single or multiple variables:</p> <pre><code>package main\nvar fruits = [\"apple\", \"banana\", \"cherry\"]\n\n// Single variable - iterate over elements\nfor fruit in fruits {\n    fmt.Printf(\"Fruit: %s\\n\", fruit)\n}\n\n// Multiple variables - get index and element\nfor index, fruit in fruits {\n    fmt.Printf(\"[%d] %s\\n\", index, fruit)\n}\n</code></pre>"},{"location":"general/control_flow/#map-iteration","title":"Map Iteration","text":"<p>Iterate over map keys or key-value pairs:</p> <pre><code>package main\nvar scores = {\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92}\n\n// Single variable - iterate over keys only\nfor name in scores {\n    fmt.Printf(\"Name: %s\\n\", name)\n}\n\n// Multiple variables - iterate over key-value pairs\nfor name, score in scores {\n    fmt.Printf(\"%s scored %d\\n\", name, score)\n}\n</code></pre>"},{"location":"general/control_flow/#enumeration-with-enumerate","title":"Enumeration with enumerate()","text":"<p>Use the <code>enumerate()</code> builtin function to get index-value pairs:</p> <pre><code>package main\nvar colors = [\"red\", \"green\", \"blue\"]\n\n// Using enumerate() function\nfor pair in enumerate(colors) {\n    var index = pair[0]\n    var color = pair[1]\n    fmt.Printf(\"[%d] %s\\n\", index, color)\n}\n\n// Direct enumeration syntax (equivalent to above)\nfor index, color in colors {\n    fmt.Printf(\"[%d] %s\\n\", index, color)\n}\n</code></pre>"},{"location":"general/control_flow/#nested-loops-and-complex-data","title":"Nested Loops and Complex Data","text":"<p>For-in loops work with nested data structures:</p> <pre><code>// Nested arrays\npackage main\nvar matrix = [[1, 2], [3, 4], [5, 6]]\nfor row in matrix {\n    fmt.Printf(\"Row: \")\n    for cell in row {\n        fmt.Printf(\"%d \", cell)\n    }\n    fmt.Println()\n}\n\n// Array of maps\nvar users = [\n    {\"name\": \"Alice\", \"age\": 30},\n    {\"name\": \"Bob\", \"age\": 25}\n]\n\nfor user in users {\n    fmt.Printf(\"User: %s (age %s)\\n\", user[\"name\"], user[\"age\"])\n}\n</code></pre>"},{"location":"general/control_flow/#break-and-continue","title":"Break and Continue","text":"<p>Break and continue statements work in all for-in loop types:</p> <pre><code>// Break example\npackage main\nfor i in range(10) {\n    if i == 5 {\n        fmt.Printf(\"Breaking at %d\\n\", i)\n        break\n    }\n    fmt.Printf(\"i = %d\\n\", i)\n}\n\n// Continue example  \nfor i in range(8) {\n    if i % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    fmt.Printf(\"Odd number: %d\\n\", i)\n}\n</code></pre>"},{"location":"general/control_flow/#supported-iteration-patterns","title":"Supported Iteration Patterns","text":"Pattern Syntax Variables Bound Use Case Range <code>for i in range(n)</code> <code>i</code>: integer Counting loops Array Simple <code>for item in array</code> <code>item</code>: array element Processing items Array Indexed <code>for i, item in array</code> <code>i</code>: index, <code>item</code>: element Need both index and value Map Keys <code>for key in map</code> <code>key</code>: map key Processing keys only Map Pairs <code>for k, v in map</code> <code>k</code>: key, <code>v</code>: value Processing key-value pairs Enumerate <code>for pair in enumerate(array)</code> <code>pair</code>: [index, value] Manual index extraction"},{"location":"general/data_types/","title":"Data Types","text":"<p>Harneet supports a variety of built-in data types to represent different kinds of values.</p>"},{"location":"general/data_types/#integers","title":"Integers","text":"<p>Integers are whole numbers, positive or negative. Harneet provides various integer types to accommodate different ranges and memory requirements.</p> <ul> <li>Literals: <code>42</code>, <code>-17</code>, <code>0x1A</code> (hexadecimal), <code>0b1010</code> (binary)</li> <li>Types: <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> (signed integers)</li> <li>Unsigned Types: <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code> (unsigned integers)</li> <li>Automatic Type Inference: Harneet can automatically infer the most appropriate integer type based on the value.</li> <li>Explicit Declarations: You can explicitly declare the integer type.</li> </ul>"},{"location":"general/data_types/#floating-point-numbers","title":"Floating-point Numbers","text":"<p>Floating-point numbers represent real numbers with decimal points.</p> <ul> <li>Literals: <code>3.14</code>, <code>-2.71</code>, <code>1.23e-4</code> (scientific notation)</li> <li>Types: <code>float32</code>, <code>float64</code> (IEEE-754 compliant)</li> <li>Precision: Harneet ensures precision preservation in all floating-point operations.</li> </ul>"},{"location":"general/data_types/#strings","title":"Strings","text":"<p>Strings are sequences of characters. Harneet has robust support for Unicode.</p> <ul> <li>Literals: <code>\"Hello World\"</code>, <code>\"Unicode: \u4f60\u597d\u4e16\u754c \ud83c\udf0d\"</code>, <code>\"Multi\\nLine\"</code></li> <li>Encoding: UTF-8 native support for full Unicode handling.</li> <li>Escape Sequences: <code>\\n</code> (newline), <code>\\t</code> (tab), <code>\\\"</code> (double quote), <code>\\\\</code> (backslash)</li> <li>Concatenation: Use the <code>+</code> operator to join strings.</li> </ul>"},{"location":"general/data_types/#booleans","title":"Booleans","text":"<p>Booleans represent truth values, either <code>true</code> or <code>false</code>.</p> <ul> <li>Literals: <code>true</code>, <code>false</code></li> <li>Logical Operations: <code>and</code>, <code>or</code>, <code>not</code> (Python-style with short-circuit evaluation)</li> <li>No Implicit Conversion: Booleans are not implicitly converted from other types.</li> </ul>"},{"location":"general/data_types/#arrays","title":"Arrays","text":"<p>Arrays are ordered, mutable collections of elements.</p> <ul> <li>Literals: <code>[1, 2, 3]</code>, <code>[\"a\", \"b\", \"c\"]</code>, <code>[[1, 2], [3, 4]]</code></li> <li>Dynamic Resizing: Arrays can grow or shrink dynamically.</li> <li>Mixed Type Support: Arrays can contain elements of different data types.</li> <li>Nested Arrays: Arrays can be nested to arbitrary depths.</li> <li>Indexing: Zero-based indexing with bounds checking.</li> <li>Module: For comprehensive array operations, refer to the <code>arrays</code> module in the Standard Library.</li> </ul>"},{"location":"general/data_types/#none","title":"None","text":"<p><code>None</code> is a special value that represents the absence of a value, similar to <code>nil</code> in Go or <code>None</code> in Python.</p> <ul> <li>Usage: Used extensively in error handling to indicate no error.</li> <li>Explicit Checking: Requires explicit checking (e.g., <code>if err != None</code>).</li> </ul>"},{"location":"general/import_system/","title":"Import System","text":"<p>Harneet provides a comprehensive import system that supports both standard library modules and local Harneet packages, with Go-like syntax and modern features including relative imports and module-qualified types.</p>"},{"location":"general/import_system/#standard-library-imports","title":"Standard Library Imports","text":""},{"location":"general/import_system/#basic-import-syntax","title":"Basic Import Syntax","text":"<pre><code>import fmt\nimport strings\nimport json\n</code></pre>"},{"location":"general/import_system/#comma-separated-imports","title":"Comma-Separated Imports","text":"<pre><code>import fmt, strings, json\nimport math, datetime, os\n</code></pre>"},{"location":"general/import_system/#import-aliases","title":"Import Aliases","text":"<pre><code>import fmt as f\nimport strings as str\nimport \"../mylib\" as mylib\n</code></pre>"},{"location":"general/import_system/#local-package-imports","title":"Local Package Imports","text":""},{"location":"general/import_system/#relative-imports","title":"Relative Imports","text":"<p>Harneet supports relative imports using <code>../</code> and <code>./</code> syntax, similar to modern module systems:</p> <pre><code>// Import from parent directory\nimport \"../mylib\" as mylib\n\n// Import from current directory\nimport \"./utils\" as utils\n\n// Import from subdirectory\nimport \"./helpers/validation\" as validate\n</code></pre>"},{"location":"general/import_system/#package-structure","title":"Package Structure","text":"<p>Local packages must follow Go-like conventions:</p> <pre><code>project/\n\u251c\u2500\u2500 main.ha              # package main\n\u251c\u2500\u2500 mylib/\n\u2502   \u2514\u2500\u2500 lib.ha          # package mylib\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 helpers.ha      # package utils\n</code></pre>"},{"location":"general/import_system/#package-declaration","title":"Package Declaration","text":"<p>Each Harneet file must start with a package declaration:</p> <pre><code>// mylib/lib.ha\npackage mylib\n\n// Exported struct type (starts with uppercase)\ntype User struct {\n    name string\n    age int\n}\n\n// Exported variable\nvar DefaultAge int = 21\n\n// Exported function\nfunction MakeDefaultUser(name string) User {\n    return User{name: name, age: DefaultAge}\n}\n</code></pre>"},{"location":"general/import_system/#module-qualified-types","title":"Module-Qualified Types","text":""},{"location":"general/import_system/#type-annotations","title":"Type Annotations","text":"<p>Use imported types in variable declarations, function parameters, and return types:</p> <pre><code>package main\nimport \"../mylib\" as mylib\n\nfunction main() {\n    // Module-qualified type in variable annotation\n    var user mylib.User = mylib.MakeDefaultUser(\"Alice\")\n\n    // Module-qualified type in function parameter\n    function processUser(u mylib.User) {\n        fmt.Printf(\"Processing user: %s\\n\", u.name)\n    }\n\n    processUser(user)\n}\n</code></pre>"},{"location":"general/import_system/#struct-literals","title":"Struct Literals","text":"<p>Create instances using module-qualified struct literals:</p> <pre><code>// Direct struct literal with module qualification\nvar user mylib.User = mylib.User{name: \"Bob\", age: 33}\n\n// Struct literal in typed array\nvar users = mylib.User[2]{\n    mylib.User{name: \"Carol\", age: 25},\n    mylib.User{name: \"Dave\", age: 30},\n}\n</code></pre>"},{"location":"general/import_system/#typed-arrays","title":"Typed Arrays","text":"<p>Use module-qualified types in typed array declarations:</p> <pre><code>// Typed array with module-qualified element type\nvar userArray = mylib.User[3]{\n    mylib.User{name: \"Alice\", age: 25},\n    mylib.User{name: \"Bob\", age: 30},\n    mylib.User{name: \"Charlie\", age: 35},\n}\n\n// Access array length\nvar count = len(userArray)  // Returns: 3\n</code></pre>"},{"location":"general/import_system/#export-rules","title":"Export Rules","text":"<p>Harneet follows Go-like export rules:</p>"},{"location":"general/import_system/#exported-names","title":"Exported Names","text":"<ul> <li>Uppercase first letter: Exported (public)</li> <li>Lowercase first letter: Unexported (private)</li> </ul> <pre><code>package mylib\n\n// Exported (public) - can be imported\ntype User struct { ... }        // \u2705 Exported\nvar DefaultAge int = 21         // \u2705 Exported  \nfunction MakeUser() User { ... } // \u2705 Exported\n\n// Unexported (private) - cannot be imported\ntype userInternal struct { ... }     // \u274c Private\nvar internalConfig string = \"...\"    // \u274c Private\nfunction validateUser() bool { ... } // \u274c Private\n</code></pre>"},{"location":"general/import_system/#struct-fields","title":"Struct Fields","text":"<pre><code>type User struct {\n    Name string    // \u2705 Exported field\n    Age int        // \u2705 Exported field\n    id string      // \u274c Private field\n}\n</code></pre>"},{"location":"general/import_system/#multi-file-main-packages","title":"Multi-File Main Packages","text":""},{"location":"general/import_system/#directory-execution","title":"Directory Execution","text":"<p>Execute all <code>.ha</code> files in a directory as a single <code>package main</code>:</p> <pre><code># Execute all .ha files in the app directory\nharneet ./examples/packages/app\n</code></pre>"},{"location":"general/import_system/#file-structure","title":"File Structure","text":"<pre><code>app/\n\u251c\u2500\u2500 main.ha      # package main\n\u251c\u2500\u2500 helpers.ha   # package main  \n\u2514\u2500\u2500 config.ha    # package main\n</code></pre> <p>All files are combined into a single program execution context.</p>"},{"location":"general/import_system/#complete-example","title":"Complete Example","text":""},{"location":"general/import_system/#project-structure","title":"Project Structure","text":"<pre><code>examples/packages/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 main.ha\n\u2514\u2500\u2500 mylib/\n    \u2514\u2500\u2500 lib.ha\n</code></pre>"},{"location":"general/import_system/#library-package-myliblibha","title":"Library Package (<code>mylib/lib.ha</code>)","text":"<pre><code>package mylib\n\n// Exported struct type\ntype User struct {\n    name string\n    age int\n}\n\n// Exported variables\nvar DefaultAge int = 21\nvar Version string = \"v1.0.0\"\n\n// Exported constructor function\nfunction MakeDefaultUser(name string) User {\n    return User{name: name, age: DefaultAge}\n}\n\n// Exported utility function\nfunction Greet(name string) string {\n    return \"Hello \" + name\n}\n</code></pre>"},{"location":"general/import_system/#main-application-appmainha","title":"Main Application (<code>app/main.ha</code>)","text":"<pre><code>package main\n\nimport fmt\nimport \"../mylib\" as mylib\n\nfunction main() {\n    fmt.Println(\"Testing module-qualified types and relative imports\")\n\n    // Use module-qualified type in variable annotation\n    var u mylib.User = mylib.MakeDefaultUser(\"Alice\")\n    fmt.Println(\"DefaultAge:\")\n    fmt.Println(mylib.DefaultAge)\n    fmt.Println(\"Version:\")\n    fmt.Println(mylib.Version)\n\n    // Struct literal with module-qualified type\n    var v mylib.User = mylib.User{name: \"Bob\", age: 33}\n\n    // Typed array literal with module-qualified struct element type\n    var arr = mylib.User[2]{\n        mylib.User{name: \"Carol\", age: 10},\n        mylib.User{name: \"Dave\", age: 20},\n    }\n\n    // Call exported function\n    var message = mylib.Greet(\"Gagan\")\n    fmt.Println(message)\n\n    fmt.Println(\"User u:\")\n    fmt.Println(u)\n    fmt.Println(\"User v:\")\n    fmt.Println(v)\n    fmt.Println(\"arr length:\")\n    fmt.Println(len(arr))\n}\n\nmain()\n</code></pre>"},{"location":"general/import_system/#execution","title":"Execution","text":"<pre><code>$ harneet examples/packages/app\nTesting module-qualified types and relative imports\nDefaultAge:\n21\nVersion:\nv1.0.0\nHello Gagan\nUser u:\nUser{age: 21, name: Alice}\nUser v:\nUser{name: Bob, age: 33}\narr length:\n2\n</code></pre>"},{"location":"general/import_system/#import-resolution","title":"Import Resolution","text":""},{"location":"general/import_system/#standard-library","title":"Standard Library","text":"<ul> <li>Resolved from built-in stdlib modules</li> <li>Examples: <code>fmt</code>, <code>strings</code>, <code>json</code>, <code>math</code>, <code>os</code></li> </ul>"},{"location":"general/import_system/#relative-imports_1","title":"Relative Imports","text":"<ul> <li><code>../package</code> - Import from parent directory</li> <li><code>./package</code> - Import from current directory  </li> <li><code>./sub/package</code> - Import from subdirectory</li> </ul>"},{"location":"general/import_system/#package-discovery","title":"Package Discovery","text":"<ol> <li>Look for directory with matching name</li> <li>Find <code>.ha</code> files with matching package declaration</li> <li>Load and evaluate package in isolated environment</li> <li>Make exported symbols available to importing module</li> </ol>"},{"location":"general/import_system/#type-compatibility","title":"Type Compatibility","text":""},{"location":"general/import_system/#struct-type-matching","title":"Struct Type Matching","text":"<p>Module-qualified types are compatible with their base types:</p> <pre><code>// These are compatible:\nvar expected mylib.User = ...\nvar actual User = ...  // Base type from same module\n\n// Type checker allows assignment between:\n// - mylib.User \u2194 User (when from same module)\n// - mylib.User \u2194 STRUCT (runtime struct objects)\n</code></pre>"},{"location":"general/import_system/#error-handling","title":"Error Handling","text":"<p>Clear error messages for import and type issues:</p> <pre><code>Error: Cannot execute non-main package 'mylib'. Only 'package main' is executable.\nError: Missing package declaration. The first non-comment line must be 'package &lt;name&gt;'.\nError: variable 'u' type mismatch: cannot assign STRUCT to mylib.User\n</code></pre>"},{"location":"general/import_system/#best-practices","title":"Best Practices","text":""},{"location":"general/import_system/#1-package-organization","title":"1. Package Organization","text":"<pre><code>// Good: Clear package structure\nproject/\n\u251c\u2500\u2500 main.ha           # Main application\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 user.ha      # User-related types\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 api.ha       # API services\n\u2514\u2500\u2500 utils/\n    \u2514\u2500\u2500 helpers.ha   # Utility functions\n</code></pre>"},{"location":"general/import_system/#2-export-conventions","title":"2. Export Conventions","text":"<pre><code>// Good: Clear export intentions\ntype User struct { ... }        // Exported type\nvar DefaultConfig = { ... }     // Exported variable\nfunction NewUser() User { ... } // Exported constructor\n\ntype userImpl struct { ... }    // Private implementation\nvar cache = { ... }             // Private cache\nfunction validate() bool { ... } // Private helper\n</code></pre>"},{"location":"general/import_system/#3-import-aliases","title":"3. Import Aliases","text":"<pre><code>// Good: Clear, meaningful aliases\nimport \"../models/user\" as userModel\nimport \"../services/api\" as apiService\nimport \"../utils/validation\" as validate\n\n// Avoid: Unclear or conflicting aliases\nimport \"../models/user\" as u  // Too short\nimport \"../services/api\" as user  // Confusing\n</code></pre>"},{"location":"general/import_system/#4-type-usage","title":"4. Type Usage","text":"<pre><code>// Good: Explicit type annotations for clarity\nvar user userModel.User = userModel.NewUser(\"Alice\")\nvar users []userModel.User = userModel.LoadUsers()\n\n// Good: Module-qualified constructors\nvar config apiService.Config = apiService.DefaultConfig()\n</code></pre>"},{"location":"general/import_system/#integration-with-standard-library","title":"Integration with Standard Library","text":"<p>The import system works seamlessly with all standard library modules:</p> <pre><code>import fmt, json, cast\nimport \"../models\" as models\n\nfunction processData(jsonStr string) models.User {\n    var data, err = json.Unmarshal(jsonStr)\n    if err != None {\n        fmt.Printf(\"JSON error: %s\\n\", err)\n        return models.User{}\n    }\n\n    var name, _ = cast.ToString(data[\"name\"])\n    var age, _ = cast.ToInt(data[\"age\"])\n\n    return models.User{name: name, age: age}\n}\n</code></pre> <p>This import system provides the flexibility of modern module systems while maintaining the simplicity and type safety that makes Harneet productive for both small scripts and larger applications.</p>"},{"location":"general/keywords_identifiers/","title":"Keywords and Identifiers","text":""},{"location":"general/keywords_identifiers/#keywords","title":"Keywords","text":"<p>Keywords are reserved words in Harneet that have special meaning and cannot be used as identifiers (e.g., variable names, function names).</p>"},{"location":"general/keywords_identifiers/#reserved-keywords","title":"Reserved Keywords","text":"<ul> <li><code>var</code>: Used for variable declaration.</li> <li><code>function</code>: Used for function declaration.</li> <li><code>if</code>, <code>else</code>: Used for conditional statements.</li> <li><code>for</code>: Used for loops.</li> <li><code>switch</code>, <code>case</code>, <code>default</code>: Used for switch statements.</li> <li><code>import</code>: Used to import modules.</li> <li><code>return</code>: Used to return values from functions.</li> <li><code>and</code>, <code>or</code>, <code>not</code>: Logical operators.</li> <li><code>true</code>, <code>false</code>: Boolean literals.</li> <li><code>None</code>: Represents the absence of a value.</li> </ul>"},{"location":"general/keywords_identifiers/#type-keywords","title":"Type Keywords","text":"<p>These keywords are used to specify data types.</p> <ul> <li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>: Signed integer types.</li> <li><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code>: Unsigned integer types.</li> <li><code>float32</code>, <code>float64</code>: Floating-point types.</li> <li><code>string</code>: String type.</li> <li><code>bool</code>: Boolean type.</li> </ul>"},{"location":"general/keywords_identifiers/#identifiers","title":"Identifiers","text":"<p>Identifiers are names given to variables, functions, modules, and other program entities.</p> <ul> <li>Rules:<ul> <li>Must start with a letter (a-z, A-Z) or an underscore (<code>_</code>).</li> <li>Can contain letters, numbers (0-9), and underscores.</li> <li>Case-sensitive (e.g., <code>myVar</code> and <code>myvar</code> are different).</li> </ul> </li> <li>Conventions: Follow consistent naming conventions for readability.</li> </ul>"},{"location":"general/maps/","title":"Maps","text":"<p>Maps are key-value data structures that provide efficient lookups and storage. Harneet's maps follow Go-like syntax and behavior with strong type safety, reference semantics, and modern conveniences like dot-access and built-in methods.</p>"},{"location":"general/maps/#overview","title":"Overview","text":"<p>Maps in Harneet are: - Reference types - passed by reference, not by value - Type-safe - support both typed and untyped maps - Flexible keys - support strings, numbers, booleans, floats, arrays, and structs as keys - Zero value - <code>None</code> (must be initialized before use) - Nested - support unlimited nesting depth - Method-rich - built-in <code>.keys()</code>, <code>.values()</code>, <code>.has()</code>, <code>.delete()</code> methods - Dot-accessible - convenient <code>obj.key</code> syntax alongside <code>obj[\"key\"]</code></p>"},{"location":"general/maps/#quick-start","title":"Quick Start","text":"<pre><code>package main\nimport fmt\n\nfunction main() {\n    // Create and access maps\n    var user = {\"name\": \"Alice\", \"age\": 30}\n    fmt.Println(user.name)  // Dot-access: \"Alice\"\n    fmt.Println(user[\"age\"]) // Bracket access: 30\n\n    // Map methods\n    var keys = user.keys()      // [\"name\", \"age\"]\n    var hasEmail = user.has(\"email\")  // false\n\n    // Add and delete\n    user[\"email\"] = \"alice@example.com\"\n    user.delete(\"age\")\n\n    // Advanced: struct keys\n    type Point struct { x int; y int }\n    var locations = {\n        Point{x: 0, y: 0}: \"origin\",\n        Point{x: 10, y: 20}: \"home\"\n    }\n}\n</code></pre>"},{"location":"general/maps/#map-literals","title":"Map Literals","text":"<p>Create maps using map literal syntax with curly braces:</p> <pre><code>// Basic map literal\npackage main\nvar user = {\"name\": \"Alice\", \"age\": 25, \"active\": true}\n\n// Empty map\nvar empty = {}\n\n// Mixed key types\nvar mixed = {1: \"one\", \"two\": 2, true: \"boolean\"}\n</code></pre>"},{"location":"general/maps/#map-type-declarations","title":"Map Type Declarations","text":"<p>Declare typed maps with specific key and value types:</p> <pre><code>// String keys, integer values\npackage main\nvar scores map[string]int\n\n// Integer keys, string values  \nvar grades map[int]string\n\n// String keys, boolean values\nvar features map[string]bool\n\n// Boolean keys, string values\nvar status map[bool]string\n</code></pre>"},{"location":"general/maps/#map-assignment","title":"Map Assignment","text":"<p>Assign map literals to typed map variables:</p> <pre><code>package main\nvar scores map[string]int\nscores = {\"math\": 95, \"science\": 87, \"english\": 92}\n\nvar features map[string]bool\nfeatures = {\"dark_mode\": true, \"notifications\": false}\n</code></pre>"},{"location":"general/maps/#map-access","title":"Map Access","text":"<p>Access map values using square bracket notation:</p> <pre><code>package main\nvar user = {\"name\": \"Alice\", \"age\": 25}\n\n// Access existing keys\nvar name = user[\"name\"]     // Returns \"Alice\"\nvar age = user[\"age\"]       // Returns 25\n\n// Access non-existent keys\nvar missing = user[\"email\"] // Returns None\n</code></pre>"},{"location":"general/maps/#zero-values","title":"Zero Values","text":"<p>Maps have a zero value of <code>None</code> and must be initialized before use:</p> <pre><code>package main\nvar m map[string]int\nif m == None {\n    fmt.Println(\"Map is None - must initialize\")\n}\n\n// Initialize before use\nm = {\"key\": 42}\n</code></pre>"},{"location":"general/maps/#nested-maps","title":"Nested Maps","text":"<p>Maps support unlimited nesting depth:</p> <pre><code>// Two-level nesting\npackage main\nvar userProfiles map[string]map[string]int\nvar alice = {\"age\": 25, \"score\": 95}\nvar bob = {\"age\": 30, \"score\": 87}\nuserProfiles = {\"alice\": alice, \"bob\": bob}\n\n// Access nested values\nvar aliceAge = userProfiles[\"alice\"][\"age\"]\n\n// Three-level nesting\nvar gameData map[string]map[string]map[string]int\nvar level1 = {\"enemies\": 5, \"coins\": 100}\nvar world1 = {\"level1\": level1}\ngameData = {\"world1\": world1}\n\nvar enemies = gameData[\"world1\"][\"level1\"][\"enemies\"]\n</code></pre>"},{"location":"general/maps/#reference-semantics","title":"Reference Semantics","text":"<p>Maps are reference types - assignment creates new references to the same data:</p> <pre><code>package main\nvar original = {\"count\": 1, \"value\": 42}\nvar reference = original\n\n// Both variables point to the same map\nfmt.Printf(\"Original: %s\\n\", original)   // {count: 1, value: 42}\nfmt.Printf(\"Reference: %s\\n\", reference) // {count: 1, value: 42}\n</code></pre>"},{"location":"general/maps/#type-safety","title":"Type Safety","text":"<p>Harneet provides compile-time type checking for maps:</p> <pre><code>// Type-safe assignments\npackage main\nvar scores map[string]int\nscores = {\"math\": 95, \"science\": 87}  // \u2705 Valid\n\n// Type compatibility\nvar untyped = {\"key\": \"value\"}\nvar typed map[string]string = untyped  // \u2705 Valid\n</code></pre>"},{"location":"general/maps/#key-types","title":"Key Types","text":"<p>Maps support various hashable key types:</p>"},{"location":"general/maps/#string-keys","title":"String Keys","text":"<pre><code>package main\nvar stringMap = {\"name\": \"Alice\", \"city\": \"NYC\"}\nvar typed map[string]string = stringMap\n</code></pre>"},{"location":"general/maps/#integer-keys","title":"Integer Keys","text":"<pre><code>package main\nvar intMap = {1: \"one\", 2: \"two\", 3: \"three\"}\nvar typed map[int]string = intMap\n</code></pre>"},{"location":"general/maps/#boolean-keys","title":"Boolean Keys","text":"<pre><code>package main\nvar boolMap = {true: \"enabled\", false: \"disabled\"}\nvar typed map[bool]string = boolMap\n</code></pre>"},{"location":"general/maps/#mixed-keys-untyped-maps","title":"Mixed Keys (Untyped Maps)","text":"<pre><code>package main\nvar mixed = {\n    1: \"integer key\",\n    \"text\": \"string key\", \n    true: \"boolean key\"\n}\n</code></pre>"},{"location":"general/maps/#complex-examples","title":"Complex Examples","text":""},{"location":"general/maps/#configuration-management","title":"Configuration Management","text":"<pre><code>package main\nvar config map[string]map[string]string\nvar database = {\"host\": \"localhost\", \"port\": \"5432\", \"name\": \"mydb\"}\nvar server = {\"host\": \"0.0.0.0\", \"port\": \"8080\", \"env\": \"dev\"}\nconfig = {\"database\": database, \"server\": server}\n\nvar dbHost = config[\"database\"][\"host\"]\nvar serverPort = config[\"server\"][\"port\"]\n</code></pre>"},{"location":"general/maps/#game-data-structure","title":"Game Data Structure","text":"<pre><code>package main\nvar gameData map[string]map[string]map[string]int\nvar level1 = {\"enemies\": 5, \"coins\": 100, \"powerups\": 3}\nvar level2 = {\"enemies\": 8, \"coins\": 150, \"powerups\": 2}\nvar world1 = {\"level1\": level1, \"level2\": level2}\ngameData = {\"world1\": world1}\n\nvar coins = gameData[\"world1\"][\"level1\"][\"coins\"]\n</code></pre>"},{"location":"general/maps/#user-management-system","title":"User Management System","text":"<pre><code>package main\nvar users map[string]map[string]int\nvar alice = {\"age\": 25, \"score\": 95, \"level\": 3}\nvar bob = {\"age\": 30, \"score\": 87, \"level\": 2}\nvar charlie = {\"age\": 28, \"score\": 92, \"level\": 4}\nusers = {\"alice\": alice, \"bob\": bob, \"charlie\": charlie}\n\n// Access user data\nvar aliceScore = users[\"alice\"][\"score\"]\nvar bobLevel = users[\"bob\"][\"level\"]\n</code></pre>"},{"location":"general/maps/#best-practices","title":"Best Practices","text":""},{"location":"general/maps/#1-use-typed-maps-for-better-safety","title":"1. Use Typed Maps for Better Safety","text":"<pre><code>// Preferred: Explicit types\npackage main\nvar scores map[string]int = {\"math\": 95, \"science\": 87}\n\n// Acceptable: Type inference\nvar scores = {\"math\": 95, \"science\": 87}\n</code></pre>"},{"location":"general/maps/#2-check-for-none-before-use","title":"2. Check for None Before Use","text":"<pre><code>package main\nvar m map[string]int\nif m == None {\n    m = {\"default\": 0}\n}\n</code></pre>"},{"location":"general/maps/#3-handle-missing-keys","title":"3. Handle Missing Keys","text":"<pre><code>package main\nvar user = {\"name\": \"Alice\"}\nvar email = user[\"email\"]\nif email == None {\n    fmt.Println(\"Email not provided\")\n}\n</code></pre>"},{"location":"general/maps/#4-use-descriptive-key-names","title":"4. Use Descriptive Key Names","text":"<pre><code>// Good: Descriptive keys\npackage main\nvar userProfile = {\"firstName\": \"Alice\", \"lastName\": \"Smith\", \"isActive\": true}\n\n// Avoid: Cryptic keys  \nvar profile = {\"fn\": \"Alice\", \"ln\": \"Smith\", \"act\": true}\n</code></pre>"},{"location":"general/maps/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Access Time: O(1) average case for key lookup</li> <li>Memory: Reference types - efficient memory usage</li> <li>Assignment: O(1) - only copies reference, not data</li> <li>Nesting: No performance penalty for nested access</li> </ul>"},{"location":"general/maps/#comparison-with-other-languages","title":"Comparison with Other Languages","text":"Feature Harneet Go JavaScript Python Syntax <code>{\"key\": value}</code> <code>map[string]int{}</code> <code>{\"key\": value}</code> <code>{\"key\": value}</code> Type Safety \u2705 Compile-time \u2705 Compile-time \u274c Runtime \u274c Runtime Reference Types \u2705 Yes \u2705 Yes \u2705 Yes \u2705 Yes Zero Value <code>None</code> <code>nil</code> <code>undefined</code> <code>None</code> Nested Maps \u2705 Unlimited \u2705 Unlimited \u2705 Unlimited \u2705 Unlimited Dot-Access \u2705 <code>obj.key</code> \u274c No \u2705 <code>obj.key</code> \u274c No Methods \u2705 <code>.keys()</code> <code>.values()</code> <code>.has()</code> <code>.delete()</code> \u274c Use functions \u2705 Built-in \u2705 Built-in Float Keys \u2705 Yes \u274c No \u2705 Yes \u2705 Yes Array Keys \u2705 Yes \u274c No \u274c No \u274c No (tuples only) Struct Keys \u2705 Yes \u2705 Yes \u274c No \u274c No"},{"location":"general/maps/#map-methods","title":"Map Methods","text":"<p>Maps support several built-in methods for common operations:</p>"},{"location":"general/maps/#keys","title":"keys()","text":"<p>Returns an array containing all keys in the map: <pre><code>package main\nvar user = {\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"}\nvar keys = user.keys()  // [\"name\", \"age\", \"city\"]\n</code></pre></p>"},{"location":"general/maps/#values","title":"values()","text":"<p>Returns an array containing all values in the map: <pre><code>package main\nvar scores = {\"math\": 95, \"science\": 87, \"english\": 92}\nvar values = scores.values()  // [95, 87, 92]\n</code></pre></p>"},{"location":"general/maps/#haskey-containskey","title":"has(key) / contains(key)","text":"<p>Checks if a key exists in the map (returns boolean): <pre><code>package main\nvar config = {\"debug\": true, \"port\": 8080}\nvar hasDebug = config.has(\"debug\")      // true\nvar hasHost = config.contains(\"host\")    // false\n</code></pre></p>"},{"location":"general/maps/#deletekey","title":"delete(key)","text":"<p>Removes a key-value pair from the map: <pre><code>package main\nvar data = {\"a\": 1, \"b\": 2, \"c\": 3}\ndata.delete(\"b\")  // Removes key \"b\"\n// data is now {\"a\": 1, \"c\": 3}\n</code></pre></p>"},{"location":"general/maps/#dot-access-syntax","title":"Dot-Access Syntax","text":"<p>Maps support dot-notation as syntactic sugar for bracket access:</p> <pre><code>package main\nvar user = {\"name\": \"Alice\", \"age\": 30}\n\n// Dot-access (sugar for bracket notation)\nvar name = user.name     // Same as user[\"name\"]\nvar age = user.age       // Same as user[\"age\"]\n\n// Works with nested maps\nvar config = {\"server\": {\"host\": \"localhost\", \"port\": 8080}}\nvar host = config.server.host    // \"localhost\"\nvar port = config.server.port    // 8080\n\n// Missing keys return None\nvar missing = user.email  // None\n</code></pre> <p>Note: Dot-access is only syntactic sugar. Use bracket notation when: - Key names contain special characters or spaces - Key names are computed dynamically - Key names conflict with method names</p>"},{"location":"general/maps/#advanced-key-types","title":"Advanced Key Types","text":"<p>Harneet maps support any comparable (hashable) type as keys:</p>"},{"location":"general/maps/#float-keys","title":"Float Keys","text":"<pre><code>package main\nvar constants = {3.14: \"pi\", 2.71: \"e\", 1.41: \"sqrt(2)\"}\nvar pi = constants[3.14]  // \"pi\"\n</code></pre>"},{"location":"general/maps/#array-keys","title":"Array Keys","text":"<p>Arrays can be used as keys if all elements are hashable: <pre><code>package main\nvar coordinates = {\n    [0, 0]: \"origin\",\n    [1, 2]: \"point A\",\n    [3, 4]: \"point B\"\n}\nvar origin = coordinates[[0, 0]]  // \"origin\"\n\n// Nested arrays work too\nvar nested = {\n    [[1, 2], [3, 4]]: \"matrix A\",\n    [[5, 6], [7, 8]]: \"matrix B\"\n}\n</code></pre></p>"},{"location":"general/maps/#struct-keys","title":"Struct Keys","text":"<p>Structs can be used as keys if all fields are comparable: <pre><code>package main\ntype Point struct {\n    x int\n    y int\n}\n\nvar locations = {\n    Point{x: 0, y: 0}: \"origin\",\n    Point{x: 10, y: 20}: \"home\",\n    Point{x: -5, y: 15}: \"work\"\n}\n\nvar home = locations[Point{x: 10, y: 20}]  // \"home\"\n\n// Complex structs with nested hashable fields\ntype Address struct {\n    city string\n    zip int\n}\n\ntype Person struct {\n    name string\n    age int\n    address Address\n}\n\nvar people = {\n    Person{name: \"Alice\", age: 30, address: Address{city: \"NYC\", zip: 10001}}: \"employee_001\"\n}\n</code></pre></p>"},{"location":"general/maps/#mixed-key-types","title":"Mixed Key Types","text":"<p>Untyped maps can have mixed key types: <pre><code>package main\nvar mixed = {\n    \"string\": 1,\n    42: 2,\n    true: 3,\n    3.14: 4,\n    [1, 2]: 5\n}\n</code></pre></p>"},{"location":"general/maps/#map-initialization","title":"Map Initialization","text":"<p>Multiple ways to initialize maps:</p>"},{"location":"general/maps/#empty-map-literal","title":"Empty Map Literal","text":"<pre><code>package main\nvar m = {}\nm[\"key\"] = \"value\"\n</code></pre>"},{"location":"general/maps/#map-literal-with-values","title":"Map Literal with Values","text":"<pre><code>package main\nvar scores = {\"math\": 95, \"science\": 87}\n</code></pre>"},{"location":"general/maps/#typed-map-declaration","title":"Typed Map Declaration","text":"<pre><code>package main\nvar m map[string]int\nm = {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"general/maps/#iteration","title":"Iteration","text":"<p>Maps can be iterated using for-in loops:</p>"},{"location":"general/maps/#iterate-over-keys","title":"Iterate Over Keys","text":"<pre><code>package main\nvar scores = {\"Alice\": 95, \"Bob\": 87, \"Carol\": 92}\nfor name in scores {\n    fmt.Printf(\"Student: %s\\n\", name)\n}\n</code></pre>"},{"location":"general/maps/#iterate-over-key-value-pairs","title":"Iterate Over Key-Value Pairs","text":"<pre><code>package main\nvar scores = {\"Alice\": 95, \"Bob\": 87, \"Carol\": 92}\nfor name, score in scores {\n    fmt.Printf(\"%s: %d\\n\", name, score)\n}\n</code></pre>"},{"location":"general/maps/#complete-example","title":"Complete Example","text":"<p>Comprehensive example using all map features:</p> <pre><code>package main\nimport fmt\n\ntype Point struct {\n    x int\n    y int\n}\n\nfunction main() {\n    // Create map with various key types\n    var data = {\n        \"name\": \"Alice\",\n        \"age\": 30,\n        \"active\": true\n    }\n\n    // Dot-access\n    fmt.Printf(\"Name: %s\\n\", data.name)\n\n    // Add new key\n    data[\"email\"] = \"alice@example.com\"\n\n    // Check existence\n    if data.has(\"email\") {\n        fmt.Println(\"Email exists\")\n    }\n\n    // Get all keys and values\n    var keys = data.keys()\n    var values = data.values()\n    fmt.Println(\"Keys:\", keys)\n    fmt.Println(\"Values:\", values)\n\n    // Iterate over map\n    for key, value in data {\n        fmt.Printf(\"%s: %v\\n\", key, value)\n    }\n\n    // Delete key\n    data.delete(\"age\")\n\n    // Struct keys\n    var locations = {\n        Point{x: 0, y: 0}: \"origin\",\n        Point{x: 10, y: 20}: \"destination\"\n    }\n\n    var dest = locations[Point{x: 10, y: 20}]\n    fmt.Println(\"Destination:\", dest)\n\n    // Array keys\n    var grid = {\n        [0, 0]: \"top-left\",\n        [0, 1]: \"top-right\",\n        [1, 0]: \"bottom-left\",\n        [1, 1]: \"bottom-right\"\n    }\n\n    var topLeft = grid[[0, 0]]\n    fmt.Println(\"Top-left:\", topLeft)\n}\n</code></pre>"},{"location":"general/maps/#see-also","title":"See Also","text":"<ul> <li>Data Types - Overview of all data types</li> <li>Arrays - Array data structures</li> <li>Variable Declaration - Variable declaration syntax</li> <li>Type System &amp; Safety - Type system overview</li> </ul>"},{"location":"general/operators_and_expressions/","title":"Operators and Expressions","text":"<p>Harneet supports a variety of operators for performing arithmetic, comparison, and logical operations.</p>"},{"location":"general/operators_and_expressions/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code>: Addition</li> <li><code>-</code>: Subtraction</li> <li><code>*</code>: Multiplication</li> <li><code>/</code>: Division</li> <li><code>%</code>: Modulo (remainder)</li> </ul>"},{"location":"general/operators_and_expressions/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>==</code>: Equal to</li> <li><code>!=</code>: Not equal to</li> <li><code>&lt;</code>: Less than</li> <li><code>&gt;</code>: Greater than</li> <li><code>&lt;=</code>: Less than or equal to</li> <li><code>&gt;=</code>: Greater than or equal to</li> </ul>"},{"location":"general/operators_and_expressions/#logical-operators","title":"Logical Operators","text":"<ul> <li><code>and</code>: Logical AND (short-circuiting)</li> <li><code>or</code>: Logical OR (short-circuiting)</li> <li><code>not</code>: Logical NOT</li> </ul>"},{"location":"general/operators_and_expressions/#assignment-operators","title":"Assignment Operators","text":"<ul> <li><code>=</code>: Assignment</li> <li><code>:=</code>: Short declaration and assignment</li> </ul>"},{"location":"general/operators_and_expressions/#string-concatenation","title":"String Concatenation","text":"<p>The <code>+</code> operator can be used to concatenate strings.</p> <pre><code>package main\nvar greeting = \"Hello, \" + \"World!\"\n</code></pre>"},{"location":"general/operators_and_expressions/#precedence","title":"Precedence","text":"<p>Harneet follows standard mathematical operator precedence. You can use parentheses <code>()</code> to group expressions and control the order of evaluation.</p>"},{"location":"general/pattern_matching/","title":"Pattern Matching","text":"<p>Pattern matching is a powerful control flow construct in Harneet that allows you to match values against patterns and execute code based on the match. It provides a more expressive and safer alternative to traditional switch statements.</p>"},{"location":"general/pattern_matching/#basic-syntax","title":"Basic Syntax","text":"<p>The basic syntax for pattern matching uses the <code>match</code> keyword:</p> <pre><code>package main\nmatch value {\n    pattern1 =&gt; expression1,\n    pattern2 =&gt; expression2,\n    _ =&gt; default_expression\n}\n</code></pre>"},{"location":"general/pattern_matching/#pattern-types","title":"Pattern Types","text":""},{"location":"general/pattern_matching/#literal-patterns","title":"Literal Patterns","text":"<p>Match against specific literal values:</p> <pre><code>package main\nvar status = match code {\n    200 =&gt; \"OK\",\n    404 =&gt; \"Not Found\", \n    500 =&gt; \"Server Error\",\n    _ =&gt; \"Unknown\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#wildcard-pattern","title":"Wildcard Pattern","text":"<p>The underscore <code>_</code> matches any value and acts as a catch-all:</p> <pre><code>package main\nvar result = match value {\n    1 =&gt; \"one\",\n    2 =&gt; \"two\",\n    _ =&gt; \"other\"  // Matches anything else\n}\n</code></pre>"},{"location":"general/pattern_matching/#variable-binding","title":"Variable Binding","text":"<p>Bind the matched value to a variable:</p> <pre><code>package main\nvar message = match number {\n    0 =&gt; \"zero\",\n    1 =&gt; \"one\",\n    n =&gt; \"some number\"  // 'n' contains the matched value\n}\n</code></pre>"},{"location":"general/pattern_matching/#array-destructuring","title":"Array Destructuring","text":"<p>Match and destructure arrays:</p> <pre><code>package main\nvar description = match coordinates {\n    [] =&gt; \"empty\",\n    [x] =&gt; \"single point\",\n    [x, y] =&gt; \"2D point\", \n    [x, y, z] =&gt; \"3D point\",\n    _ =&gt; \"higher dimension\"\n}\n</code></pre> <p>You can also use specific values in array patterns:</p> <pre><code>package main\nvar result = match point {\n    [0, 0] =&gt; \"origin\",\n    [x, 0] =&gt; \"on x-axis\",\n    [0, y] =&gt; \"on y-axis\", \n    [x, y] =&gt; \"general point\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#blank-identifiers-in-patterns","title":"Blank Identifiers in Patterns","text":"<p>Use <code>_</code> to ignore specific values in destructuring:</p> <pre><code>package main\nvar info = match data {\n    [_, _, important] =&gt; \"third element is important\",\n    [first, _] =&gt; \"only care about first element\",\n    _ =&gt; \"other\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#guard-clauses","title":"Guard Clauses","text":"<p>Add conditional logic to patterns using <code>if</code> guards:</p> <pre><code>package main\nvar category = match age {\n    a if a &lt; 13 =&gt; \"child\",\n    a if a &gt;= 13 and a &lt; 20 =&gt; \"teenager\",\n    a if a &gt;= 20 and a &lt; 65 =&gt; \"adult\",\n    a if a &gt;= 65 =&gt; \"senior\",\n    _ =&gt; \"unknown\"\n}\n</code></pre> <p>Guards can use any boolean expression:</p> <pre><code>package main\nvar grade = match score {\n    s if s &gt;= 90 =&gt; \"A\",\n    s if s &gt;= 80 =&gt; \"B\",\n    s if s &gt;= 70 =&gt; \"C\", \n    s if s &gt;= 60 =&gt; \"D\",\n    s =&gt; \"F\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#array-pattern-examples","title":"Array Pattern Examples","text":""},{"location":"general/pattern_matching/#basic-array-matching","title":"Basic Array Matching","text":"<pre><code>package main\nvar arrays = [[], [1], [1, 2], [1, 2, 3]]\n\nfor arr in arrays {\n    var description = match arr {\n        [] =&gt; \"empty array\",\n        [_] =&gt; \"single element\",\n        [_, _] =&gt; \"pair\",\n        [1, 2, 3] =&gt; \"specific triple\",\n        _ =&gt; \"other array\"\n    }\n    fmt.Printf(\"Array %s =&gt; %s\\n\", arr, description)\n}\n</code></pre>"},{"location":"general/pattern_matching/#array-destructuring-with-guards","title":"Array Destructuring with Guards","text":"<pre><code>package main\nvar points = [[0, 0], [5, 0], [0, 3], [4, 3]]\n\nfor point in points {\n    var quadrant = match point {\n        [0, 0] =&gt; \"origin\",\n        [x, 0] if x &gt; 0 =&gt; \"positive x-axis\",\n        [x, 0] if x &lt; 0 =&gt; \"negative x-axis\",\n        [0, y] if y &gt; 0 =&gt; \"positive y-axis\", \n        [0, y] if y &lt; 0 =&gt; \"negative y-axis\",\n        [x, y] if x &gt; 0 and y &gt; 0 =&gt; \"first quadrant\",\n        [x, y] if x &lt; 0 and y &gt; 0 =&gt; \"second quadrant\",\n        [x, y] if x &lt; 0 and y &lt; 0 =&gt; \"third quadrant\",\n        [x, y] if x &gt; 0 and y &lt; 0 =&gt; \"fourth quadrant\",\n        [x, y] =&gt; \"some point\"\n    }\n    fmt.Printf(\"Point %s =&gt; %s\\n\", point, quadrant)\n}\n</code></pre>"},{"location":"general/pattern_matching/#real-world-examples","title":"Real-World Examples","text":""},{"location":"general/pattern_matching/#http-status-code-processing","title":"HTTP Status Code Processing","text":"<pre><code>package main\nvar statusCodes = [200, 404, 500, 301, 401]\n\nfor code in statusCodes {\n    var status = match code {\n        200 =&gt; \"OK\",\n        201 =&gt; \"Created\",\n        301 =&gt; \"Moved Permanently\", \n        400 =&gt; \"Bad Request\",\n        401 =&gt; \"Unauthorized\",\n        404 =&gt; \"Not Found\",\n        500 =&gt; \"Internal Server Error\",\n        c if c &gt;= 200 and c &lt; 300 =&gt; \"Success\",\n        c if c &gt;= 300 and c &lt; 400 =&gt; \"Redirection\",\n        c if c &gt;= 400 and c &lt; 500 =&gt; \"Client Error\", \n        c if c &gt;= 500 =&gt; \"Server Error\",\n        _ =&gt; \"Unknown Status\"\n    }\n    fmt.Printf(\"HTTP %d =&gt; %s\\n\", code, status)\n}\n</code></pre>"},{"location":"general/pattern_matching/#role-based-access-control","title":"Role-Based Access Control","text":"<pre><code>package main\nvar roles = [\"admin\", \"user\", \"guest\", \"moderator\"]\n\nfor role in roles {\n    var access = match role {\n        \"admin\" =&gt; \"full access\",\n        \"moderator\" =&gt; \"limited admin access\",\n        \"user\" =&gt; \"standard access\",\n        \"guest\" =&gt; \"read-only access\",\n        _ =&gt; \"no access\"\n    }\n    fmt.Printf(\"Role '%s' =&gt; %s\\n\", role, access)\n}\n</code></pre>"},{"location":"general/pattern_matching/#type-safety-and-exhaustiveness","title":"Type Safety and Exhaustiveness","text":"<p>Pattern matching in Harneet includes compile-time type checking:</p> <ul> <li>Pattern Compatibility: Patterns must be compatible with the matched value type</li> <li>Variable Binding Types: Variables bound in patterns get proper types</li> <li>Guard Validation: Guard clauses must be boolean expressions</li> <li>Return Type Consistency: All match arms must return compatible types</li> <li>Exhaustiveness Warnings: The compiler warns about potentially non-exhaustive matches</li> </ul>"},{"location":"general/pattern_matching/#best-practices","title":"Best Practices","text":""},{"location":"general/pattern_matching/#1-always-include-a-wildcard","title":"1. Always Include a Wildcard","text":"<pre><code>// Good - handles all cases\npackage main\nvar result = match value {\n    \"expected\" =&gt; \"handled\",\n    _ =&gt; \"fallback\"\n}\n\n// Risky - may not handle all cases\nvar result = match value {\n    \"expected\" =&gt; \"handled\"\n    // Missing wildcard\n}\n</code></pre>"},{"location":"general/pattern_matching/#2-use-guards-for-complex-conditions","title":"2. Use Guards for Complex Conditions","text":"<pre><code>// Good - clear and expressive\npackage main\nvar category = match age {\n    a if a &lt; 18 =&gt; \"minor\",\n    a if a &gt;= 65 =&gt; \"senior\", \n    a =&gt; \"adult\"\n}\n\n// Less clear with nested conditions\nif age &lt; 18 {\n    category = \"minor\"\n} else if age &gt;= 65 {\n    category = \"senior\"\n} else {\n    category = \"adult\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#3-use-destructuring-for-data-extraction","title":"3. Use Destructuring for Data Extraction","text":"<pre><code>// Good - extract values directly\npackage main\nvar info = match coordinates {\n    [x, y] =&gt; fmt.Sprintf(\"Point at (%d, %d)\", x, y),\n    _ =&gt; \"Invalid coordinates\"\n}\n\n// More verbose alternative\nif len(coordinates) == 2 {\n    var x = coordinates[0]\n    var y = coordinates[1]\n    info = fmt.Sprintf(\"Point at (%d, %d)\", x, y)\n} else {\n    info = \"Invalid coordinates\"\n}\n</code></pre>"},{"location":"general/pattern_matching/#4-leverage-type-safety","title":"4. Leverage Type Safety","text":"<p>Pattern matching provides compile-time guarantees about type safety and helps catch errors early in development.</p>"},{"location":"general/pattern_matching/#comparison-with-switch-statements","title":"Comparison with Switch Statements","text":"<p>Pattern matching is more powerful than traditional switch statements:</p> Feature Switch Pattern Matching Value matching \u2705 \u2705 Variable binding \u274c \u2705 Destructuring \u274c \u2705 Guard clauses \u274c \u2705 Type safety Limited \u2705 Exhaustiveness checking \u274c \u2705 <p>Pattern matching provides a more expressive, safer, and more powerful way to handle conditional logic in Harneet programs.</p>"},{"location":"general/scoping_variable_management/","title":"Scoping and Variable Management","text":"<p>Scoping rules determine where variables are accessible in your program. Harneet uses lexical scoping, meaning the scope of a variable is determined by its position in the source code.</p>"},{"location":"general/scoping_variable_management/#global-scope","title":"Global Scope","text":"<p>Variables declared outside of any function or block have global scope and are accessible from anywhere in the program.</p> <pre><code>package main\nvar global = \"accessible everywhere\"\n\nfunction printGlobal() {\n    fmt.Println(global)\n}\n\nprintGlobal() // Output: accessible everywhere\n</code></pre>"},{"location":"general/scoping_variable_management/#local-scope-function-scope","title":"Local Scope (Function Scope)","text":"<p>Variables declared inside a function have local scope and are only accessible within that function.</p> <pre><code>package main\nfunction example() {\n    var local = \"only in function\"\n    fmt.Println(local)\n}\n\nexample() // Output: only in function\n// fmt.Println(local) // Error: local is not defined\n</code></pre>"},{"location":"general/scoping_variable_management/#block-scope","title":"Block Scope","text":"<p>Variables declared inside a block (e.g., <code>if</code> statements, <code>for</code> loops) have block scope and are only accessible within that block.</p> <pre><code>package main\nif true {\n    var blockScope = \"only in this block\"\n    fmt.Println(blockScope) // Output: only in this block\n}\n// fmt.Println(blockScope) // Error: blockScope is not defined\n</code></pre>"},{"location":"general/scoping_variable_management/#accessing-outer-scope-variables","title":"Accessing Outer Scope Variables","text":"<p>Inner scopes can access variables from their outer (enclosing) scopes.</p> <pre><code>package main\nvar outerVar = \"I am from outer scope\"\n\nfunction outer() {\n    var innerVar = \"I am from inner scope\"\n    function nested() {\n        fmt.Println(outerVar) // Access outerVar from outer scope\n        fmt.Println(innerVar) // Access innerVar from inner scope\n    }\n    nested()\n}\n\nouter()\n</code></pre>"},{"location":"general/scoping_variable_management/#variable-shadowing","title":"Variable Shadowing","text":"<p>If a variable in an inner scope has the same name as a variable in an outer scope, the inner variable \"shadows\" the outer one within its scope.</p> <pre><code>package main\nvar x = 10\n\nfunction shadowExample() {\n    var x = 20 // This 'x' shadows the global 'x'\n    fmt.Println(x) // Output: 20\n}\n\nshadowExample()\nfmt.Println(x) // Output: 10 (global 'x' is unchanged)\n</code></pre>"},{"location":"general/struct_field_assignment/","title":"Struct Field Assignment","text":"<p>Harneet supports Go-like direct struct field assignment, allowing you to access and modify struct fields using dot notation.</p>"},{"location":"general/struct_field_assignment/#basic-syntax","title":"Basic Syntax","text":""},{"location":"general/struct_field_assignment/#field-access","title":"Field Access","text":"<pre><code>var person = Person{Name: \"Alice\", Age: 30}\nvar name = person.Name    // Access field value\nvar age = person.Age      // Access field value\n</code></pre>"},{"location":"general/struct_field_assignment/#field-assignment","title":"Field Assignment","text":"<pre><code>person.Name = \"Bob\"       // Assign new value to field\nperson.Age = 25           // Assign new value to field\n</code></pre>"},{"location":"general/struct_field_assignment/#zero-value-initialization","title":"Zero Value Initialization","text":"<p>Structs can be declared without initialization, and all fields will be set to their zero values:</p> <pre><code>type Person struct {\n    Name string\n    Age int\n    Active bool\n}\n\nfunction main() {\n    var p Person              // Zero value initialization\n    // p.Name = \"\"            (empty string)\n    // p.Age = 0              (zero integer)\n    // p.Active = false       (false boolean)\n\n    // Assign fields directly\n    p.Name = \"Alice\"\n    p.Age = 30\n    p.Active = true\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#nested-field-assignment","title":"Nested Field Assignment","text":"<p>Harneet supports nested field assignment on chained dotted receivers.</p> <pre><code>type Address struct { city string; zip int }\ntype Person struct { name string; addr Address }\n\nfunction main() {\n    var p = Person{name: \"Alice\", addr: Address{city: \"SF\", zip: 94105}}\n    p.addr.city = \"LA\"\n    p.addr.zip = 90001\n    fmt.Println(p) // Person{name: Alice, addr: Address{zip: 90001, city: LA}}\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#method-calls-on-fields","title":"Method Calls on Fields","text":"<p>You can call methods directly on field values without introducing intermediates.</p> <pre><code>type Address struct { city string }\nfunc (a Address) toString() string { return a.city }\n\ntype Person struct { name string; addr Address }\n\nfunction main() {\n    var p = Person{name: \"Alice\", addr: Address{city: \"Paris\"}}\n    fmt.Println(p.addr.toString()) // Paris\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#compile-time-validation-of-dotted-chains","title":"Compile-time Validation of Dotted Chains","text":"<p>The type checker validates receivers for dotted access at compile-time:</p> <ul> <li>Struct receiver required: Each <code>.</code> step must have a struct-like receiver (<code>struct</code> or user-defined struct type). </li> <li>Invalid receiver error: Accessing a field or calling a method on a non-struct produces a type error.</li> </ul> <p>Examples:</p> <pre><code>type Person struct { name string }\n\nvar p = Person{name: \"A\"}\nvar n = 42\n\n// \u274c Error: cannot access field name on type int\nn.name = \"x\"\n\n// \u274c Error: cannot call method toString on type int\nn.toString()\n\n// \u2705 OK: structs and nested fields are validated step-by-step\np.name = \"Bob\"\n</code></pre>"},{"location":"general/struct_field_assignment/#zero-values-by-type","title":"Zero Values by Type","text":"Type Zero Value <code>string</code> <code>\"\"</code> (empty string) <code>int</code> <code>0</code> <code>float64</code> <code>0.0</code> <code>bool</code> <code>false</code> <code>map[K]V</code> <code>None</code> (must be initialized) Custom structs All fields set to their zero values"},{"location":"general/struct_field_assignment/#complete-examples","title":"Complete Examples","text":""},{"location":"general/struct_field_assignment/#basic-field-operations","title":"Basic Field Operations","text":"<pre><code>type Person struct {\n    Name string\n    Age int\n    Active bool\n}\n\nfunction main() {\n    // Method 1: Zero value initialization + field assignment\n    var p1 Person\n    p1.Name = \"Alice\"\n    p1.Age = 30\n    p1.Active = true\n\n    // Method 2: Struct literal initialization\n    var p2 = Person{Name: \"Bob\", Age: 25, Active: false}\n\n    // Field access\n    fmt.Printf(\"p1.Name: %s\\n\", p1.Name)\n    fmt.Printf(\"p2.Age: %d\\n\", p2.Age)\n\n    // Field modification\n    p2.Age = p2.Age + 1\n    p2.Active = !p2.Active\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#multiple-struct-instances","title":"Multiple Struct Instances","text":"<pre><code>type Point struct {\n    X int\n    Y int\n}\n\nfunction main() {\n    var p1 Point\n    var p2 Point\n\n    // Each instance is independent\n    p1.X = 10\n    p1.Y = 20\n\n    p2.X = 30\n    p2.Y = 40\n\n    fmt.Printf(\"p1: (%d, %d)\\n\", p1.X, p1.Y)  // (10, 20)\n    fmt.Printf(\"p2: (%d, %d)\\n\", p2.X, p2.Y)  // (30, 40)\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#field-assignment-in-functions","title":"Field Assignment in Functions","text":"<pre><code>type Rectangle struct {\n    Width int\n    Height int\n}\n\nfunction setDimensions(rect Rectangle, w int, h int) {\n    rect.Width = w\n    rect.Height = h\n}\n\nfunction main() {\n    var r Rectangle\n    setDimensions(r, 100, 50)\n\n    fmt.Printf(\"Rectangle: %dx%d\\n\", r.Width, r.Height)\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#export-rules-go-like-convention","title":"Export Rules (Go-like Convention)","text":"<p>Field visibility follows Go-like export conventions:</p> <pre><code>type User struct {\n    Name string    // Exported (accessible from other packages)\n    age int        // Unexported (package-private)\n    Email string   // Exported\n    password string // Unexported\n}\n</code></pre> <ul> <li>Exported fields: Start with uppercase letter, accessible from other packages</li> <li>Unexported fields: Start with lowercase letter, only accessible within the same package</li> </ul>"},{"location":"general/struct_field_assignment/#comparison-with-other-languages","title":"Comparison with Other Languages","text":""},{"location":"general/struct_field_assignment/#go-similarity","title":"Go Similarity","text":"<pre><code>// Go\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    var p Person\n    p.Name = \"Alice\"\n    p.Age = 30\n}\n</code></pre> <pre><code>// Harneet (nearly identical)\ntype Person struct {\n    Name string\n    Age int\n}\n\nfunction main() {\n    var p Person\n    p.Name = \"Alice\"\n    p.Age = 30\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#differences-from-javascript","title":"Differences from JavaScript","text":"<pre><code>// JavaScript - dynamic typing\nlet person = {};\nperson.name = \"Alice\";    // Can add fields dynamically\nperson.age = 30;\n</code></pre> <pre><code>// Harneet - static typing\ntype Person struct {\n    Name string\n    Age int\n}\nvar person Person         // Must declare struct type first\nperson.Name = \"Alice\"     // Only predefined fields allowed\nperson.Age = 30\n</code></pre>"},{"location":"general/struct_field_assignment/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive field names: <code>UserName</code> instead of <code>Name</code> when context matters</li> <li>Follow export conventions: Uppercase for public fields, lowercase for private</li> <li>Initialize before use: Always ensure structs are properly initialized</li> <li>Zero value awareness: Understand what zero values mean for your use case</li> <li>Prefer struct literals: Use <code>Person{Name: \"Alice\", Age: 30}</code> when you have all values</li> </ol>"},{"location":"general/struct_field_assignment/#error-cases","title":"Error Cases","text":"<pre><code>type Person struct {\n    Name string\n    Age int\n}\n\nfunction main() {\n    var p Person\n\n    // \u2705 Valid operations\n    p.Name = \"Alice\"\n    var name = p.Name\n\n    // \u274c Invalid operations\n    // p.InvalidField = \"value\"  // Error: field doesn't exist\n    // var x = p.Name.InvalidMethod()  // Error: strings don't have methods\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#integration-with-other-features","title":"Integration with Other Features","text":""},{"location":"general/struct_field_assignment/#with-maps","title":"With Maps","text":"<pre><code>type Config struct {\n    Settings map[string]string\n}\n\nfunction main() {\n    var cfg Config\n    cfg.Settings = {\"theme\": \"dark\", \"lang\": \"en\"}\n\n    var theme = cfg.Settings[\"theme\"]\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#with-arrays","title":"With Arrays","text":"<pre><code>type Team struct {\n    Members []string\n}\n\nfunction main() {\n    var team Team\n    team.Members = [\"Alice\", \"Bob\", \"Charlie\"]\n\n    var firstMember = team.Members[0]\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#with-functions","title":"With Functions","text":"<pre><code>type Calculator struct {\n    Result float64\n}\n\nfunction (c Calculator) add(x float64) {\n    c.Result = c.Result + x\n}\n\nfunction main() {\n    var calc Calculator\n    calc.add(10.5)\n    fmt.Printf(\"Result: %f\\n\", calc.Result)\n}\n</code></pre>"},{"location":"general/struct_field_assignment/#current-limitations","title":"Current Limitations","text":"<ol> <li>Field address taking: Cannot take addresses of fields (no pointers yet)</li> </ol>"},{"location":"general/struct_field_assignment/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Struct embedding and inheritance</li> <li>Field tags and metadata</li> <li>Pointer semantics for reference types</li> </ul>"},{"location":"general/unicode_support/","title":"Unicode Support","text":"<p>Harneet has first-class support for Unicode, allowing you to work with international characters and emojis seamlessly.</p>"},{"location":"general/unicode_support/#utf-8-encoding","title":"UTF-8 Encoding","text":"<p>All strings in Harneet are UTF-8 encoded. This means you can use any Unicode character in your strings, comments, and identifiers.</p>"},{"location":"general/unicode_support/#examples","title":"Examples","text":""},{"location":"general/unicode_support/#unicode-in-strings","title":"Unicode in Strings","text":"<pre><code>package main\nimport fmt\n\nvar greeting = \"Hello, \u4e16\u754c \ud83c\udf0d\"\nfmt.Println(greeting)\n</code></pre>"},{"location":"general/unicode_support/#unicode-in-identifiers","title":"Unicode in Identifiers","text":"<pre><code>package main\nvar \u4f60\u597d = \"Hello\"\nfmt.Println(\u4f60\u597d)\n</code></pre>"},{"location":"general/variable_declaration/","title":"Variable Declaration &amp; Assignment","text":"<p>Variables are used to store data in Harneet. Harneet provides flexible ways to declare and assign values to variables.</p>","tags":["variables"]},{"location":"general/variable_declaration/#explicit-type-declaration","title":"Explicit Type Declaration","text":"<p>You can explicitly declare the type of a variable when you declare it.</p> <pre><code>package main\nvar x int = 42\nvar name string = \"Hello\"\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#type-inference","title":"Type Inference","text":"<p>Harneet can infer the type of a variable based on the value assigned to it.</p> <pre><code>package main\nvar x = 42        // x is inferred as int\nvar name = \"Hello\"  // name is inferred as string\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#short-declaration","title":"Short Declaration","text":"<p>The <code>:=</code> operator provides a shorthand for declaring and assigning a value to a variable. The type is automatically inferred.</p> <pre><code>x := 42\nmessage := \"Hi there\"\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#assignment","title":"Assignment","text":"<p>You can assign a new value to an existing variable using the <code>=</code> operator.</p> <pre><code>package main\nvar count = 10\ncount = 20 // Assign a new value\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#zero-value-initialization","title":"Zero Value Initialization","text":"<p>When a variable is declared without an explicit initial value, it is automatically initialized to its \"zero value\".</p> <ul> <li>Integer Types: <code>0</code></li> <li>Float Types: <code>0.0</code></li> <li>String Type: <code>\"\"</code> (empty string)</li> <li>Boolean Type: <code>false</code></li> </ul> <pre><code>package main\nvar intVal int       // intVal is 0\nvar floatVal float64 // floatVal is 0.0\nvar strVal string    // strVal is \"\"\nvar boolVal bool     // boolVal is false\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#multiple-assignment","title":"Multiple Assignment","text":"<p>Harneet supports assigning multiple values to multiple variables in a single statement. This is particularly useful for functions that return multiple values.</p>","tags":["variables"]},{"location":"general/variable_declaration/#function-returns","title":"Function Returns","text":"<pre><code>package main\nimport math\n\nfunction getAbs(num int) (int, string) {\n    if num &lt; 0 {\n        return -num, \"\"\n    }\n    return num, \"\"\n}\n\nvar result, err = getAbs(-42)\nif err != \"\" {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Absolute value:\", result) // Output: Absolute value: 42\n}\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#multiple-expressions","title":"Multiple Expressions","text":"<pre><code>package main\nvar name string, age int, score float64 = \"Alice\", 25, 98.5\nvar x, y, z int = 10, 20, 30\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#short-multiple-assignment","title":"Short Multiple Assignment","text":"<pre><code>a, b, c := \"hello\", 123, true\n</code></pre>","tags":["variables"]},{"location":"general/variable_declaration/#blank-identifier","title":"Blank Identifier","text":"<p>The blank identifier <code>_</code> can be used to discard unwanted values in multiple assignment operations.</p> <pre><code>package main\nimport math\n\nvar value, _ = math.Max(10, 5) // Discard the error return value\n</code></pre>","tags":["variables"]},{"location":"stdlib/arrays/","title":"<code>arrays</code> Module","text":"<p>The <code>arrays</code> module provides a comprehensive set of functions for array manipulation.</p>"},{"location":"stdlib/arrays/#functions","title":"Functions","text":""},{"location":"stdlib/arrays/#lengtharray","title":"<code>length(array)</code>","text":"<p>Returns the number of elements in an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(integer, error)</code>: The length of the array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar len, _ = arrays.length(a)\nfmt.Println(len) // Output: 3\n</code></pre></p>"},{"location":"stdlib/arrays/#containsarray-value","title":"<code>contains(array, value)</code>","text":"<p>Checks if a value exists in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value</code>: The value to search for.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the value is found, <code>false</code> otherwise.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar found, _ = arrays.contains(a, 2)\nfmt.Println(found) // Output: true\n</code></pre></p>"},{"location":"stdlib/arrays/#indexarray-value","title":"<code>index(array, value)</code>","text":"<p>Returns the index of the first occurrence of a value in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value</code>: The value to search for.</p> <p>Returns: - <code>(integer, error)</code>: The index of the value, or -1 if not found.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3, 2]\nvar i, _ = arrays.index(a, 2)\nfmt.Println(i) // Output: 1\n</code></pre></p>"},{"location":"stdlib/arrays/#pusharray-value","title":"<code>push(array, value)</code>","text":"<p>Adds one or more elements to the end of an array and returns the new array.</p> <p>Parameters: - <code>array</code>: An array. - <code>value...</code>: The element(s) to add.</p> <p>Returns: - <code>(array, error)</code>: The new array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.push(a, 4, 5)\nfmt.Println(b) // Output: [1, 2, 3, 4, 5]\n</code></pre></p>"},{"location":"stdlib/arrays/#poparray","title":"<code>pop(array)</code>","text":"<p>Removes the last element from an array and returns that element.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(any, error)</code>: The removed element.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar last, _ = arrays.pop(a)\nfmt.Println(last) // Output: 3\nfmt.Println(a) // Output: [1, 2]\n</code></pre></p>"},{"location":"stdlib/arrays/#replacearray-index-value","title":"<code>replace(array, index, value)</code>","text":"<p>Replaces an element at a specific index in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>index</code>: The index of the element to replace. - <code>value</code>: The new value.</p> <p>Returns: - <code>(array, error)</code>: The modified array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.replace(a, 1, 42)\nfmt.Println(b) // Output: [1, 42, 3]\n</code></pre></p>"},{"location":"stdlib/arrays/#deletearray-index","title":"<code>delete(array, index)</code>","text":"<p>Removes an element at a specific index in an array.</p> <p>Parameters: - <code>array</code>: An array. - <code>index</code>: The index of the element to remove.</p> <p>Returns: - <code>(array, error)</code>: The modified array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.delete(a, 1)\nfmt.Println(b) // Output: [1, 3]\n</code></pre></p>"},{"location":"stdlib/arrays/#copyarray","title":"<code>copy(array)</code>","text":"<p>Creates a shallow copy of an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: A new array that is a copy of the original.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.copy(a)\nfmt.Println(b) // Output: [1, 2, 3]\n</code></pre></p>"},{"location":"stdlib/arrays/#cleararray","title":"<code>clear(array)</code>","text":"<p>Removes all elements from an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: The empty array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b, _ = arrays.clear(a)\nfmt.Println(b) // Output: []\n</code></pre></p>"},{"location":"stdlib/arrays/#equalarray1-array2","title":"<code>equal(array1, array2)</code>","text":"<p>Compares two arrays for equality.</p> <p>Parameters: - <code>array1</code>: The first array. - <code>array2</code>: The second array.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the arrays are equal, <code>false</code> otherwise.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar b = [1, 2, 3]\nvar c = [4, 5, 6]\n\nvar eq1, _ = arrays.equal(a, b)\nfmt.Println(eq1) // Output: true\n\nvar eq2, _ = arrays.equal(a, c)\nfmt.Println(eq2) // Output: false\n</code></pre></p>"},{"location":"stdlib/arrays/#sortarray","title":"<code>sort(array)</code>","text":"<p>Sorts the elements of an array in place.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(array, error)</code>: The sorted array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [3, 1, 2]\nvar b, _ = arrays.sort(a)\nfmt.Println(b) // Output: [1, 2, 3]\n</code></pre></p>"},{"location":"stdlib/arrays/#memoryarray","title":"<code>memory(array)</code>","text":"<p>Returns the memory usage of an array.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(integer, error)</code>: The memory usage in bytes.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar mem, _ = arrays.memory(a)\nfmt.Println(mem) \n</code></pre></p>"},{"location":"stdlib/arrays/#tojsonarray","title":"<code>tojson(array)</code>","text":"<p>Converts an array to a JSON string.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(string, error)</code>: The JSON string representation of the array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar json, _ = arrays.tojson(a)\nfmt.Println(json) // Output: [1,2,3]\n</code></pre></p>"},{"location":"stdlib/arrays/#tostringarray","title":"<code>tostring(array)</code>","text":"<p>Converts an array to a string representation.</p> <p>Parameters: - <code>array</code>: An array.</p> <p>Returns: - <code>(string, error)</code>: The string representation of the array.</p> <p>Example: <pre><code>package main\nimport fmt\nimport arrays\n\nvar a = [1, 2, 3]\nvar s, _ = arrays.tostring(a)\nfmt.Println(s) // Output: [1, 2, 3]\n</code></pre></p>"},{"location":"stdlib/arrays/#sorting","title":"Sorting","text":"<p>Harneet supports non-mutating array sorting with natural order and custom comparators. You can access these via the <code>arrays</code> module aliases shown below. These aliases delegate to the global built-ins under the hood.</p>"},{"location":"stdlib/arrays/#arrayssortfnarray","title":"<code>arrays.SortFn(array)</code>","text":"<p>Returns a new array sorted in natural order.</p> <p>Behavior: - Numbers are sorted in ascending order. - Strings are sorted lexicographically. - Errors on mixed element types or unsupported element types. - Non-mutating: the original array is not changed. - Returns a tuple: <code>(array, error)</code>.</p> <p>Example: <pre><code>package main\nimport fmt, arrays\n\n// Sort integers\nvar nums = [5, 2, 9, 1, 5, 6]\nvar sortedNums, err1 = arrays.SortFn(nums)\nif err1 != None {\n    fmt.Println(\"SortFn error:\", err1)\n} else {\n    fmt.Println(\"sorted ints:\", sortedNums) // [1, 2, 5, 5, 6, 9]\n}\n\n// Sort strings\nvar words = [\"pear\", \"apple\", \"banana\"]\nvar sortedWords, err2 = arrays.SortFn(words)\nfmt.Println(sortedWords) // [apple, banana, pear]\n</code></pre></p>"},{"location":"stdlib/arrays/#arrayssortbyarray-less-functiont-t-bool","title":"<code>arrays.SortBy(array, less function(T, T) bool)</code>","text":"<p>Returns a new array sorted using a user-supplied comparator function. The sort is stable.</p> <p>Behavior: - Comparator signature must match the array element type: <code>function(T, T) bool</code>. - Returns a tuple: <code>(array, error)</code>. - Non-mutating: the original array is not changed. - Stable sorting preserves the relative order of equal elements.</p> <p>Examples: <pre><code>package main\nimport fmt, arrays\n\n// Sort integers by absolute value\nvar signed = [-3, 1, -2, 4]\nvar byAbs, err3 = arrays.SortBy(signed, function(a int, b int) bool { \n    return (a &lt; 0 ? -a : a) &lt; (b &lt; 0 ? -b : b) \n})\nfmt.Println(byAbs) // [1, -2, -3, 4]\n\n// Sort strings by length (stable)\nvar fruits = [\"fig\", \"apple\", \"pear\", \"plum\", \"banana\"]\nvar byLen, err4 = arrays.SortBy(fruits, function(a string, b string) bool { \n    return len(a) &lt; len(b) \n})\n</code></pre></p>"},{"location":"stdlib/arrays/#slicing","title":"Slicing","text":"<p>Harneet supports Go-like slicing on arrays, typed arrays, and strings using the <code>s[a:b]</code> syntax. Four forms are available:</p> <ul> <li><code>s[a:b]</code></li> <li><code>s[:b]</code></li> <li><code>s[a:]</code></li> <li><code>s[:]</code></li> </ul>"},{"location":"stdlib/arrays/#rules-and-semantics","title":"Rules and semantics","text":"<ul> <li>Sliceable types: arrays, typed arrays, and strings.</li> <li>Indices: <code>a</code> and <code>b</code> must be integers. The type checker validates this at compile time.</li> <li>Bounds: indices are clamped to the valid range <code>[0, len(s)]</code>.</li> <li>Order: if <code>a &gt; b</code>, the result is an empty slice <code>[]</code>.</li> <li>Half-open: <code>a</code> is inclusive, <code>b</code> is exclusive.</li> <li>Typed arrays: slicing preserves the array's element type (e.g., <code>int[]</code>).</li> <li>Strings: result is a <code>string</code>. Slicing is currently byte-based.</li> </ul>"},{"location":"stdlib/arrays/#examples","title":"Examples","text":"<pre><code>package main\nimport fmt\n\n// Arrays\nvar arr = [10, 20, 30, 40, 50]\nfmt.Println(arr[:])    // [10, 20, 30, 40, 50]\nfmt.Println(arr[:3])   // [10, 20, 30]\nfmt.Println(arr[2:])   // [30, 40, 50]\nfmt.Println(arr[1:4])  // [20, 30, 40]\n\n// Bounds handling\nfmt.Println(arr[-5:2]) // [10, 20]  (clamped)\nfmt.Println(arr[3:99]) // [40, 50]  (clamped)\nfmt.Println(arr[4:2])  // []        (start &gt; end)\n\n// Typed arrays\nvar tarr = int[5]{1, 2, 3, 4, 5}\nvar tmid = tarr[1:4]\nfmt.Println(tmid)      // int[3]{2, 3, 4}\n\n// Strings (byte-based slicing)\nvar s = \"abcdef\"\nfmt.Println(s[0:3])    // \"abc\"\nfmt.Println(s[2:])     // \"cdef\"\nfmt.Println(s[:])      // \"abcdef\"\n</code></pre> <p>Notes on strings:</p> <ul> <li>Current implementation slices by byte index. If your strings contain multi-byte UTF-8 characters, ensure indices align with character boundaries to avoid splitting a character. Rune-aware slicing may be introduced in the future.</li> </ul>"},{"location":"stdlib/assert/","title":"<code>assert</code> Module","text":"<p>The <code>assert</code> module provides fail-fast assertions for tests and runtime contracts. When an assertion fails, Harneet terminates with a runtime error and does not execute subsequent lines.</p>"},{"location":"stdlib/assert/#functions","title":"Functions","text":""},{"location":"stdlib/assert/#assertcondition-message","title":"<code>Assert(condition, message?)</code>","text":"<p>Asserts that a condition is true. If the condition is false, the program will terminate with a runtime error (fail-fast).</p> <p>Parameters: - <code>condition</code>: The condition to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.Assert(1 == 1, \"1 should be equal to 1\")\n// ok\n\nassert.Assert(1 == 2, \"1 should not be equal to 2\")\n// terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#asserteqactual-expected-message","title":"<code>AssertEq(actual, expected, message?)</code>","text":"<p>Asserts that two values are equal. If they are not, the program terminates with  a runtime error.</p> <p>Parameters: - <code>actual</code>: The actual value. - <code>expected</code>: The expected value. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertEq(42, 42, \"42 should be equal to 42\")\n// ok\n\nassert.AssertEq(42, 43, \"42 should not be equal to 43\")\n// terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#assertneactual-expected-message","title":"<code>AssertNe(actual, expected, message?)</code>","text":"<p>Asserts that two values are not equal. If they are, the program terminates with  a runtime error.</p> <p>Parameters: - <code>actual</code>: The actual value. - <code>expected</code>: The expected value. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertNe(42, 43, \"42 should not be equal to 43\")\n// ok\n\nassert.AssertNe(42, 42, \"42 should be equal to 42\")\n// terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#assertisnotnonevalue-message","title":"<code>AssertIsNotNone(value, message?)</code>","text":"<p>Asserts that a value is not <code>None</code>. If it is <code>None</code>, the program terminates with a runtime error.</p> <p>Parameters: - <code>value</code>: The value to check against <code>None</code>. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertIsNotNone(\"hello\")\n// ok\n\n// assert.AssertIsNotNone(None, \"value must not be None\")\n// terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#assertlengthisnotzerovalue-message","title":"<code>AssertLengthIsNotZero(value, message?)</code>","text":"<p>Asserts that the length of a value is not zero. Supported types: <code>string</code>, <code>array</code>. Fails fast on zero length.</p> <p>Parameters: - <code>value</code>: String or array to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertLengthIsNotZero(\"abc\")\nassert.AssertLengthIsNotZero([1, 2])\n</code></pre></p>"},{"location":"stdlib/assert/#assertlengthisgreaterthanvalue-min-message","title":"<code>AssertLengthIsGreaterThan(value, min, message?)</code>","text":"<p>Asserts that <code>length(value) &gt; min</code>. Supported types: <code>string</code>, <code>array</code>. Fails fast if not strictly greater.</p> <p>Parameters: - <code>value</code>: String or array to check. - <code>min</code> (integer): Minimum length threshold (exclusive). - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertLengthIsGreaterThan(\"abcd\", 3)\nassert.AssertLengthIsGreaterThan([1, 2, 3], 2)\n</code></pre></p>"},{"location":"stdlib/assert/#assertlengthislessthanvalue-max-message","title":"<code>AssertLengthIsLessThan(value, max, message?)</code>","text":"<p>Asserts that <code>length(value) &lt; max</code>. Supported types: <code>string</code>, <code>array</code>. Fails fast if not strictly less.</p> <p>Parameters: - <code>value</code>: String or array to check. - <code>max</code> (integer): Maximum length threshold (exclusive). - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertLengthIsLessThan(\"ab\", 3)\nassert.AssertLengthIsLessThan([1], 2)\n</code></pre></p>"},{"location":"stdlib/assert/#assertisanintvalue-message","title":"<code>AssertIsAnInt(value, message?)</code>","text":"<p>Asserts that <code>value</code> is an <code>INTEGER</code>. Fails fast on wrong type.</p> <p>Parameters: - <code>value</code>: Value to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertIsAnInt(42)\n// assert.AssertIsAnInt(\"not-int\")  // terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#assertisastringvalue-message","title":"<code>AssertIsAString(value, message?)</code>","text":"<p>Asserts that <code>value</code> is a <code>STRING</code>. Fails fast on wrong type.</p> <p>Parameters: - <code>value</code>: Value to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertIsAString(\"hello\")\n// assert.AssertIsAString(123)  // terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/assert/#assertisboolvalue-message","title":"<code>AssertIsBool(value, message?)</code>","text":"<p>Asserts that <code>value</code> is a <code>BOOLEAN</code>. Fails fast on wrong type.</p> <p>Parameters: - <code>value</code>: Value to check. - <code>message</code> (optional): A message to display if the assertion fails.</p> <p>Example: <pre><code>package main\nimport assert\n\nassert.AssertIsBool(true)\n// assert.AssertIsBool(\"nope\")  // terminates with a runtime error\n</code></pre></p>"},{"location":"stdlib/box/","title":"box module","text":"<p>A box is a tiny mutable cell that holds a single value. It provides reference-like semantics without language-level pointers. Use it when you want to share and mutate a value across functions, or avoid copying large values.</p> <ul> <li>Import: <code>import box</code></li> <li>Backing: A box is implemented as a one-element array internally.</li> <li>Pattern: Get/transform/Set via explicit functions.</li> </ul>"},{"location":"stdlib/box/#api","title":"API","text":"<ul> <li><code>box.New(value any) (box, error)</code></li> <li>Create a new box containing <code>value</code>.</li> <li><code>box.Get(b box) (value, error)</code></li> <li>Read the value stored in the box.</li> <li><code>box.Set(b box, value any) (None, error)</code></li> <li>Replace the value in the box with <code>value</code>.</li> </ul> <p>All functions return <code>(result, error)</code> tuples consistent with Harneet stdlib conventions.</p>"},{"location":"stdlib/box/#why-use-a-box","title":"Why use a box?","text":"<ul> <li>Pass-by-reference semantics without references:</li> <li>Let a callee update a caller\u2019s value.</li> <li>Shared mutable state:</li> <li>Multiple functions can observe and update a single, shared slot.</li> <li>Large values:</li> <li>Pass a small handle (the box) rather than copying/rebinding large data repeatedly.</li> </ul>"},{"location":"stdlib/box/#when-to-use-in-the-real-world","title":"When to use in the real world","text":"<ul> <li>Counters, accumulators, and state shared across helpers.</li> <li>Swapping values across two locations.</li> <li>Coordinating state across callbacks or closures.</li> <li>Managing large data held in memory (e.g., a full file\u2019s contents) when a single shared value needs mutation.</li> <li>Note: For very large data processing, prefer streaming or chunked processing via the <code>file</code> module if you don\u2019t need the entire data in memory.</li> </ul>"},{"location":"stdlib/box/#examples","title":"Examples","text":""},{"location":"stdlib/box/#basic-usage","title":"Basic usage","text":"<pre><code>package main\nimport fmt\nimport box\n\n// Create a box holding an integer\nvar counterBox, err = box.New(0)\nif err != None {\n    fmt.Println(\"box.New error:\", err)\n}\n\n// Read\nvar value, err1 = box.Get(counterBox)\nif err1 == None {\n    fmt.Println(\"initial value:\", value)\n}\n\n// Write\nvar _, err2 = box.Set(counterBox, 42)\nif err2 == None {\n    var newValue, _ = box.Get(counterBox)\n    fmt.Println(\"updated value:\", newValue)  // 42\n}\n</code></pre>"},{"location":"stdlib/box/#pass-by-reference-style-mutation","title":"Pass-by-reference style mutation","text":"<pre><code>package main\nimport fmt\nimport box\n\nfunction Increment(b) {\n    var v, err = box.Get(b)\n    if err != None {\n        fmt.Println(\"box.Get error:\", err)\n        return\n    }\n    var _, setErr = box.Set(b, v + 1)\n    if setErr != None {\n        fmt.Println(\"box.Set error:\", setErr)\n        return\n    }\n}\n\nvar counter, e = box.New(10)\nif e == None {\n    Increment(counter)\n    var v, _ = box.Get(counter)\n    fmt.Println(\"after increment:\", v)  // 11\n}\n</code></pre>"},{"location":"stdlib/box/#swap-using-boxes-shared-mutable-state","title":"Swap using boxes (shared mutable state)","text":"<pre><code>package main\nimport fmt\nimport box\n\nfunction Swap(a, b) {\n    var av, errA = box.Get(a)\n    if errA != None { return }\n\n    var bv, errB = box.Get(b)\n    if errB != None { return }\n\n    var _, errSetA = box.Set(a, bv)\n    if errSetA != None { return }\n\n    var _, errSetB = box.Set(b, av)\n    if errSetB != None { return }\n}\n\nvar x, _ = box.New(1)\nvar y, _ = box.New(2)\nSwap(x, y)\nvar xv, _ = box.Get(x)\nvar yv, _ = box.Get(y)\nfmt.Println(\"x:\", xv, \"y:\", yv)  // x: 2 y: 1\n</code></pre>"},{"location":"stdlib/box/#large-data-in-a-box","title":"Large data in a box","text":"<pre><code>package main\nimport fmt\nimport box\nimport file\nimport strings\n\n// Read a full file (for demo). For very large files, consider streaming.\nvar content, readErr = file.Read(\"README.md\")\nif readErr == None {\n    var contentBox, err = box.New(content)\n    if err == None {\n        var current, _ = box.Get(contentBox)\n        var updated = current + \"\\n---\\nprocessed by box example\\n\"\n        var _, setErr = box.Set(contentBox, updated)\n        if setErr == None {\n            var final, _ = box.Get(contentBox)\n            var length, lenErr = strings.Len(final)\n            if lenErr == None {\n                fmt.Println(\"content length:\", length)\n            }\n        }\n    }\n}\n</code></pre> <p>Remember this \u2192</p> <ul> <li>Treat a box like a tiny heap-allocated cell holding one value.</li> <li>Don\u2019t overuse boxes; prefer pure functions and returning updated values when mutation isn\u2019t needed.</li> <li>Boxes are excellent when you need a shared, mutable slot or pass-by-reference semantics.</li> </ul>"},{"location":"stdlib/break_continue/","title":"break and continue","text":"<p>This document describes the semantics of <code>break</code> and <code>continue</code> in the Harneet language and provides examples.</p>"},{"location":"stdlib/break_continue/#overview","title":"Overview","text":"<ul> <li><code>break</code> exits the nearest enclosing loop or switch.</li> <li><code>continue</code> skips to the next iteration of the nearest enclosing loop.</li> <li>Using <code>continue</code> while not inside a loop is a runtime error.</li> <li>If a <code>break</code>/<code>continue</code> occurs inside a <code>switch</code> within a loop:</li> <li><code>break</code> exits the switch only (the loop continues).</li> <li><code>continue</code> propagates to the loop and proceeds to the next iteration.</li> </ul> <p>These semantics are enforced by the evaluator. Internally, a loop depth is tracked to validate <code>continue</code> usage, and break/continue signals are propagated through statement blocks correctly.</p>"},{"location":"stdlib/break_continue/#examples","title":"Examples","text":""},{"location":"stdlib/break_continue/#basic-break","title":"Basic break","text":"<pre><code>package main\nimport fmt\n\nfmt.Println(\"=== basic_break ===\")\n\nfmt.Println(\"Break out of a simple for loop at i == 3\")\nfor i := 1; i &lt;= 5; i = i + 1 {\n    if i == 3 {\n        fmt.Println(\"hit 3 -&gt; break\")\n        break\n    }\n    fmt.Println(i)\n}\n\nfmt.Println(\"Done: basic_break\")\n</code></pre>"},{"location":"stdlib/break_continue/#basic-continue","title":"Basic continue","text":"<pre><code>package main\nimport fmt\n\nfmt.Println(\"=== basic_continue ===\")\n\nfmt.Println(\"Continue skips printing even numbers (prints only odds)\")\nfor i := 1; i &lt;= 10; i = i + 1 {\n    if i % 2 == 0 {\n        continue\n    }\n    fmt.Println(i)\n}\n\nfmt.Println(\"Done: basic_continue\")\n</code></pre>"},{"location":"stdlib/break_continue/#nested-loops-with-break-and-continue","title":"Nested loops with break and continue","text":"<pre><code>package main\nimport fmt\n\nfmt.Println(\"=== nested_loops_break_continue ===\")\n\nfmt.Println(\"Outer 1..3, inner 1..3 with continue and break\")\nfor i := 1; i &lt;= 3; i = i + 1 {\n    for j := 1; j &lt;= 3; j = j + 1 {\n        if j == 2 {\n            fmt.Println(\"i=\", i, \", j=\", j, \" -&gt; continue inner\")\n            continue\n        }\n        if i == 3 &amp;&amp; j == 3 {\n            fmt.Println(\"i=\", i, \", j=\", j, \" -&gt; break inner\")\n            break\n        }\n        fmt.Println(\"i=\", i, \", j=\", j)\n    }\n}\n\nfmt.Println(\"Done: nested_loops_break_continue\")\n</code></pre>"},{"location":"stdlib/break_continue/#forin-with-break-and-continue","title":"for..in with break and continue","text":"<pre><code>package main\nimport fmt\n\nfmt.Println(\"=== for_in_break_continue ===\")\n\nvar nums = [1, 2, 3, 4, 5]\n\nfmt.Println(\"Use continue to skip number 3 and break at 4\")\nfor n in nums {\n    if n == 3 {\n        fmt.Println(\"skip 3 with continue\")\n        continue\n    }\n    if n == 4 {\n        fmt.Println(\"hit 4 -&gt; break\")\n        break\n    }\n    fmt.Println(n)\n}\n\nfmt.Println(\"Done: for_in_break_continue\")\n</code></pre>"},{"location":"stdlib/break_continue/#switch-inside-loop-while-like-pattern-in-switch-body","title":"switch inside loop; while-like pattern in switch body","text":"<pre><code>package main\nimport fmt\n\nfmt.Println(\"=== while_in_switch_and_switch_in_loop ===\")\n\nfmt.Println(\"Switch inside a for loop: use continue and break from inside switch\")\nfor i := 1; i &lt;= 5; i = i + 1 {\n    switch i {\n    case 2, 4 {\n        fmt.Println(\"i=\", i, \" -&gt; continue from switch\")\n        continue\n    }\n    case 5 {\n        fmt.Println(\"i=\", i, \" -&gt; break from switch (exits switch; outer loop continues)\")\n        break\n    }\n    default {\n        fmt.Println(\"i=\", i, \" default case\")\n    }\n    // Should reach here for i=1,3\n}\n\nfmt.Println(\"Done: while_in_switch_and_switch_in_loop\")\n</code></pre>"},{"location":"stdlib/break_continue/#notes","title":"Notes","text":"<ul> <li><code>break</code> inside <code>switch</code> does not exit the loop; it exits only the switch. The loop continues.</li> <li><code>continue</code> always refers to the nearest enclosing loop. If no loop is active, a runtime error is raised.</li> <li>Within the evaluator, <code>break</code>/<code>continue</code> are modelled as control-flow signal objects that bubble up through blocks until they are handled by loops, and <code>continue</code> is validated using tracked loop depth.</li> </ul>"},{"location":"stdlib/cast/","title":"<code>cast</code> Module","text":"<p>The <code>cast</code> module provides comprehensive type conversion functions with robust error handling, making it easy to convert between different data types safely and predictably.</p>"},{"location":"stdlib/cast/#functions","title":"Functions","text":""},{"location":"stdlib/cast/#tostringvalue","title":"<code>ToString(value)</code>","text":"<p>Converts any value to its string representation.</p> <p>Parameters: - <code>value</code>: The value to convert to string (any type)</p> <p>Returns: - <code>(string, error)</code>: String representation of the value</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar str1, err1 = cast.ToString(42)        // \"42\"\nvar str2, err2 = cast.ToString(3.14)      // \"3.14\"\nvar str3, err3 = cast.ToString(true)      // \"true\"\nvar str4, err4 = cast.ToString(None)      // \"None\"\nvar str5, err5 = cast.ToString({\"a\": 1})  // \"{a: 1}\"\n\nfmt.Printf(\"Number: %s\\n\", str1)\nfmt.Printf(\"Float: %s\\n\", str2)\nfmt.Printf(\"Boolean: %s\\n\", str3)\n</code></pre></p>"},{"location":"stdlib/cast/#tointvalue","title":"<code>ToInt(value)</code>","text":"<p>Converts a value to an integer with validation.</p> <p>Parameters: - <code>value</code>: The value to convert (string, float, boolean, or integer)</p> <p>Returns: - <code>(int, error)</code>: Integer representation of the value</p> <p>Conversion Rules: - String: Must be a valid integer format - Float: Truncates decimal part - Boolean: <code>true</code> \u2192 1, <code>false</code> \u2192 0 - Integer: Returns as-is - None: Returns error</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar int1, err1 = cast.ToInt(\"123\")     // 123\nvar int2, err2 = cast.ToInt(3.14)      // 3\nvar int3, err3 = cast.ToInt(true)      // 1\nvar int4, err4 = cast.ToInt(false)     // 0\n\n// Error handling\nvar invalid, err5 = cast.ToInt(\"hello\")\nif err5 != None {\n    fmt.Printf(\"Conversion failed: %s\\n\", err5)\n}\n</code></pre></p>"},{"location":"stdlib/cast/#tofloatvalue","title":"<code>ToFloat(value)</code>","text":"<p>Converts a value to a floating-point number.</p> <p>Parameters: - <code>value</code>: The value to convert (string, integer, boolean, or float)</p> <p>Returns: - <code>(float, error)</code>: Float representation of the value</p> <p>Conversion Rules: - String: Must be a valid float format - Integer: Converts to equivalent float - Boolean: <code>true</code> \u2192 1.0, <code>false</code> \u2192 0.0 - Float: Returns as-is - None: Returns error</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar float1, err1 = cast.ToFloat(\"3.14159\")  // 3.14159\nvar float2, err2 = cast.ToFloat(42)         // 42.0\nvar float3, err3 = cast.ToFloat(true)       // 1.0\n\nfmt.Printf(\"Pi: %s\\n\", float1)\nfmt.Printf(\"Answer: %s\\n\", float2)\n</code></pre></p>"},{"location":"stdlib/cast/#toboolvalue","title":"<code>ToBool(value)</code>","text":"<p>Converts a value to a boolean with flexible conversion rules.</p> <p>Parameters: - <code>value</code>: The value to convert (any type)</p> <p>Returns: - <code>(bool, error)</code>: Boolean representation of the value</p> <p>Conversion Rules: - String:    - <code>\"true\"</code>, <code>\"1\"</code>, <code>\"yes\"</code>, <code>\"on\"</code> \u2192 <code>true</code>   - <code>\"false\"</code>, <code>\"0\"</code>, <code>\"no\"</code>, <code>\"off\"</code>, <code>\"\"</code> \u2192 <code>false</code>   - Case-insensitive - Numbers: <code>0</code> \u2192 <code>false</code>, any other number \u2192 <code>true</code> - None: \u2192 <code>false</code> - Arrays/Maps: empty \u2192 <code>false</code>, non-empty \u2192 <code>true</code> - Boolean: Returns as-is</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar bool1, err1 = cast.ToBool(\"true\")     // true\nvar bool2, err2 = cast.ToBool(\"yes\")      // true\nvar bool3, err3 = cast.ToBool(\"1\")        // true\nvar bool4, err4 = cast.ToBool(0)          // false\nvar bool5, err5 = cast.ToBool([])         // false (empty array)\nvar bool6, err6 = cast.ToBool([1, 2])     // true (non-empty array)\n\nfmt.Printf(\"String to bool: %s\\n\", bool1)\nfmt.Printf(\"Array to bool: %s\\n\", bool6)\n</code></pre></p>"},{"location":"stdlib/cast/#toarrayvalue","title":"<code>ToArray(value)</code>","text":"<p>Converts a value to an array.</p> <p>Parameters: - <code>value</code>: The value to convert (string, map, or array)</p> <p>Returns: - <code>(array, error)</code>: Array representation of the value</p> <p>Conversion Rules: - String: Converts to array of characters - Map: Converts to array of <code>[key, value]</code> pairs - Array: Returns as-is - Other types: Returns error</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar arr1, err1 = cast.ToArray(\"hello\")          // [\"h\", \"e\", \"l\", \"l\", \"o\"]\nvar arr2, err2 = cast.ToArray({\"a\": 1, \"b\": 2}) // [[\"a\", 1], [\"b\", 2]]\nvar arr3, err3 = cast.ToArray([1, 2, 3])        // [1, 2, 3]\n\nfmt.Printf(\"String to array: %s\\n\", arr1)\nfmt.Printf(\"Map to array: %s\\n\", arr2)\n</code></pre></p>"},{"location":"stdlib/cast/#tomapvalue","title":"<code>ToMap(value)</code>","text":"<p>Converts a value to a map.</p> <p>Parameters: - <code>value</code>: The value to convert (array of pairs or map)</p> <p>Returns: - <code>(map, error)</code>: Map representation of the value</p> <p>Conversion Rules: - Array: Must be array of <code>[key, value]</code> pairs with hashable keys - Map: Returns as-is - Other types: Returns error</p> <p>Hashable Keys: Strings, integers, and booleans</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar map1, err1 = cast.ToMap([[\"a\", 1], [\"b\", 2], [\"c\", 3]])  // {\"a\": 1, \"b\": 2, \"c\": 3}\nvar map2, err2 = cast.ToMap({\"x\": 10, \"y\": 20})             // {\"x\": 10, \"y\": 20}\n\n// Error case - invalid structure\nvar invalid, err3 = cast.ToMap([1, 2, 3])  // Error: not pairs\nif err3 != None {\n    fmt.Printf(\"Conversion failed: %s\\n\", err3)\n}\n\nfmt.Printf(\"Array to map: %s\\n\", map1)\n</code></pre></p>"},{"location":"stdlib/cast/#cancastvalue-targettype","title":"<code>CanCast(value, targetType)</code>","text":"<p>Checks if a value can be cast to a specific type without performing the conversion.</p> <p>Parameters: - <code>value</code>: The value to check - <code>targetType</code>: Target type as string (<code>\"string\"</code>, <code>\"int\"</code>, <code>\"float\"</code>, <code>\"bool\"</code>, <code>\"array\"</code>, <code>\"map\"</code>)</p> <p>Returns: - <code>(bool, error)</code>: <code>true</code> if casting is possible, <code>false</code> otherwise</p> <p>Examples: <pre><code>package main\nimport fmt\nimport cast\n\nvar canCast1, err1 = cast.CanCast(\"42\", \"int\")        // true\nvar canCast2, err2 = cast.CanCast(\"hello\", \"int\")     // false\nvar canCast3, err3 = cast.CanCast([1, 2], \"array\")    // true\nvar canCast4, err4 = cast.CanCast(\"anything\", \"string\") // true (everything can be string)\n\n// Use before casting to avoid errors\nif canCast1 {\n    var num, _ = cast.ToInt(\"42\")\n    fmt.Printf(\"Converted: %s\\n\", num)\n}\n\nfmt.Printf(\"Can cast '42' to int: %s\\n\", canCast1)\nfmt.Printf(\"Can cast 'hello' to int: %s\\n\", canCast2)\n</code></pre></p>"},{"location":"stdlib/cast/#type-conversion-matrix","title":"Type Conversion Matrix","text":"From Type To String To Int To Float To Bool To Array To Map String \u2705 Always \u2705 If valid \u2705 If valid \u2705 Flexible rules \u2705 To chars \u274c No Integer \u2705 Always \u2705 Always \u2705 Always \u2705 0\u2192false, other\u2192true \u274c No \u274c No Float \u2705 Always \u2705 Truncate \u2705 Always \u2705 0.0\u2192false, other\u2192true \u274c No \u274c No Boolean \u2705 Always \u2705 1/0 \u2705 1.0/0.0 \u2705 Always \u274c No \u274c No Array \u2705 Always \u274c No \u274c No \u2705 Empty\u2192false \u2705 Always \u2705 If pairs Map \u2705 Always \u274c No \u274c No \u2705 Empty\u2192false \u2705 To pairs \u2705 Always None \u2705 \"None\" \u274c Error \u274c Error \u2705 false \u274c Error \u274c Error"},{"location":"stdlib/cast/#error-handling","title":"Error Handling","text":"<p>The cast module provides detailed error messages for failed conversions:</p> <pre><code>package main\nimport fmt\nimport cast\n\n// Invalid string to integer\nvar result, err = cast.ToInt(\"not_a_number\")\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n    // Output: Error: cast.ToInt: cannot convert string \"not_a_number\" to integer: strconv.ParseInt: parsing \"not_a_number\": invalid syntax\n}\n\n// Invalid array to map (not pairs)\nvar mapResult, mapErr = cast.ToMap([1, 2, 3])\nif mapErr != None {\n    fmt.Printf(\"Error: %s\\n\", mapErr)\n    // Output: Error: cast.ToMap: array element 0 is not an array (expected [key, value] pairs)\n}\n\n// Unsupported conversion\nvar boolResult, boolErr = cast.ToBool(\"maybe\")\nif boolErr != None {\n    fmt.Printf(\"Error: %s\\n\", boolErr)\n    // Output: Error: cast.ToBool: cannot convert string \"maybe\" to boolean (valid values: true/false, 1/0, yes/no, on/off)\n}\n</code></pre>"},{"location":"stdlib/cast/#common-use-cases","title":"Common Use Cases","text":""},{"location":"stdlib/cast/#data-validation-and-conversion","title":"Data Validation and Conversion","text":"<pre><code>package main\nimport fmt\nimport cast\n\nfunction processUserInput(input string, expectedType string) {\n    var canConvert, _ = cast.CanCast(input, expectedType)\n    if !canConvert {\n        fmt.Printf(\"Invalid input: cannot convert '%s' to %s\\n\", input, expectedType)\n        return\n    }\n\n    if expectedType == \"int\" {\n        var value, err = cast.ToInt(input)\n        if err == None {\n            fmt.Printf(\"Processing integer: %s\\n\", value)\n        }\n    } else if expectedType == \"float\" {\n        var value, err = cast.ToFloat(input)\n        if err == None {\n            fmt.Printf(\"Processing float: %s\\n\", value)\n        }\n    }\n}\n\nprocessUserInput(\"42\", \"int\")      // Processing integer: 42\nprocessUserInput(\"hello\", \"int\")   // Invalid input: cannot convert 'hello' to int\n</code></pre>"},{"location":"stdlib/cast/#configuration-processing","title":"Configuration Processing","text":"<pre><code>package main\nimport fmt\nimport cast\n\nfunction parseConfig(configMap map) {\n    // Convert string values to appropriate types\n    var portStr = configMap[\"port\"]\n    var port, portErr = cast.ToInt(portStr)\n\n    var enabledStr = configMap[\"enabled\"]\n    var enabled, enabledErr = cast.ToBool(enabledStr)\n\n    if portErr == None &amp;&amp; enabledErr == None {\n        fmt.Printf(\"Server config - Port: %s, Enabled: %s\\n\", port, enabled)\n    }\n}\n\nvar config = {\"port\": \"8080\", \"enabled\": \"true\"}\nparseConfig(config)  // Server config - Port: 8080, Enabled: true\n</code></pre>"},{"location":"stdlib/cast/#data-structure-transformation","title":"Data Structure Transformation","text":"<pre><code>package main\nimport fmt\nimport cast\n\n// Convert CSV-like data to structured format\nvar csvData = [[\"name\", \"age\"], [\"Alice\", \"25\"], [\"Bob\", \"30\"]]\nvar headers = csvData[0]\nvar rows = csvData[1:]\n\nvar records = []\nfor row in rows {\n    var record = {}\n    for i, value in row {\n        var header = headers[i]\n        if header == \"age\" {\n            var ageInt, _ = cast.ToInt(value)\n            record[header] = ageInt\n        } else {\n            record[header] = value\n        }\n    }\n    records = append(records, record)\n}\n\nfmt.Printf(\"Structured data: %s\\n\", records)\n// Output: Structured data: [{\"name\": \"Alice\", \"age\": 25}, {\"name\": \"Bob\", \"age\": 30}]\n</code></pre>"},{"location":"stdlib/cast/#integration-with-other-modules","title":"Integration with Other Modules","text":""},{"location":"stdlib/cast/#json-and-cast-integration","title":"JSON and Cast Integration","text":"<pre><code>package main\nimport fmt\nimport json\nimport cast\n\n// Parse JSON and convert specific fields\nvar jsonStr = \"{\\\"id\\\": \\\"123\\\", \\\"active\\\": \\\"true\\\", \\\"score\\\": \\\"95.5\\\"}\"\nvar data, _ = json.Unmarshal(jsonStr)\n\nvar id, _ = cast.ToInt(data[\"id\"])\nvar active, _ = cast.ToBool(data[\"active\"])\nvar score, _ = cast.ToFloat(data[\"score\"])\n\nvar processedData = {\n    \"id\": id,\n    \"active\": active,\n    \"score\": score\n}\n\nfmt.Printf(\"Processed: %s\\n\", processedData)\n// Output: Processed: {\"id\": 123, \"active\": true, \"score\": 95.5}\n</code></pre>"},{"location":"stdlib/cast/#os-and-cast-integration","title":"OS and Cast Integration","text":"<pre><code>package main\nimport fmt\nimport os\nimport cast\n\n// Convert environment variables to appropriate types\nvar portEnv, _ = os.Getenv(\"PORT\")\nvar debugEnv, _ = os.Getenv(\"DEBUG\")\n\nvar port, portErr = cast.ToInt(portEnv)\nvar debug, debugErr = cast.ToBool(debugEnv)\n\nif portErr == None &amp;&amp; debugErr == None {\n    fmt.Printf(\"Config - Port: %s, Debug: %s\\n\", port, debug)\n}\n</code></pre>"},{"location":"stdlib/cast/#see-also","title":"See Also","text":"<ul> <li>JSON - JSON serialization and parsing</li> <li>Strings - String manipulation functions</li> <li>Arrays - Array operations</li> <li>Maps - Map data structures</li> <li>Error Handling - Error handling patterns</li> </ul>"},{"location":"stdlib/collections/","title":"<code>collections</code> Module","text":"<p>The <code>collections</code> module provides data structures for storing and manipulating collections of values.</p>"},{"location":"stdlib/collections/#stack","title":"Stack","text":"<p>A Last-In-First-Out (LIFO) data structure.</p>"},{"location":"stdlib/collections/#new_stack","title":"<code>new_stack()</code>","text":"<p>Creates and returns a new empty stack.</p> <p>Returns:</p> <ul> <li><code>Stack</code>: A new empty stack.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport collections\n\nlet s = collections.new_stack()\n</code></pre>"},{"location":"stdlib/collections/#pushitem","title":"<code>push(item)</code>","text":"<p>Adds an item to the top of the stack.</p> <p>Parameters:</p> <ul> <li><code>item</code>: The item to add to the stack.</li> </ul> <p>Example:</p> <pre><code>s.push(42)\ns.push(\"hello\")\n</code></pre>"},{"location":"stdlib/collections/#pop","title":"<code>pop()</code>","text":"<p>Removes and returns the top item from the stack.</p> <p>Returns:</p> <ul> <li><code>any</code>: The top item, or <code>None</code> if the stack is empty.</li> </ul> <p>Example:</p> <pre><code>package main\nlet item = s.pop()\nfmt.Println(\"Popped:\", item)\n</code></pre>"},{"location":"stdlib/collections/#peek","title":"<code>peek()</code>","text":"<p>Returns the top item without removing it.</p> <p>Returns:</p> <ul> <li><code>any</code>: The top item, or <code>None</code> if the stack is empty.</li> </ul> <p>Example:</p> <pre><code>package main\nlet top = s.peek()\nfmt.Println(\"Top item:\", top)\n</code></pre>"},{"location":"stdlib/collections/#is_empty","title":"<code>is_empty()</code>","text":"<p>Checks if the stack is empty.</p> <p>Returns:</p> <ul> <li><code>bool</code>: <code>true</code> if the stack is empty, <code>false</code> otherwise.</li> </ul> <p>Example:</p> <pre><code>package main\nif s.is_empty() {\n    fmt.Println(\"Stack is empty\")\n}\n</code></pre>"},{"location":"stdlib/collections/#size","title":"<code>size()</code>","text":"<p>Returns the number of items in the stack.</p> <p>Returns:</p> <ul> <li><code>int</code>: The number of items in the stack.</li> </ul> <p>Example:</p> <pre><code>package main\nfmt.Println(\"Stack size:\", s.size())\n</code></pre>"},{"location":"stdlib/collections/#inspect","title":"<code>inspect()</code>","text":"<p>Returns a string representation of the stack.</p> <p>Returns:</p> <ul> <li><code>string</code>: A string representation of the stack.</li> </ul> <p>Example:</p> <pre><code>package main\nfmt.Println(\"Stack:\", s.inspect())\n</code></pre>"},{"location":"stdlib/collections/#queue","title":"Queue","text":"<p>A First-In-First-Out (FIFO) data structure.</p>"},{"location":"stdlib/collections/#new_queue","title":"<code>new_queue()</code>","text":"<p>Creates and returns a new empty queue.</p> <p>Returns:</p> <ul> <li><code>Queue</code>: A new empty queue.</li> </ul> <p>Example:</p> <pre><code>let q = collections.new_queue()\n</code></pre>"},{"location":"stdlib/collections/#enqueueitem","title":"<code>enqueue(item)</code>","text":"<p>Adds an item to the end of the queue.</p> <p>Parameters:</p> <ul> <li><code>item</code>: The item to add to the queue.</li> </ul> <p>Example:</p> <pre><code>q.enqueue(\"first\")\nq.enqueue(\"second\")\n</code></pre>"},{"location":"stdlib/collections/#dequeue","title":"<code>dequeue()</code>","text":"<p>Removes and returns the first item from the queue.</p> <p>Returns:</p> <ul> <li><code>any</code>: The first item, or <code>None</code> if the queue is empty.</li> </ul> <p>Example:</p> <pre><code>package main\nlet item = q.dequeue()\nfmt.Println(\"Dequeued:\", item)\n</code></pre>"},{"location":"stdlib/collections/#peek_1","title":"<code>peek()</code>","text":"<p>Returns the first item without removing it.</p> <p>Returns:</p> <ul> <li><code>any</code>: The first item, or <code>None</code> if the queue is empty.</li> </ul> <p>Example:</p> <pre><code>package main\nlet first = q.peek()\nfmt.Println(\"First item:\", first)\n</code></pre>"},{"location":"stdlib/collections/#is_empty_1","title":"<code>is_empty()</code>","text":"<p>Checks if the queue is empty.</p> <p>Returns:</p> <ul> <li><code>bool</code>: <code>true</code> if the queue is empty, <code>false</code> otherwise.</li> </ul> <p>Example:</p> <pre><code>package main\nif q.is_empty() {\n    fmt.Println(\"Queue is empty\")\n}\n</code></pre>"},{"location":"stdlib/collections/#size_1","title":"<code>size()</code>","text":"<p>Returns the number of items in the queue.</p> <p>Returns:</p> <ul> <li><code>int</code>: The number of items in the queue.</li> </ul> <p>Example:</p> <pre><code>package main\nfmt.Println(\"Queue size:\", q.size())\n</code></pre>"},{"location":"stdlib/collections/#inspect_1","title":"<code>inspect()</code>","text":"<p>Returns a string representation of the queue.</p> <p>Returns:</p> <ul> <li><code>string</code>: A string representation of the queue.</li> </ul> <p>Example:</p> <pre><code>package main\nfmt.Println(\"Queue:\", q.inspect())\n</code></pre>"},{"location":"stdlib/collections/#complete-example","title":"Complete Example","text":"<pre><code>package main\nimport fmt\nimport collections\n\n// Stack example\nlet stack = collections.new_stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\n\nfmt.Println(\"Stack:\", stack.inspect())  // [1, 2, 3]\nfmt.Println(\"Size:\", stack.size())      // 3\n\nlet top = stack.pop()\nfmt.Println(\"Popped:\", top)            // 3\nfmt.Println(\"Stack:\", stack.inspect())  // [1, 2]\n\n// Queue example\nlet queue = collections.new_queue()\nqueue.enqueue(\"first\")\nqueue.enqueue(\"second\")\nqueue.enqueue(\"third\")\n\nfmt.Println(\"Queue:\", queue.inspect())  // [\"first\", \"second\", \"third\"]\nfmt.Println(\"Size:\", queue.size())      // 3\n\nlet first = queue.dequeue()\nfmt.Println(\"Dequeued:\", first)        // \"first\"\nfmt.Println(\"Queue:\", queue.inspect())  // [\"second\", \"third\"]\n</code></pre>"},{"location":"stdlib/collections/#draining-a-queue-while-style-loop-using-for","title":"Draining a queue (while-style loop using <code>for</code>)","text":"<p>Harneet does not have a separate <code>while</code> keyword. Use a condition-only <code>for</code> loop to achieve the same effect (just like Go):</p> <pre><code>package main\nimport fmt\nimport collections\n\nlet q = collections.new_queue()\nq.enqueue(\"a\")\nq.enqueue(\"b\")\nq.enqueue(\"c\")\n\nfmt.Println(\"Draining queue:\")\nfor !q.is_empty() {\n    fmt.Println(\"  dequeued:\", q.dequeue())\n}\n\nfmt.Println(\"Empty now?\", q.is_empty())\n</code></pre>"},{"location":"stdlib/config/","title":"Config Module","text":"<p>The <code>config</code> module provides comprehensive configuration file parsing and management, similar to Viper in Go. It supports multiple formats (YAML, TOML, XML, CSV) with full type safety, nested structure access, and environment variable overlay.</p>"},{"location":"stdlib/config/#features","title":"Features","text":"<ul> <li>\u2705 Multiple Formats: YAML, TOML, XML, and CSV support</li> <li>\u2705 Auto-Detection: Automatic format detection from file extension</li> <li>\u2705 Type-Safe Access: Dedicated getters with type validation</li> <li>\u2705 Dot Notation: Navigate nested structures with simple paths</li> <li>\u2705 Direct Property Access: Use <code>cfg.key</code> for clean code</li> <li>\u2705 Default Values: Built-in support for fallback values</li> <li>\u2705 Environment Variables: Overlay environment variables on config</li> <li>\u2705 Config Merging: Combine multiple configuration sources</li> <li>\u2705 Complex Structures: Handle deeply nested maps and arrays</li> </ul>"},{"location":"stdlib/config/#import","title":"Import","text":"<pre><code>import config\n</code></pre>"},{"location":"stdlib/config/#file-reading","title":"File Reading","text":""},{"location":"stdlib/config/#readfilefilepath-string-map-error","title":"ReadFile(filepath string) (map, error)","text":"<p>Reads and parses a configuration file, automatically detecting the format from the file extension.</p> <p>Supported Extensions: - <code>.yaml</code> / <code>.yml</code> - YAML format - <code>.toml</code> - TOML format - <code>.xml</code> - XML format - <code>.csv</code> - CSV format (returns array of maps)</p> <p>Example:</p> <pre><code>import config\nimport fmt\n\n// Read YAML configuration\nvar cfg, err = config.ReadFile(\"config.yaml\")\nif err != None {\n    fmt.Printf(\"Error: %v\\n\", err)\n    return\n}\n\n// Access values\nvar host = cfg.server.host\nvar port = cfg.server.port\nfmt.Printf(\"Server: %s:%d\\n\", host, port)\n</code></pre>"},{"location":"stdlib/config/#format-specific-parsing","title":"Format-Specific Parsing","text":""},{"location":"stdlib/config/#parseyamlcontent-string-map-error","title":"ParseYAML(content string) (map, error)","text":"<p>Parses YAML content from a string.</p> <pre><code>var yamlStr = \"name: MyApp\\nversion: 1.0.0\\nenabled: true\"\nvar cfg, err = config.ParseYAML(yamlStr)\nif err == None {\n    var name = cfg.name  // \"MyApp\"\n    fmt.Printf(\"App: %s\\n\", name)\n}\n</code></pre>"},{"location":"stdlib/config/#parsetomlcontent-string-map-error","title":"ParseTOML(content string) (map, error)","text":"<p>Parses TOML content from a string.</p> <pre><code>var tomlStr = \"[server]\\nhost = \\\"localhost\\\"\\nport = 8080\"\nvar cfg, err = config.ParseTOML(tomlStr)\nif err == None {\n    var host = cfg.server.host  // \"localhost\"\n}\n</code></pre>"},{"location":"stdlib/config/#parsexmlcontent-string-map-error","title":"ParseXML(content string) (map, error)","text":"<p>Parses XML content from a string.</p> <pre><code>var xmlStr = \"&lt;config&gt;&lt;server&gt;&lt;host&gt;localhost&lt;/host&gt;&lt;/server&gt;&lt;/config&gt;\"\nvar cfg, err = config.ParseXML(xmlStr)\n</code></pre>"},{"location":"stdlib/config/#parsecsvcontent-string-array-error","title":"ParseCSV(content string) (array, error)","text":"<p>Parses CSV content with automatic header detection and type inference.</p> <pre><code>var csvData = \"name,age,active\\nAlice,30,true\\nBob,25,false\"\nvar rows, err = config.ParseCSV(csvData)\nif err == None {\n    for row in rows {\n        var name = row.name\n        var age = row.age\n        fmt.Printf(\"%s is %d years old\\n\", name, age)\n    }\n}\n</code></pre>"},{"location":"stdlib/config/#value-extraction","title":"Value Extraction","text":""},{"location":"stdlib/config/#two-access-styles","title":"Two Access Styles","text":"<p>The config module supports two ways to access values:</p>"},{"location":"stdlib/config/#1-direct-dot-access-recommended-for-simple-cases","title":"1. Direct Dot Access (Recommended for Simple Cases)","text":"<pre><code>var cfg, _ = config.ReadFile(\"config.yaml\")\n\n// Direct property access\nvar version = cfg.version\nvar host = cfg.server.host\nvar port = cfg.server.port\n\n// Deep nesting (4+ levels)\nvar dbPassword = cfg.services.database.environment.POSTGRES_PASSWORD\n</code></pre> <p>Advantages: - Clean, readable code - Natural JavaScript/Python-like syntax - Returns <code>None</code> for missing keys</p>"},{"location":"stdlib/config/#2-type-safe-getters-recommended-for-validation","title":"2. Type-Safe Getters (Recommended for Validation)","text":"<pre><code>// Type-safe extraction with error handling\nvar host, err = config.GetString(cfg, \"server.host\")\nvar port, err = config.GetInt(cfg, \"server.port\")\nvar ssl, err = config.GetBool(cfg, \"server.ssl\")\n</code></pre> <p>Advantages: - Explicit type validation - Error tuples for missing keys - Type conversion included</p>"},{"location":"stdlib/config/#getconfig-map-path-string-any-error","title":"Get(config map, path string) (any, error)","text":"<p>Retrieves a value from config using dot-notation path.</p> <pre><code>var value, err = config.Get(cfg, \"database.connection.host\")\nif err == None {\n    fmt.Printf(\"Value: %v\\n\", value)\n}\n</code></pre>"},{"location":"stdlib/config/#getstringconfig-map-path-string-string-error","title":"GetString(config map, path string) (string, error)","text":"<p>Retrieves a string value with type validation.</p> <pre><code>var hostname, err = config.GetString(cfg, \"server.hostname\")\nif err != None {\n    fmt.Printf(\"Error: %v\\n\", err)\n}\n</code></pre>"},{"location":"stdlib/config/#getintconfig-map-path-string-int-error","title":"GetInt(config map, path string) (int, error)","text":"<p>Retrieves an integer value with type validation.</p> <pre><code>var port, err = config.GetInt(cfg, \"server.port\")\nif err != None {\n    fmt.Println(\"Port not found or invalid\")\n}\n</code></pre>"},{"location":"stdlib/config/#getfloatconfig-map-path-string-float64-error","title":"GetFloat(config map, path string) (float64, error)","text":"<p>Retrieves a float value with type validation.</p> <pre><code>var timeout, err = config.GetFloat(cfg, \"api.timeout\")\n</code></pre>"},{"location":"stdlib/config/#getboolconfig-map-path-string-bool-error","title":"GetBool(config map, path string) (bool, error)","text":"<p>Retrieves a boolean value with type validation.</p> <pre><code>var debug, err = config.GetBool(cfg, \"features.debug\")\n</code></pre>"},{"location":"stdlib/config/#getarrayconfig-map-path-string-array-error","title":"GetArray(config map, path string) (array, error)","text":"<p>Retrieves an array value.</p> <pre><code>var servers, err = config.GetArray(cfg, \"api.endpoints\")\nif err == None {\n    for server in servers {\n        fmt.Printf(\"Endpoint: %v\\n\", server)\n    }\n}\n</code></pre>"},{"location":"stdlib/config/#getmapconfig-map-path-string-map-error","title":"GetMap(config map, path string) (map, error)","text":"<p>Retrieves a nested map.</p> <pre><code>var database, err = config.GetMap(cfg, \"database\")\nif err == None {\n    var host = database.host\n    var port = database.port\n}\n</code></pre>"},{"location":"stdlib/config/#default-values","title":"Default Values","text":""},{"location":"stdlib/config/#getstringorconfig-map-path-string-default-string-string","title":"GetStringOr(config map, path string, default string) string","text":"<p>Returns the string value or a default if not found.</p> <pre><code>var env = config.GetStringOr(cfg, \"environment\", \"development\")\nvar host = config.GetStringOr(cfg, \"server.host\", \"localhost\")\n</code></pre>"},{"location":"stdlib/config/#getintorconfig-map-path-string-default-int-int","title":"GetIntOr(config map, path string, default int) int","text":"<pre><code>var port = config.GetIntOr(cfg, \"server.port\", 8080)\nvar timeout = config.GetIntOr(cfg, \"timeout\", 30)\n</code></pre>"},{"location":"stdlib/config/#getfloatorconfig-map-path-string-default-float64-float64","title":"GetFloatOr(config map, path string, default float64) float64","text":"<pre><code>var ratio = config.GetFloatOr(cfg, \"performance.ratio\", 0.75)\n</code></pre>"},{"location":"stdlib/config/#getboolorconfig-map-path-string-default-bool-bool","title":"GetBoolOr(config map, path string, default bool) bool","text":"<pre><code>var debug = config.GetBoolOr(cfg, \"debug\", false)\nvar enabled = config.GetBoolOr(cfg, \"features.logging\", true)\n</code></pre>"},{"location":"stdlib/config/#advanced-features","title":"Advanced Features","text":""},{"location":"stdlib/config/#readfilewithenvfilepath-string-prefix-string-map-error","title":"ReadFileWithEnv(filepath string, prefix string) (map, error)","text":"<p>Reads a config file and overlays environment variables.</p> <pre><code>// Reads config.yaml and overlays environment variables\n// with prefix APP (e.g., APP_SERVER_HOST, APP_SERVER_PORT)\nvar cfg, err = config.ReadFileWithEnv(\"config.yaml\", \"APP\")\n\n// Environment variable APP_SERVER_HOST overrides cfg.server.host\nvar host = cfg.server.host\n</code></pre> <p>Example:</p> <pre><code># Set environment variables\nexport APP_SERVER_HOST=production.example.com\nexport APP_SERVER_PORT=9000\n</code></pre> <pre><code>// These will use environment values if set\nvar cfg, _ = config.ReadFileWithEnv(\"config.yaml\", \"APP\")\nvar host = cfg.server.host  // \"production.example.com\" from env\nvar port = cfg.server.port  // 9000 from env\n</code></pre>"},{"location":"stdlib/config/#mergeconfigsconfigs-map-map-error","title":"MergeConfigs(configs ...map) (map, error)","text":"<p>Merges multiple configuration maps. Later configs override earlier ones.</p> <pre><code>// Base configuration\nvar baseConfig = {\"timeout\": 30, \"retries\": 3}\n\n// Environment-specific overrides\nvar prodConfig = {\"timeout\": 60, \"retries\": 5, \"cache\": true}\n\n// Merge configurations\nvar finalConfig, _ = config.MergeConfigs(baseConfig, prodConfig)\n\n// finalConfig: {timeout: 60, retries: 5, cache: true}\n</code></pre>"},{"location":"stdlib/config/#real-world-examples","title":"Real-World Examples","text":""},{"location":"stdlib/config/#example-1-docker-compose-configuration","title":"Example 1: Docker Compose Configuration","text":"<p>docker-compose.yaml: <pre><code>version: '3.8'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"80:80\"\n    networks:\n      - app-network\n  database:\n    image: postgres:latest\n    environment:\n      POSTGRES_DB: mydb\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - db-data:/var/lib/postgresql/data\n</code></pre></p> <p>Parsing with Harneet: <pre><code>import config\nimport fmt\n\nfunction main() {\n    var cfg, err = config.ReadFile(\"docker-compose.yaml\")\n    if err != None {\n        fmt.Printf(\"Error: %v\\n\", err)\n        return\n    }\n\n    // Direct dot access (clean and readable)\n    var version = cfg.version\n    var webImage = cfg.services.web.image\n    var dbPassword = cfg.services.database.environment.POSTGRES_PASSWORD\n\n    fmt.Printf(\"Docker Compose Version: %s\\n\", version)\n    fmt.Printf(\"Web Image: %s\\n\", webImage)\n    fmt.Printf(\"Database Password: %s\\n\", dbPassword)\n\n    // Type-safe getters (with validation)\n    var webPorts, _ = config.GetArray(cfg, \"services.web.ports\")\n    var dbVolumes, _ = config.GetArray(cfg, \"services.database.volumes\")\n\n    fmt.Printf(\"Web Ports: %v\\n\", webPorts)\n    fmt.Printf(\"Database Volumes: %v\\n\", dbVolumes)\n}\n</code></pre></p>"},{"location":"stdlib/config/#example-2-application-configuration-yaml","title":"Example 2: Application Configuration (YAML)","text":"<p>config.yaml: <pre><code>server:\n  host: localhost\n  port: 8080\n  ssl: true\n\ndatabase:\n  host: db.example.com\n  port: 5432\n  name: myapp\n  pool_size: 10\n\nfeatures:\n  debug: false\n  logging: true\n  cache_enabled: true\n\napi:\n  timeout: 30\n  retries: 3\n  endpoints:\n    - https://api1.example.com\n    - https://api2.example.com\n</code></pre></p> <p>Using the config: <pre><code>import config\nimport fmt\n\nfunction main() {\n    var cfg, _ = config.ReadFile(\"config.yaml\")\n\n    // Extract server configuration\n    var host = cfg.server.host\n    var port = cfg.server.port\n    var ssl = cfg.server.ssl\n\n    fmt.Printf(\"Starting server on %s:%d (SSL: %v)\\n\", host, port, ssl)\n\n    // Database configuration with defaults\n    var dbHost = config.GetStringOr(cfg, \"database.host\", \"localhost\")\n    var dbPort = config.GetIntOr(cfg, \"database.port\", 5432)\n    var poolSize = config.GetIntOr(cfg, \"database.pool_size\", 5)\n\n    fmt.Printf(\"Database: %s:%d (pool: %d)\\n\", dbHost, dbPort, poolSize)\n\n    // Feature flags\n    var debug = config.GetBoolOr(cfg, \"features.debug\", false)\n    var logging = config.GetBoolOr(cfg, \"features.logging\", true)\n\n    if debug {\n        fmt.Println(\"Debug mode enabled\")\n    }\n    if logging {\n        fmt.Println(\"Logging enabled\")\n    }\n\n    // API endpoints\n    var endpoints, _ = config.GetArray(cfg, \"api.endpoints\")\n    fmt.Println(\"API Endpoints:\")\n    for endpoint in endpoints {\n        fmt.Printf(\"  - %v\\n\", endpoint)\n    }\n}\n</code></pre></p>"},{"location":"stdlib/config/#example-3-editor-configuration-toml","title":"Example 3: Editor Configuration (TOML)","text":"<p>config.toml: <pre><code>theme = \"dark\"\n\n[editor]\nline-number = \"relative\"\nrainbow-brackets = true\nmax-panel-width = 120\n\n[editor.cursor-shape]\ninsert = \"block\"\nnormal = \"block\"\n\n[editor.lsp]\ndisplay-inlay-hints = false\ndisplay-messages = true\n\n[keys.normal]\ntab = \"rotate_view\"\nC-p = \"file_picker\"\n</code></pre></p> <p>Reading the configuration: <pre><code>import config\nimport fmt\n\nfunction main() {\n    var cfg, _ = config.ReadFile(\"config.toml\")\n\n    // Simple values\n    var theme = cfg.theme\n    fmt.Printf(\"Theme: %s\\n\", theme)\n\n    // Nested configuration (use getters for hyphenated keys)\n    var lineNumber, _ = config.GetString(cfg, \"editor.line-number\")\n    var rainbowBrackets, _ = config.GetBool(cfg, \"editor.rainbow-brackets\")\n    var maxWidth, _ = config.GetInt(cfg, \"editor.max-panel-width\")\n\n    fmt.Printf(\"Line Numbers: %s\\n\", lineNumber)\n    fmt.Printf(\"Rainbow Brackets: %v\\n\", rainbowBrackets)\n    fmt.Printf(\"Max Width: %d\\n\", maxWidth)\n\n    // Deep nesting\n    var insertCursor, _ = config.GetString(cfg, \"editor.cursor-shape.insert\")\n    var normalCursor, _ = config.GetString(cfg, \"editor.cursor-shape.normal\")\n\n    fmt.Printf(\"Cursor Shapes - Insert: %s, Normal: %s\\n\", insertCursor, normalCursor)\n\n    // Key bindings\n    var tabAction, _ = config.GetString(cfg, \"keys.normal.tab\")\n    var ctrlP, _ = config.GetString(cfg, \"keys.normal.C-p\")\n\n    fmt.Printf(\"Tab: %s, Ctrl-P: %s\\n\", tabAction, ctrlP)\n}\n</code></pre></p>"},{"location":"stdlib/config/#example-4-environment-variable-overlay","title":"Example 4: Environment Variable Overlay","text":"<p>config.yaml: <pre><code>server:\n  host: localhost\n  port: 8080\ndatabase:\n  host: localhost\n  port: 5432\n</code></pre></p> <p>Using environment overlay: <pre><code>import config\nimport fmt\n\nfunction main() {\n    // Read config with APP_ prefix for environment variables\n    // Environment: APP_SERVER_HOST=production.com, APP_SERVER_PORT=443\n    var cfg, _ = config.ReadFileWithEnv(\"config.yaml\", \"APP\")\n\n    // These will use environment values if set\n    var serverHost = cfg.server.host  // \"production.com\" from APP_SERVER_HOST\n    var serverPort = cfg.server.port  // 443 from APP_SERVER_PORT\n\n    fmt.Printf(\"Server: %s:%d\\n\", serverHost, serverPort)\n}\n</code></pre></p>"},{"location":"stdlib/config/#example-5-multi-environment-configuration","title":"Example 5: Multi-Environment Configuration","text":"<pre><code>import config\nimport os\nimport fmt\n\nfunction main() {\n    // Load base configuration\n    var baseConfig, _ = config.ReadFile(\"config.base.yaml\")\n\n    // Load environment-specific configuration\n    var env, _ = os.Getenv(\"ENVIRONMENT\")\n    if env == \"\" {\n        env = \"development\"\n    }\n\n    var envConfigPath = \"config.\" + env + \".yaml\"\n    var envConfig, err = config.ReadFile(envConfigPath)\n\n    var finalConfig = baseConfig\n    if err == None {\n        // Merge environment-specific overrides\n        finalConfig, _ = config.MergeConfigs(baseConfig, envConfig)\n    }\n\n    // Overlay environment variables\n    finalConfig, _ = config.ReadFileWithEnv(\"config.base.yaml\", \"APP\")\n\n    // Use the final merged configuration\n    var host = finalConfig.server.host\n    var port = finalConfig.server.port\n\n    fmt.Printf(\"Running on %s:%d (env: %s)\\n\", host, port, env)\n}\n</code></pre>"},{"location":"stdlib/config/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/config/#1-use-direct-dot-access-for-simple-cases","title":"1. Use Direct Dot Access for Simple Cases","text":"<pre><code>// Clean and readable\nvar host = cfg.server.host\nvar port = cfg.server.port\nvar ssl = cfg.server.ssl\n</code></pre>"},{"location":"stdlib/config/#2-use-type-safe-getters-for-validation","title":"2. Use Type-Safe Getters for Validation","text":"<pre><code>// When you need explicit error handling\nvar timeout, err = config.GetInt(cfg, \"api.timeout\")\nif err != None {\n    fmt.Println(\"Timeout not configured, using default\")\n    timeout = 30\n}\n</code></pre>"},{"location":"stdlib/config/#3-always-provide-defaults","title":"3. Always Provide Defaults","text":"<pre><code>// Use GetXOr functions for resilient code\nvar host = config.GetStringOr(cfg, \"server.host\", \"localhost\")\nvar port = config.GetIntOr(cfg, \"server.port\", 8080)\nvar debug = config.GetBoolOr(cfg, \"debug\", false)\n</code></pre>"},{"location":"stdlib/config/#4-handle-missing-keys-gracefully","title":"4. Handle Missing Keys Gracefully","text":"<pre><code>var optionalFeature = cfg.features.experimental\nif optionalFeature == None {\n    fmt.Println(\"Experimental features not configured\")\n} else {\n    // Use the feature\n}\n</code></pre>"},{"location":"stdlib/config/#5-use-environment-overlays-for-deployment","title":"5. Use Environment Overlays for Deployment","text":"<pre><code>// Development: use config file values\n// Production: override with environment variables\nvar cfg, _ = config.ReadFileWithEnv(\"config.yaml\", \"APP\")\n</code></pre>"},{"location":"stdlib/config/#error-handling","title":"Error Handling","text":"<p>The config module follows Harneet's error handling patterns:</p> <pre><code>// Pattern 1: Check error tuple\nvar cfg, err = config.ReadFile(\"config.yaml\")\nif err != None {\n    fmt.Printf(\"Failed to read config: %v\\n\", err)\n    return\n}\n\n// Pattern 2: Use defaults\nvar host = config.GetStringOr(cfg, \"server.host\", \"localhost\")\n\n// Pattern 3: Check for None\nvar optional = cfg.optional.feature\nif optional == None {\n    fmt.Println(\"Optional feature not configured\")\n}\n</code></pre>"},{"location":"stdlib/config/#type-inference","title":"Type Inference","text":"<p>The config module automatically infers types from values:</p> <ul> <li>Boolean: <code>true</code>, <code>false</code></li> <li>Integer: <code>42</code>, <code>8080</code>, <code>-100</code></li> <li>Float: <code>3.14</code>, <code>0.5</code></li> <li>String: Everything else</li> </ul> <pre><code>// CSV parsing with automatic type inference\nvar csvData = \"name,age,active\\nAlice,30,true\\nBob,25,false\"\nvar rows, _ = config.ParseCSV(csvData)\n\nvar firstRow = rows[0]\nvar age = firstRow.age      // Automatically inferred as integer (30)\nvar active = firstRow.active // Automatically inferred as boolean (true)\n</code></pre>"},{"location":"stdlib/config/#summary","title":"Summary","text":"<p>The <code>config</code> module provides a comprehensive, Viper-like configuration management system for Harneet:</p> <ul> <li>\u2705 Multiple formats: YAML, TOML, XML, CSV</li> <li>\u2705 Two access styles: Direct dot access and type-safe getters</li> <li>\u2705 Deep nesting: 5+ levels of nested structures</li> <li>\u2705 Type safety: Automatic type conversion and validation</li> <li>\u2705 Defaults: Built-in fallback support</li> <li>\u2705 Environment overlays: Seamless environment variable integration</li> <li>\u2705 Config merging: Combine multiple sources</li> <li>\u2705 Production-ready: Handles complex real-world configurations</li> </ul> <p>Perfect for building applications with flexible, maintainable configuration management!</p>"},{"location":"stdlib/datetime/","title":"<code>datetime</code> Module","text":"<p>The <code>datetime</code> module provides a comprehensive set of functions for date and time operations, including timezone support, timers, and cron-like scheduling.</p>"},{"location":"stdlib/datetime/#functions","title":"Functions","text":""},{"location":"stdlib/datetime/#now","title":"<code>Now()</code>","text":"<p>Returns the current Unix timestamp.</p> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The current Unix timestamp.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nfmt.Println(now)\n</code></pre>"},{"location":"stdlib/datetime/#formattimestamp-format","title":"<code>Format(timestamp, format)</code>","text":"<p>Formats a Unix timestamp into a string based on a layout.</p> <p>Parameters:</p> <ul> <li><code>timestamp</code>: An integer representing the Unix timestamp.</li> <li><code>format</code>: A string representing the layout. Supports <code>RFC3339</code>, or custom Go format strings.</li> </ul> <p>Returns:</p> <ul> <li><code>(string, error)</code>: The formatted time string.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nvar formatted, _ = datetime.Format(now, \"RFC3339\")\nfmt.Println(formatted)\n</code></pre>"},{"location":"stdlib/datetime/#sleepseconds","title":"<code>Sleep(seconds)</code>","text":"<p>Pauses the execution for a given number of seconds.</p> <p>Parameters:</p> <ul> <li><code>seconds</code>: An integer or float representing the number of seconds to sleep.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nfmt.Println(\"Sleeping for 2 seconds...\")\ndatetime.Sleep(2)\nfmt.Println(\"Awake!\")\n</code></pre>"},{"location":"stdlib/datetime/#year","title":"<code>year()</code>","text":"<p>Returns the year of the <code>datetime</code> object.</p> <pre><code>package main\nimport datetime\nimport fmt\n\n// Get the current date and time\nvar now,_ = datetime.Now()\nfmt.Println(now)\n// Get the year\nvar year, yearErr = datetime.Year(now)\nfmt.Println(\"Current Year:\", year) // Example: Current Year: 2025\n</code></pre>"},{"location":"stdlib/datetime/#monthtimestamps","title":"<code>Month(timestamps)</code>","text":"<p>Returns the month of a given Unix timestamp.</p> <p>Parameters:</p> <ul> <li><code>timestamp</code>: An integer representing the Unix timestamp.</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The month (1-12).</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nvar month, _ = datetime.Month(now)\nfmt.Println(\"Month:\", month)\n</code></pre>"},{"location":"stdlib/datetime/#daytimestamp","title":"<code>Day(timestamp)</code>","text":"<p>Returns the day of the month of a given Unix timestamp.</p> <p>Parameters:</p> <ul> <li><code>timestamp</code>: An integer representing the Unix timestamp.</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The day of the month (1-31).</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nvar day, _ = datetime.Day(now)\nfmt.Println(\"Day:\", day)\n</code></pre>"},{"location":"stdlib/datetime/#converttztimestamp-fromtz-totz","title":"<code>ConvertTZ(timestamp, fromTZ, toTZ)</code>","text":"<p>Converts a timestamp from one timezone to another.</p> <p>Parameters:</p> <ul> <li><code>timestamp</code>: An integer representing the Unix timestamp.</li> <li><code>fromTZ</code>: The source timezone (e.g., \"UTC\").</li> <li><code>toTZ</code>: The target timezone (e.g., \"America/New_York\").</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The converted Unix timestamp.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar nowUTC, _ = datetime.Now()\nvar nyTime, err = datetime.ConvertTZ(nowUTC, \"UTC\", \"America/New_York\")\nif err != None {\n    fmt.Println(\"Convert error:\", err)\n} else {\n    fmt.Println(\"NY timestamp:\", nyTime)\n}\n</code></pre>"},{"location":"stdlib/datetime/#nowintztimezone","title":"<code>NowInTZ(timezone)</code>","text":"<p>Returns the current time in a specific timezone.</p> <p>Parameters:</p> <ul> <li><code>timezone</code>: The timezone (e.g., \"America/New_York\").</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The current Unix timestamp in the specified timezone.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar tokyoNow, err = datetime.NowInTZ(\"Asia/Tokyo\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Tokyo now:\", tokyoNow)\n}\n</code></pre>"},{"location":"stdlib/datetime/#localtimelocale","title":"<code>LocalTime(locale)</code>","text":"<p>Returns the current time for a given locale.</p> <p>Parameters:</p> <ul> <li><code>locale</code>: A two-letter country code (e.g., \"US\", \"GB\").</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The current Unix timestamp in the locale's timezone.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar usNow, err = datetime.LocalTime(\"US\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"US local time:\", usNow)\n}\n</code></pre>"},{"location":"stdlib/datetime/#getsystemtz","title":"<code>GetSystemTZ()</code>","text":"<p>Returns the system's timezone name.</p> <p>Returns:</p> <ul> <li><code>(string, error)</code>: The system timezone.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar tz, _ = datetime.GetSystemTZ()\nfmt.Println(\"System TZ:\", tz)\n</code></pre>"},{"location":"stdlib/datetime/#gettzoffsettimezone","title":"<code>GetTZOffset(timezone)</code>","text":"<p>Returns the timezone offset in seconds from UTC.</p> <p>Parameters:</p> <ul> <li><code>timezone</code>: The timezone name.</li> </ul> <p>Returns:</p> <ul> <li><code>(integer, error)</code>: The offset in seconds.</li> </ul> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar offset, _ = datetime.GetTZOffset(\"America/New_York\")\nfmt.Println(\"NY offset (seconds):\", offset)\n</code></pre>"},{"location":"stdlib/datetime/#timers-and-tickers","title":"Timers and Tickers","text":""},{"location":"stdlib/datetime/#newtimerid-delay_seconds","title":"<code>NewTimer(id, delay_seconds)</code>","text":"<p>Creates a new timer that will fire after a delay.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.NewTimer(\"job1\", 2)\nfmt.Println(\"Timer scheduled for 2s\")\n</code></pre>"},{"location":"stdlib/datetime/#checktimerid","title":"<code>CheckTimer(id)</code>","text":"<p>Checks if a timer has fired.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar fired, _ = datetime.CheckTimer(\"job1\")\nfmt.Println(\"Timer fired:\", fired)\n</code></pre>"},{"location":"stdlib/datetime/#stoptimerid","title":"<code>StopTimer(id)</code>","text":"<p>Stops a timer.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.StopTimer(\"job1\")\nfmt.Println(\"Timer stopped\")\n</code></pre>"},{"location":"stdlib/datetime/#newtickerid-interval_seconds","title":"<code>NewTicker(id, interval_seconds)</code>","text":"<p>Creates a new ticker that fires at regular intervals.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.NewTicker(\"tick1\", 5)\nfmt.Println(\"Ticker 'tick1' every 5s started\")\n</code></pre>"},{"location":"stdlib/datetime/#stoptickerid","title":"<code>StopTicker(id)</code>","text":"<p>Stops a ticker.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.StopTicker(\"tick1\")\nfmt.Println(\"Ticker 'tick1' stopped\")\n</code></pre>"},{"location":"stdlib/datetime/#cron-scheduling","title":"Cron Scheduling","text":""},{"location":"stdlib/datetime/#isvalidcronexpression","title":"<code>IsValidCron(expression)</code>","text":"<p>Validates a cron expression.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar ok, _ = datetime.IsValidCron(\"0 0 * * *\")\nfmt.Println(\"Daily cron valid:\", ok)\n</code></pre>"},{"location":"stdlib/datetime/#nextcronexecutionexpression-timestamp","title":"<code>NextCronExecution(expression, timestamp)</code>","text":"<p>Calculates the next execution time of a cron expression.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar now, _ = datetime.Now()\nvar next, err = datetime.NextCronExecution(\"0 0 * * *\", now)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Next daily run:\", next)\n}\n</code></pre>"},{"location":"stdlib/datetime/#parsecronexpression","title":"<code>ParseCron(expression)</code>","text":"<p>Parses a cron expression.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar cron, err = datetime.ParseCron(\"*/15 * * * *\")\nif err != None {\n    fmt.Println(\"Parse error:\", err)\n} else {\n    fmt.Println(\"Cron job:\", cron)\n}\n</code></pre>"},{"location":"stdlib/datetime/#schedulecronid-expression","title":"<code>ScheduleCron(id, expression)</code>","text":"<p>Schedules a cron job.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.ScheduleCron(\"jobA\", \"0 * * * *\")\nfmt.Println(\"Scheduled hourly job 'jobA'\")\n</code></pre>"},{"location":"stdlib/datetime/#stopcronid","title":"<code>StopCron(id)</code>","text":"<p>Stops a scheduled cron job.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar _ = datetime.StopCron(\"jobA\")\nfmt.Println(\"Stopped job 'jobA'\")\n</code></pre>"},{"location":"stdlib/datetime/#listcronjobs","title":"<code>ListCronJobs()</code>","text":"<p>Lists all active cron jobs.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar jobs, _ = datetime.ListCronJobs()\nfmt.Println(\"Active cron jobs:\", jobs)\n</code></pre>"},{"location":"stdlib/datetime/#everyminute-hourly-daily-weekly-monthly","title":"<code>EveryMinute()</code>, <code>Hourly()</code>, <code>Daily()</code>, <code>Weekly()</code>, <code>Monthly()</code>","text":"<p>Returns common cron expressions.</p> <p>Example:</p> <pre><code>package main\nimport fmt\nimport datetime\n\nvar everyMinute, _ = datetime.EveryMinute()\nvar hourly, _ = datetime.Hourly()\nvar daily, _ = datetime.Daily()\nvar weekly, _ = datetime.Weekly()\nvar monthly, _ = datetime.Monthly()\n\nfmt.Println(everyMinute)\nfmt.Println(hourly)\nfmt.Println(daily)\nfmt.Println(weekly)\nfmt.Println(monthly)\n</code></pre>"},{"location":"stdlib/db/","title":"Database Module","text":"<p>The <code>db</code> module provides comprehensive SQL database connectivity with connection pooling, transaction support, and GORM-inspired ORM features. It supports SQLite3, PostgreSQL, and MySQL databases with SQLC-like query workflows.</p>"},{"location":"stdlib/db/#features","title":"Features","text":"<ul> <li>\u2705 Multiple Database Support: SQLite3, PostgreSQL, MySQL</li> <li>\u2705 Connection Pooling: Configurable pool size and connection lifetime</li> <li>\u2705 SQLC-style Queries: Type-safe query execution with parameter binding</li> <li>\u2705 Transaction Support: Manual and automatic transaction management</li> <li>\u2705 GORM-inspired ORM: Simple CRUD operations with map-based data</li> <li>\u2705 Map Integration: Results returned as Harneet maps</li> <li>\u2705 JSON Ready: Seamless JSON serialization of query results</li> </ul>"},{"location":"stdlib/db/#import","title":"Import","text":"<pre><code>import db\n</code></pre>"},{"location":"stdlib/db/#connection-management","title":"Connection Management","text":""},{"location":"stdlib/db/#opendriver-string-dsn-string-connection-error","title":"Open(driver string, dsn string) (connection, error)","text":"<p>Opens a database connection with the specified driver and data source name.</p> <p>Supported Drivers: - <code>sqlite3</code> - SQLite file-based database - <code>postgres</code> - PostgreSQL database - <code>mysql</code> - MySQL database</p> <p>Example:</p> <pre><code>import db\nimport fmt\n\n// SQLite3\nvar conn, err = db.Open(\"sqlite3\", \"myapp.db\")\n\n// PostgreSQL\nvar conn, err = db.Open(\"postgres\", \"host=localhost user=postgres password=secret dbname=mydb sslmode=disable\")\n\n// MySQL\nvar conn, err = db.Open(\"mysql\", \"user:password@tcp(localhost:3306)/dbname\")\n\nif err != None {\n    fmt.Printf(\"Connection failed: %v\\n\", err)\n    return\n}\n</code></pre>"},{"location":"stdlib/db/#closeconn-connection-error","title":"Close(conn connection) error","text":"<p>Closes the database connection and releases resources.</p> <pre><code>var err = db.Close(conn)\nif err != None {\n    fmt.Printf(\"Close error: %v\\n\", err)\n}\n</code></pre>"},{"location":"stdlib/db/#pingconn-connection-error","title":"Ping(conn connection) error","text":"<p>Verifies the database connection is alive.</p> <pre><code>var err = db.Ping(conn)\nif err != None {\n    fmt.Println(\"Database connection lost\")\n}\n</code></pre>"},{"location":"stdlib/db/#connection-pool-configuration","title":"Connection Pool Configuration","text":""},{"location":"stdlib/db/#setmaxopenconnsconn-connection-n-int-none","title":"SetMaxOpenConns(conn connection, n int) None","text":"<p>Sets the maximum number of open connections to the database.</p> <pre><code>db.SetMaxOpenConns(conn, 25)  // Max 25 connections\n</code></pre>"},{"location":"stdlib/db/#setmaxidleconnsconn-connection-n-int-none","title":"SetMaxIdleConns(conn connection, n int) None","text":"<p>Sets the maximum number of idle connections in the pool.</p> <pre><code>db.SetMaxIdleConns(conn, 5)  // Keep 5 idle connections\n</code></pre>"},{"location":"stdlib/db/#setconnmaxlifetimeconn-connection-seconds-int-none","title":"SetConnMaxLifetime(conn connection, seconds int) None","text":"<p>Sets the maximum lifetime of a connection in seconds.</p> <pre><code>db.SetConnMaxLifetime(conn, 300)  // 5 minutes max lifetime\n</code></pre>"},{"location":"stdlib/db/#query-execution-sqlc-style","title":"Query Execution (SQLC-style)","text":""},{"location":"stdlib/db/#queryconn-connection-sql-string-args-arraymap-error","title":"Query(conn connection, sql string, ...args) (array[map], error)","text":"<p>Executes a SQL query that returns multiple rows. Results are returned as an array of maps where each map represents a row.</p> <pre><code>// Query with no parameters\nvar users, err = db.Query(conn, \"SELECT * FROM users\")\n\n// Query with parameters (uses ? placeholders)\nvar adults, err = db.Query(conn, \"SELECT * FROM users WHERE age &gt;= ?\", 18)\n\n// Multiple parameters\nvar results, err = db.Query(conn, \n    \"SELECT * FROM users WHERE age &gt;= ? AND city = ?\", \n    18, \"New York\")\n\nif err == None {\n    for row in results {\n        fmt.Printf(\"ID: %d, Name: %s, Age: %d\\n\", \n            row[\"id\"], row[\"name\"], row[\"age\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/db/#queryrowconn-connection-sql-string-args-map-error","title":"QueryRow(conn connection, sql string, ...args) (map, error)","text":"<p>Executes a SQL query that returns a single row.</p> <pre><code>var user, err = db.QueryRow(conn, \"SELECT * FROM users WHERE id = ?\", 1)\nif err != None {\n    fmt.Println(\"User not found\")\n    return\n}\n\nfmt.Printf(\"User: %s, Email: %s\\n\", user[\"name\"], user[\"email\"])\n</code></pre>"},{"location":"stdlib/db/#execconn-connection-sql-string-args-result-error","title":"Exec(conn connection, sql string, ...args) (result, error)","text":"<p>Executes a SQL statement (INSERT, UPDATE, DELETE) that doesn't return rows.</p> <pre><code>// INSERT\nvar result, err = db.Exec(conn, \n    \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n    \"Alice\", \"alice@example.com\", 30)\n\n// UPDATE\nvar result, err = db.Exec(conn,\n    \"UPDATE users SET age = ? WHERE id = ?\",\n    31, 1)\n\n// DELETE\nvar result, err = db.Exec(conn,\n    \"DELETE FROM users WHERE age &lt; ?\",\n    18)\n</code></pre>"},{"location":"stdlib/db/#lastinsertidresult-int-error","title":"LastInsertId(result) (int, error)","text":"<p>Returns the last inserted ID from an INSERT operation.</p> <pre><code>var result, err = db.Exec(conn, \"INSERT INTO users (name) VALUES (?)\", \"Bob\")\nif err == None {\n    var id, _ = db.LastInsertId(result)\n    fmt.Printf(\"New user ID: %d\\n\", id)\n}\n</code></pre>"},{"location":"stdlib/db/#rowsaffectedresult-int-error","title":"RowsAffected(result) (int, error)","text":"<p>Returns the number of rows affected by an UPDATE or DELETE operation.</p> <pre><code>var result, err = db.Exec(conn, \"UPDATE users SET active = 1\")\nif err == None {\n    var count, _ = db.RowsAffected(result)\n    fmt.Printf(\"Updated %d users\\n\", count)\n}\n</code></pre>"},{"location":"stdlib/db/#transaction-support","title":"Transaction Support","text":""},{"location":"stdlib/db/#beginconn-connection-transaction-error","title":"Begin(conn connection) (transaction, error)","text":"<p>Starts a new database transaction.</p> <pre><code>var tx, err = db.Begin(conn)\nif err != None {\n    fmt.Println(\"Failed to start transaction\")\n    return\n}\n</code></pre>"},{"location":"stdlib/db/#committx-transaction-error","title":"Commit(tx transaction) error","text":"<p>Commits the current transaction.</p> <pre><code>var err = db.Commit(tx)\nif err != None {\n    fmt.Println(\"Commit failed\")\n}\n</code></pre>"},{"location":"stdlib/db/#rollbacktx-transaction-error","title":"Rollback(tx transaction) error","text":"<p>Rolls back the current transaction.</p> <pre><code>var err = db.Rollback(tx)\nif err != None {\n    fmt.Println(\"Rollback failed\")\n}\n</code></pre>"},{"location":"stdlib/db/#txquerytx-transaction-sql-string-args-arraymap-error","title":"TxQuery(tx transaction, sql string, ...args) (array[map], error)","text":"<p>Executes a query within a transaction.</p> <pre><code>var tx, _ = db.Begin(conn)\nvar users, err = db.TxQuery(tx, \"SELECT * FROM users WHERE age &gt; ?\", 18)\n</code></pre>"},{"location":"stdlib/db/#txexectx-transaction-sql-string-args-result-error","title":"TxExec(tx transaction, sql string, ...args) (result, error)","text":"<p>Executes a statement within a transaction.</p> <pre><code>var tx, _ = db.Begin(conn)\nvar result, err = db.TxExec(tx, \"INSERT INTO users (name) VALUES (?)\", \"Charlie\")\n</code></pre>"},{"location":"stdlib/db/#transaction-example","title":"Transaction Example","text":"<pre><code>import db\nimport fmt\n\nfunction transferMoney(conn, fromId int, toId int, amount int) error {\n    // Start transaction\n    var tx, err = db.Begin(conn)\n    if err != None {\n        return err\n    }\n\n    // Deduct from sender\n    var result1, err1 = db.TxExec(tx, \n        \"UPDATE accounts SET balance = balance - ? WHERE user_id = ?\",\n        amount, fromId)\n\n    // Add to receiver\n    var result2, err2 = db.TxExec(tx,\n        \"UPDATE accounts SET balance = balance + ? WHERE user_id = ?\",\n        amount, toId)\n\n    // Check if both succeeded\n    if err1 != None or err2 != None {\n        db.Rollback(tx)\n        fmt.Println(\"Transaction rolled back\")\n        return err1\n    }\n\n    // Commit transaction\n    var commitErr = db.Commit(tx)\n    if commitErr != None {\n        db.Rollback(tx)\n        return commitErr\n    }\n\n    fmt.Println(\"Transfer successful\")\n    return None\n}\n</code></pre>"},{"location":"stdlib/db/#orm-features-gorm-inspired","title":"ORM Features (GORM-inspired)","text":""},{"location":"stdlib/db/#createconn-connection-table-string-data-map-int-error","title":"Create(conn connection, table string, data map) (int, error)","text":"<p>Inserts a new record into the database. Returns the inserted ID.</p> <pre><code>var userData = {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"age\": 30\n}\n\nvar id, err = db.Create(conn, \"users\", userData)\nif err == None {\n    fmt.Printf(\"Created user with ID: %d\\n\", id)\n}\n</code></pre>"},{"location":"stdlib/db/#findconn-connection-table-string-conditions-map-arraymap-error","title":"Find(conn connection, table string, conditions map) (array[map], error)","text":"<p>Retrieves records from the database matching the conditions.</p> <pre><code>// Find all users aged 30\nvar users, err = db.Find(conn, \"users\", {\"age\": 30})\n\n// Find users in a specific city\nvar users, err = db.Find(conn, \"users\", {\"city\": \"New York\"})\n\n// Find with multiple conditions (AND)\nvar users, err = db.Find(conn, \"users\", {\"age\": 30, \"city\": \"New York\"})\n\nif err == None {\n    for user in users {\n        fmt.Printf(\"User: %s\\n\", user[\"name\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/db/#findoneconn-connection-table-string-conditions-map-map-error","title":"FindOne(conn connection, table string, conditions map) (map, error)","text":"<p>Retrieves a single record from the database.</p> <pre><code>var user, err = db.FindOne(conn, \"users\", {\"id\": 1})\nif err != None {\n    fmt.Println(\"User not found\")\n    return\n}\n\nfmt.Printf(\"Found: %s\\n\", user[\"name\"])\n</code></pre>"},{"location":"stdlib/db/#updateconn-connection-table-string-conditions-map-data-map-int-error","title":"Update(conn connection, table string, conditions map, data map) (int, error)","text":"<p>Updates records in the database. Returns the number of rows affected.</p> <pre><code>// Update specific user\nvar count, err = db.Update(conn, \"users\", \n    {\"id\": 1},\n    {\"age\": 31, \"city\": \"Boston\"})\n\n// Update multiple users\nvar count, err = db.Update(conn, \"users\",\n    {\"city\": \"New York\"},\n    {\"timezone\": \"EST\"})\n\nif err == None {\n    fmt.Printf(\"Updated %d records\\n\", count)\n}\n</code></pre>"},{"location":"stdlib/db/#deleteconn-connection-table-string-conditions-map-int-error","title":"Delete(conn connection, table string, conditions map) (int, error)","text":"<p>Deletes records from the database. Returns the number of rows deleted.</p> <p>Safety: Conditions map is required to prevent accidental deletion of all records.</p> <pre><code>// Delete specific user\nvar count, err = db.Delete(conn, \"users\", {\"id\": 1})\n\n// Delete multiple users\nvar count, err = db.Delete(conn, \"users\", {\"age\": 0})\n\nif err == None {\n    fmt.Printf(\"Deleted %d records\\n\", count)\n}\n</code></pre>"},{"location":"stdlib/db/#countconn-connection-table-string-conditions-map-int-error","title":"Count(conn connection, table string, conditions map) (int, error)","text":"<p>Counts records in the database matching the conditions.</p> <pre><code>// Count all users\nvar total, err = db.Count(conn, \"users\", {})\n\n// Count users with conditions\nvar adults, err = db.Count(conn, \"users\", {\"age\": 18})\n\nif err == None {\n    fmt.Printf(\"Found %d users\\n\", total)\n}\n</code></pre>"},{"location":"stdlib/db/#database-migrations","title":"Database Migrations","text":"<p>The database module includes comprehensive migration support with both up (apply) and down (rollback) capabilities, similar to Rails migrations or Flyway.</p>"},{"location":"stdlib/db/#migration-functions","title":"Migration Functions","text":""},{"location":"stdlib/db/#migrateupconn-connection-version-int-name-string-upsql-string-error","title":"MigrateUp(conn connection, version int, name string, upSQL string) error","text":"<p>Applies a migration to the database. Migrations are tracked in a <code>schema_migrations</code> table.</p> <pre><code>var err = db.MigrateUp(conn, 1, \"create_users_table\",\n    \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\")\n</code></pre>"},{"location":"stdlib/db/#migratedownconn-connection-version-int-downsql-string-error","title":"MigrateDown(conn connection, version int, downSQL string) error","text":"<p>Rolls back a migration. Only applies if the migration was previously applied.</p> <pre><code>var err = db.MigrateDown(conn, 1, \"DROP TABLE users\")\n</code></pre>"},{"location":"stdlib/db/#getmigrationversionconn-connection-int-error","title":"GetMigrationVersion(conn connection) (int, error)","text":"<p>Returns the current migration version number.</p> <pre><code>var version, err = db.GetMigrationVersion(conn)\nfmt.Printf(\"Current version: %d\\n\", version)\n</code></pre>"},{"location":"stdlib/db/#getmigrationhistoryconn-connection-arraymap-error","title":"GetMigrationHistory(conn connection) (array[map], error)","text":"<p>Returns all applied migrations with version, name, and timestamp.</p> <pre><code>var history, err = db.GetMigrationHistory(conn)\nfor migration in history {\n    fmt.Printf(\"v%d: %s (applied at: %d)\\n\", \n        migration[\"version\"], \n        migration[\"name\"],\n        migration[\"applied_at\"])\n}\n</code></pre>"},{"location":"stdlib/db/#migratetoversionconn-connection-targetversion-int-migrations-array-error","title":"MigrateToVersion(conn connection, targetVersion int, migrations array) error","text":"<p>Migrates to a specific version (up or down automatically). Migrations array should contain migration maps.</p> <pre><code>var migrations = [\n    {\n        \"version\": 1,\n        \"name\": \"create_users\",\n        \"up\": \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\",\n        \"down\": \"DROP TABLE users\"\n    },\n    {\n        \"version\": 2,\n        \"name\": \"add_users_email\",\n        \"up\": \"ALTER TABLE users ADD COLUMN email TEXT\",\n        \"down\": \"ALTER TABLE users DROP COLUMN email\"\n    }\n]\n\n// Migrate to version 2\nvar err = db.MigrateToVersion(conn, 2, migrations)\n\n// Rollback to version 1\nvar err = db.MigrateToVersion(conn, 1, migrations)\n</code></pre>"},{"location":"stdlib/db/#migration-example","title":"Migration Example","text":"<pre><code>import db\nimport fmt\n\nfunction main() {\n    var conn, _ = db.Open(\"sqlite3\", \"myapp.db\")\n\n    // Define migrations\n    var migrations = [\n        {\n            \"version\": 1,\n            \"name\": \"create_users_table\",\n            \"up\": \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL, email TEXT UNIQUE)\",\n            \"down\": \"DROP TABLE users\"\n        },\n        {\n            \"version\": 2,\n            \"name\": \"add_users_age\",\n            \"up\": \"ALTER TABLE users ADD COLUMN age INTEGER\",\n            \"down\": \"ALTER TABLE users DROP COLUMN age\"\n        },\n        {\n            \"version\": 3,\n            \"name\": \"create_posts_table\",\n            \"up\": \"CREATE TABLE posts (id INTEGER PRIMARY KEY, user_id INTEGER, title TEXT, content TEXT, FOREIGN KEY(user_id) REFERENCES users(id))\",\n            \"down\": \"DROP TABLE posts\"\n        }\n    ]\n\n    // Check current version\n    var currentVersion, _ = db.GetMigrationVersion(conn)\n    fmt.Printf(\"Current version: %d\\n\", currentVersion)\n\n    // Migrate to latest version\n    var err = db.MigrateToVersion(conn, 3, migrations)\n    if err != None {\n        fmt.Printf(\"Migration error: %v\\n\", err)\n        return\n    }\n\n    fmt.Println(\"Migrated to version 3\")\n\n    // Rollback to version 1\n    var downErr = db.MigrateToVersion(conn, 1, migrations)\n    if downErr != None {\n        fmt.Printf(\"Rollback error: %v\\n\", downErr)\n        return\n    }\n\n    fmt.Println(\"Rolled back to version 1\")\n\n    // View migration history\n    var history, _ = db.GetMigrationHistory(conn)\n    fmt.Println(\"Applied migrations:\")\n    for mig in history {\n        fmt.Printf(\"  v%d: %s\\n\", mig[\"version\"], mig[\"name\"])\n    }\n\n    db.Close(conn)\n}\n</code></pre>"},{"location":"stdlib/db/#file-based-migrations","title":"File-Based Migrations","text":"<p>Migrations can be stored in external files for better organization and version control.</p>"},{"location":"stdlib/db/#method-1-json-file","title":"Method 1: JSON File","text":"<p>Store all migrations in a single JSON file:</p> <p>migrations.json: <pre><code>[\n  {\n    \"version\": 1,\n    \"name\": \"create_users_table\",\n    \"up\": \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT NOT NULL)\",\n    \"down\": \"DROP TABLE users\"\n  },\n  {\n    \"version\": 2,\n    \"name\": \"add_users_email\",\n    \"up\": \"ALTER TABLE users ADD COLUMN email TEXT\",\n    \"down\": \"ALTER TABLE users DROP COLUMN email\"\n  }\n]\n</code></pre></p> <p>Load and apply: <pre><code>import db\nimport json\nimport file\n\nfunction loadMigrations(filepath string) array {\n    var content, err = file.ReadFile(filepath)\n    if err != None {\n        return []\n    }\n\n    var migrations, parseErr = json.Unmarshal(content)\n    if parseErr != None {\n        return []\n    }\n\n    return migrations\n}\n\nfunction main() {\n    var conn, _ = db.Open(\"sqlite3\", \"myapp.db\")\n\n    // Load migrations from JSON file\n    var migrations = loadMigrations(\"migrations.json\")\n\n    // Get current version\n    var currentVersion, _ = db.GetMigrationVersion(conn)\n\n    // Apply pending migrations\n    for migration in migrations {\n        if migration[\"version\"] &gt; currentVersion {\n            db.MigrateUp(conn, migration[\"version\"], \n                         migration[\"name\"], migration[\"up\"])\n        }\n    }\n\n    db.Close(conn)\n}\n</code></pre></p>"},{"location":"stdlib/db/#method-2-individual-sql-files","title":"Method 2: Individual SQL Files","text":"<p>Store each migration in a separate SQL file:</p> <p>migrations/001_create_users.sql: <pre><code>-- Migration: Create users table\n-- Version: 1\n-- Name: create_users_table\n\n-- UP\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL\n);\n\n-- DOWN\nDROP TABLE users;\n</code></pre></p> <p>migrations/002_add_age.sql: <pre><code>-- Migration: Add age column\n-- Version: 2\n-- Name: add_users_age\n\n-- UP\nALTER TABLE users ADD COLUMN age INTEGER;\n\n-- DOWN\nALTER TABLE users DROP COLUMN age;\n</code></pre></p> <p>Load and apply: <pre><code>import db\nimport file\nimport path\nimport strings\n\nfunction parseSQLFile(filepath string) map {\n    var content, _ = file.Read(filepath)\n    var lines = strings.Split(content, \"\\n\")\n\n    var version = 0\n    var name = \"\"\n    var upSQL = \"\"\n    var downSQL = \"\"\n    var inUpSection = false\n    var inDownSection = false\n\n    for line in lines {\n        var trimmed = strings.TrimSpace(line)\n\n        if strings.HasPrefix(trimmed, \"-- Version:\") {\n            var parts = strings.Split(trimmed, \":\")\n            if len(parts) == 2 {\n                version = cast.ToInt(strings.TrimSpace(parts[1]))\n            }\n        } else if strings.HasPrefix(trimmed, \"-- Name:\") {\n            var parts = strings.Split(trimmed, \":\")\n            if len(parts) == 2 {\n                name = strings.TrimSpace(parts[1])\n            }\n        } else if trimmed == \"-- UP\" {\n            inUpSection = true\n            inDownSection = false\n        } else if trimmed == \"-- DOWN\" {\n            inUpSection = false\n            inDownSection = true\n        } else if trimmed != \"\" &amp;&amp; !strings.HasPrefix(trimmed, \"--\") {\n            if inUpSection {\n                upSQL = upSQL + \" \" + trimmed\n            } else if inDownSection {\n                downSQL = downSQL + \" \" + trimmed\n            }\n        }\n    }\n\n    return {\n        \"version\": version,\n        \"name\": name,\n        \"up\": strings.TrimSpace(upSQL),\n        \"down\": strings.TrimSpace(downSQL)\n    }\n}\n\nfunction loadMigrationsFromDir(dirpath string) array {\n    var files, _ = path.Glob(dirpath + \"/*.sql\")\n    var migrations = []\n\n    for filepath in files {\n        var migration = parseSQLFile(filepath)\n        if migration[\"version\"] != 0 {\n            migrations = arrays.Append(migrations, migration)\n        }\n    }\n\n    return migrations\n}\n\nfunction main() {\n    var conn, _ = db.Open(\"sqlite3\", \"myapp.db\")\n\n    // Load all SQL migration files\n    var migrations = loadMigrationsFromDir(\"migrations\")\n\n    // Get current version\n    var currentVersion, _ = db.GetMigrationVersion(conn)\n\n    // Apply pending migrations\n    for migration in migrations {\n        if migration[\"version\"] &gt; currentVersion {\n            db.MigrateUp(conn, migration[\"version\"],\n                         migration[\"name\"], migration[\"up\"])\n        }\n    }\n\n    db.Close(conn)\n}\n</code></pre></p>"},{"location":"stdlib/db/#migration-best-practices","title":"Migration Best Practices","text":"<p>1. Always Define Both Up and Down <pre><code>var migration = {\n    \"version\": 1,\n    \"name\": \"add_column\",\n    \"up\": \"ALTER TABLE users ADD COLUMN phone TEXT\",\n    \"down\": \"ALTER TABLE users DROP COLUMN phone\"  // Always reversible\n}\n</code></pre></p> <p>2. Use Sequential Versioning <pre><code>// Good - sequential versions\nvar migrations = [\n    {\"version\": 1, ...},\n    {\"version\": 2, ...},\n    {\"version\": 3, ...}\n]\n</code></pre></p> <p>3. Test Migrations in Development <pre><code>// Apply migration\ndb.MigrateUp(conn, 1, \"create_table\", createSQL)\n\n// Test that it works\nvar users, _ = db.Query(conn, \"SELECT * FROM users\")\n\n// Test rollback\ndb.MigrateDown(conn, 1, dropSQL)\n</code></pre></p> <p>4. Keep Migrations Small and Focused <pre><code>// Good - one change per migration\n{\"version\": 1, \"name\": \"create_users_table\", ...}\n{\"version\": 2, \"name\": \"add_users_email\", ...}\n{\"version\": 3, \"name\": \"create_posts_table\", ...}\n</code></pre></p> <p>5. Version History is Automatic</p> <p>The module automatically tracks: - Which migrations have been applied - When they were applied - Current database version</p>"},{"location":"stdlib/db/#complete-example","title":"Complete Example","text":"<pre><code>import db\nimport fmt\n\nfunction main() {\n    // Open database\n    var conn, err = db.Open(\"sqlite3\", \"myapp.db\")\n    if err != None {\n        fmt.Printf(\"Error: %v\\n\", err)\n        return\n    }\n\n    // Configure connection pool\n    db.SetMaxOpenConns(conn, 25)\n    db.SetMaxIdleConns(conn, 5)\n    db.SetConnMaxLifetime(conn, 300)\n\n    // Create table\n    var _, createErr = db.Exec(conn, `\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            email TEXT UNIQUE NOT NULL,\n            age INTEGER\n        )\n    `)\n    if createErr != None {\n        fmt.Printf(\"Create table error: %v\\n\", createErr)\n        db.Close(conn)\n        return\n    }\n\n    // Insert data (ORM style)\n    var id, insertErr = db.Create(conn, \"users\", {\n        \"name\": \"Alice\",\n        \"email\": \"alice@example.com\",\n        \"age\": 30\n    })\n    fmt.Printf(\"Inserted user ID: %d\\n\", id)\n\n    // Query data (SQL style)\n    var users, queryErr = db.Query(conn, \"SELECT * FROM users WHERE age &gt;= ?\", 18)\n    if queryErr == None {\n        fmt.Println(\"Users:\")\n        for user in users {\n            fmt.Printf(\"  - %s (%d)\\n\", user[\"name\"], user[\"age\"])\n        }\n    }\n\n    // Update data (ORM style)\n    var updateCount, updateErr = db.Update(conn, \"users\",\n        {\"email\": \"alice@example.com\"},\n        {\"age\": 31})\n    fmt.Printf(\"Updated %d users\\n\", updateCount)\n\n    // Count records\n    var total, countErr = db.Count(conn, \"users\", {})\n    fmt.Printf(\"Total users: %d\\n\", total)\n\n    // Close connection\n    db.Close(conn)\n}\n</code></pre>"},{"location":"stdlib/db/#integration-with-other-modules","title":"Integration with Other Modules","text":""},{"location":"stdlib/db/#json-integration","title":"JSON Integration","text":"<pre><code>import db\nimport json\n\nvar users, _ = db.Query(conn, \"SELECT * FROM users\")\nvar jsonStr, _ = json.Marshal(users)\nfmt.Println(jsonStr)\n// Output: [{\"id\":1,\"name\":\"Alice\",\"age\":30},{\"id\":2,\"name\":\"Bob\",\"age\":25}]\n</code></pre>"},{"location":"stdlib/db/#map-integration","title":"Map Integration","text":"<pre><code>var user, _ = db.FindOne(conn, \"users\", {\"id\": 1})\n\n// Direct map access\nvar name = user[\"name\"]\nvar age = user[\"age\"]\n\n// Dot notation access\nvar email = user.email\n</code></pre>"},{"location":"stdlib/db/#error-handling","title":"Error Handling","text":"<p>The database module follows Harneet's error tuple pattern:</p> <pre><code>var conn, err = db.Open(\"sqlite3\", \"test.db\")\nif err != None {\n    fmt.Printf(\"Connection error: %v\\n\", err)\n    return\n}\n\nvar users, queryErr = db.Query(conn, \"SELECT * FROM users\")\nif queryErr != None {\n    fmt.Printf(\"Query error: %v\\n\", queryErr)\n    return\n}\n\n// Safe to use users\nfor user in users {\n    fmt.Println(user[\"name\"])\n}\n</code></pre>"},{"location":"stdlib/db/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/db/#1-always-close-connections","title":"1. Always Close Connections","text":"<pre><code>var conn, _ = db.Open(\"sqlite3\", \"app.db\")\n// ... use connection\ndb.Close(conn)\n</code></pre>"},{"location":"stdlib/db/#2-use-connection-pooling-for-production","title":"2. Use Connection Pooling for Production","text":"<pre><code>var conn, _ = db.Open(\"postgres\", dsn)\ndb.SetMaxOpenConns(conn, 25)\ndb.SetMaxIdleConns(conn, 5)\ndb.SetConnMaxLifetime(conn, 300)\n</code></pre>"},{"location":"stdlib/db/#3-use-transactions-for-multiple-operations","title":"3. Use Transactions for Multiple Operations","text":"<pre><code>var tx, _ = db.Begin(conn)\n// Execute multiple related operations\nvar _, err1 = db.TxExec(tx, \"INSERT ...\")\nvar _, err2 = db.TxExec(tx, \"UPDATE ...\")\n\nif err1 != None or err2 != None {\n    db.Rollback(tx)\n} else {\n    db.Commit(tx)\n}\n</code></pre>"},{"location":"stdlib/db/#4-use-parameterized-queries","title":"4. Use Parameterized Queries","text":"<pre><code>// \u2705 Good - prevents SQL injection\nvar users, _ = db.Query(conn, \"SELECT * FROM users WHERE id = ?\", userId)\n\n// \u274c Bad - vulnerable to SQL injection\nvar sql = \"SELECT * FROM users WHERE id = \" + userId\nvar users, _ = db.Query(conn, sql)\n</code></pre>"},{"location":"stdlib/db/#5-handle-errors-appropriately","title":"5. Handle Errors Appropriately","text":"<pre><code>var user, err = db.FindOne(conn, \"users\", {\"id\": 1})\nif err != None {\n    // Log error, return default, or propagate\n    fmt.Printf(\"Database error: %v\\n\", err)\n    return\n}\n</code></pre>"},{"location":"stdlib/db/#summary","title":"Summary","text":"<p>The <code>db</code> module provides enterprise-grade database functionality:</p> <ul> <li>\u2705 Multiple drivers: SQLite3, PostgreSQL, MySQL</li> <li>\u2705 Connection pooling: Production-ready connection management</li> <li>\u2705 SQLC-style queries: Type-safe parameter binding</li> <li>\u2705 Transaction support: ACID compliance with manual control</li> <li>\u2705 GORM-inspired ORM: Simple CRUD operations</li> <li>\u2705 Map-based results: Seamless Harneet integration</li> <li>\u2705 JSON ready: Direct serialization support</li> </ul> <p>Perfect for building web applications, APIs, and data-driven tools!</p>"},{"location":"stdlib/errors/","title":"<code>errors</code> Module","text":"<p>The <code>errors</code> module provides functions for creating error objects.</p>"},{"location":"stdlib/errors/#functions","title":"Functions","text":""},{"location":"stdlib/errors/#newmessage","title":"<code>New(message)</code>","text":"<p>Creates a new error with a given message.</p> <p>Parameters: - <code>message</code>: The error message.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example: <pre><code>package main\nimport fmt\nimport errors\n\nvar err, _ = errors.New(\"something went wrong\")\nfmt.Println(err)\n</code></pre></p>"},{"location":"stdlib/errors/#errorfformat-args","title":"<code>Errorf(format, args...)</code>","text":"<p>Creates a new error with a formatted error message.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example: <pre><code>package main\nimport fmt\nimport errors\n\nfunction divide(a, b) {\n    if b == 0 {\n        return None, errors.Errorf(\"division by zero: %d / %d\", a, b)\n    }\n    return a / b, None\n}\n\nvar result, err = divide(10, 0)\nif err != None {\n    fmt.Println(err)\n}\n</code></pre></p>"},{"location":"stdlib/exec/","title":"<code>exec</code> Module","text":"<p>The <code>exec</code> module allows Harneet programs to execute external commands in a controlled, cross-platform way. It returns stdout, stderr, exit code, and an error value.</p>"},{"location":"stdlib/exec/#functions","title":"Functions","text":""},{"location":"stdlib/exec/#runcommand-arg1-arg2","title":"<code>Run(command, arg1, arg2, ...)</code>","text":"<p>Executes the given program with arguments.</p> <p>Parameters: - <code>command</code>: Path or name of the executable. - <code>arg1, arg2, ...</code>: Arguments to pass to the command.</p> <p>Returns: - <code>(string, string, int, error)</code>: <code>(stdout, stderr, exitCode, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\nimport exec\n\nvar out, errOut, code, err = exec.Run(\"echo\", \"hello\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(\"stdout:\", out)\n    fmt.Println(\"stderr:\", errOut)\n    fmt.Println(\"exit:\", code)\n}\n</code></pre></p>"},{"location":"stdlib/exec/#runwithoptionscommand-args-env-cwd","title":"<code>RunWithOptions(command, args, env, cwd)</code>","text":"<p>Executes a program with explicit options.</p> <p>Arguments: - <code>command</code>: Path or name of the program to run. - <code>args</code>: Array of strings passed as arguments. - <code>env</code>: Array of strings in <code>KEY=VALUE</code> format. These are appended to the   current environment. - <code>cwd</code>: Working directory to run the command in. Use empty string to leave   unchanged.</p> <p>Returns: - <code>(string, string, int, error)</code>: <code>(stdout, stderr, exitCode, error)</code></p> <p>Example (Unix): <pre><code>package main\nimport fmt\nimport exec\nimport arrays\n\nvar a = arrays.New()\na.Push(\"-c\")\na.Push(\"echo hello-$MYVAR; pwd\")\n\nvar e = arrays.New()\ne.Push(\"MYVAR=world\")\n\nvar out, errOut, code, err =\n  exec.RunWithOptions(\"/bin/sh\", a, e, \"/tmp\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(\"stdout:\", out)\n    fmt.Println(\"stderr:\", errOut)\n    fmt.Println(\"exit:\", code)\n}\n</code></pre></p>"},{"location":"stdlib/exec/#shellcommand","title":"<code>Shell(command)</code>","text":"<p>Executes a command string using the system shell. - On Unix-like systems, this uses <code>/bin/sh -c</code>. - On Windows, this uses <code>cmd /C</code>.</p> <p>Parameters: - <code>command</code>: The full command string to execute.</p> <p>Returns: - <code>(string, string, int, error)</code>: <code>(stdout, stderr, exitCode, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\nimport exec\n\nvar out, errOut, code, err = exec.Shell(\"echo shell-works\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(\"stdout:\", out)\n    fmt.Println(\"stderr:\", errOut)\n    fmt.Println(\"exit:\", code)\n}\n</code></pre></p>"},{"location":"stdlib/exec/#process-spawning-and-ipc","title":"Process Spawning and IPC","text":"<p>The <code>exec</code> module also supports spawning long-lived processes and interacting with them via stdin/stdout/stderr.</p>"},{"location":"stdlib/exec/#functions_1","title":"Functions","text":"<ul> <li><code>exec.Command(cmd string, args array) (map, error)</code></li> <li><code>exec.Start(proc map) (int, error)</code> \u2014 returns pid</li> <li><code>exec.Wait(proc map) (int, error)</code> \u2014 returns exit code</li> <li><code>exec.Kill(proc map) (bool, error)</code></li> <li><code>exec.Write(proc map, data string) (int, error)</code> \u2014 write to stdin</li> <li><code>exec.CloseStdin(proc map) (bool, error)</code> \u2014 close stdin (signal EOF)</li> <li><code>exec.ReadStdout(proc map) (string, error)</code> \u2014 read all stdout (until EOF)</li> <li><code>exec.ReadStderr(proc map) (string, error)</code> \u2014 read all stderr (until EOF)</li> </ul>"},{"location":"stdlib/exec/#example-echo-via-cat","title":"Example: Echo via <code>cat</code>","text":"<pre><code>package main\nimport fmt\nimport exec\n\nfmt.Println(\"=== exec spawn + IPC demo ===\")\n\n// Prepare a process that echoes stdin to stdout\nvar proc, err = exec.Command(\"cat\", [])\nif err != None {\n    fmt.Println(\"Command error:\", err)\n} else {\n    var pid, startErr = exec.Start(proc)\n    if startErr != None {\n        fmt.Println(\"Start error:\", startErr)\n    } else {\n        // Write a couple of lines and close stdin to signal EOF\n        var _, w1 = exec.Write(proc, \"alpha\\n\")\n        var _, w2 = exec.Write(proc, \"beta\\n\")\n        var _, cErr = exec.CloseStdin(proc)\n        if w1 != None { fmt.Println(\"write1 error:\", w1) }\n        if w2 != None { fmt.Println(\"write2 error:\", w2) }\n        if cErr != None { fmt.Println(\"close stdin error:\", cErr) }\n\n        // Read stdout fully, then wait for exit\n        var out, rErr = exec.ReadStdout(proc)\n        var code, wErr = exec.Wait(proc)\n\n        fmt.Println(\"pid:\", pid, \"exit:\", code)\n        if rErr == None { fmt.Println(\"stdout:\\n\" + out) } else { fmt.Println(\"read stdout error:\", rErr) }\n        if wErr != None { fmt.Println(\"wait error:\", wErr) }\n    }\n}\n\nfmt.Println(\"\u2705 spawn + IPC demo complete\")\n</code></pre>"},{"location":"stdlib/file/","title":"<code>file</code> Module","text":"<p>The <code>file</code> module provides functions for interacting with the file system.</p>"},{"location":"stdlib/file/#functions","title":"Functions","text":""},{"location":"stdlib/file/#readfilename","title":"<code>Read(filename)</code>","text":"<p>Reads the entire content of a file.</p> <p>Parameters: - <code>filename</code>: The name of the file to read.</p> <p>Returns: - <code>(string, error)</code>: The content of the file.</p> <p>Example: <pre><code>package main\nimport fmt\nimport file\n\nvar content, err = file.Read(\"test.txt\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(content)\n}\n</code></pre></p>"},{"location":"stdlib/file/#movesrc-dest","title":"<code>Move(src, dest)</code>","text":"<p>Renames (moves) a file from <code>src</code> to <code>dest</code>.</p> <p>Parameters: - <code>src</code>: Source file path. - <code>dest</code>: Destination file path.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nvar _, err = file.Move(\"/tmp/a.txt\", \"/tmp/b.txt\")\n</code></pre></p>"},{"location":"stdlib/file/#removepath","title":"<code>Remove(path)</code>","text":"<p>Deletes the named file.</p> <p>Parameters: - <code>path</code>: File path to remove.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nvar _, err = file.Remove(\"/tmp/old.log\")\n</code></pre></p>"},{"location":"stdlib/file/#existspath","title":"<code>Exists(path)</code>","text":"<p>Reports whether a file or directory exists.</p> <p>Parameters: - <code>path</code>: Path to check.</p> <p>Returns: - <code>(boolean, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\nimport file\n\nvar ok, err = file.Exists(\"/tmp/data.txt\")\nif err == None { fmt.Println(ok) }\n</code></pre></p>"},{"location":"stdlib/file/#touchpath","title":"<code>Touch(path)</code>","text":"<p>Creates the file if it does not exist, or updates its modification time if it does.</p> <p>Parameters: - <code>path</code>: File path to touch.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nvar _, err = file.Touch(\"/tmp/heartbeat\")\n</code></pre></p>"},{"location":"stdlib/file/#chmodpath-mode","title":"<code>Chmod(path, mode)</code>","text":"<p>Changes the mode of the named file.</p> <p>Parameters: - <code>path</code>: File path. - <code>mode</code>: Integer mode (e.g., 420 for 0644).</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nvar _, err = file.Chmod(\"/tmp/config.ini\", 420) // 0644\n</code></pre></p>"},{"location":"stdlib/file/#listrichpath","title":"<code>ListRich(path)</code>","text":"<p>Lists directory entries and returns an array of tuples <code>(name string, isDir boolean, size int, modTime string)</code> where <code>modTime</code> is RFC3339 UTC.</p> <p>Parameters: - <code>path</code>: Directory path.</p> <p>Returns: - <code>(array, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\nimport file\n\nvar entries, err = file.ListRich(\"/tmp\")\nif err == None { fmt.Println(entries) }\n</code></pre></p>"},{"location":"stdlib/file/#writefilename-content","title":"<code>Write(filename, content)</code>","text":"<p>Writes content to a file. If the file does not exist, it will be created. If it exists, its contents will be overwritten.</p> <p>Parameters: - <code>filename</code>: The name of the file to write to. - <code>content</code>: The content to write.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nfile.Write(\"test.txt\", \"Hello, Harneet!\")\n</code></pre></p>"},{"location":"stdlib/file/#appendfilename-content","title":"<code>Append(filename, content)</code>","text":"<p>Appends content to a file. If the file does not exist, it will be created.</p> <p>Parameters: - <code>filename</code>: The name of the file to append to. - <code>content</code>: The content to append.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\n\nfile.Append(\"test.txt\", \"\\nAnother line.\")\n</code></pre></p>"},{"location":"stdlib/file/#copysrc-dest","title":"<code>Copy(src, dest)</code>","text":"<p>Copies a file from a source path to a destination path.</p> <p>Parameters: - <code>src</code>: The source file path. - <code>dest</code>: The destination file path.</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#sizefilename","title":"<code>Size(filename)</code>","text":"<p>Returns the size of a file in bytes.</p> <p>Parameters: - <code>filename</code>: The name of the file.</p> <p>Returns: - <code>(integer, error)</code>: The size of the file in bytes.</p>"},{"location":"stdlib/file/#readlinesfilename","title":"<code>ReadLines(filename)</code>","text":"<p>Reads all lines from a text file and returns them as an array of strings.</p> <p>Parameters: - <code>filename</code>: The file to read.</p> <p>Returns: - <code>(array, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\nimport file\n\nvar lines, err = file.ReadLines(\"notes.txt\")\nif err == None {\n    fmt.Println(lines)\n}\n</code></pre></p>"},{"location":"stdlib/file/#writelinesfilename-lines","title":"<code>WriteLines(filename, lines)</code>","text":"<p>Writes an array of strings to a text file, each string on a new line.</p> <p>Parameters: - <code>filename</code>: The file to write to. - <code>lines</code>: Array of strings.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport file\nimport fmt\n\nvar _, err = file.WriteLines(\"notes.txt\", [\"line 1\", \"line 2\", \"line 3\"])\nif err != None { fmt.Println(\"write error:\", err) }\n</code></pre></p>"},{"location":"stdlib/file/#createpath","title":"<code>Create(path)</code>","text":"<p>Creates an empty file at <code>path</code> (truncates if it exists).</p> <p>Parameters: - <code>path</code>: File path</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#isfilepath","title":"<code>IsFile(path)</code>","text":"<p>Reports whether the given path refers to a regular file.</p> <p>Parameters: - <code>path</code>: Path to check</p> <p>Returns: - <code>(boolean, error)</code></p>"},{"location":"stdlib/file/#deletepath","title":"<code>Delete(path)</code>","text":"<p>Deletes the named file or an empty directory.</p> <p>Parameters: - <code>path</code>: Path to delete</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#tempfilepattern","title":"<code>TempFile(pattern)</code>","text":"<p>Creates a new temporary file in the default temp directory and returns its path.</p> <p>If <code>pattern</code> is empty, a default like <code>harneet-*</code> is used.</p> <p>Parameters: - <code>pattern</code>: Name pattern for the temp file (may include <code>*</code>)</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>package main\nimport file\nimport fmt\n\nvar p, err = file.TempFile(\"mytmp-*\")\nif err == None { fmt.Println(\"temp file:\", p) }\n</code></pre></p>"},{"location":"stdlib/file/#tempdirpattern","title":"<code>TempDir(pattern)</code>","text":"<p>Creates a new temporary directory in the default temp directory and returns its path.</p> <p>If <code>pattern</code> is empty, a default like <code>harneet-*</code> is used.</p> <p>Parameters: - <code>pattern</code>: Name pattern for the temp directory (may include <code>*</code>)</p> <p>Returns: - <code>(string, error)</code></p>"},{"location":"stdlib/file/#createdirallpath","title":"<code>CreateDirAll(path)</code>","text":"<p>Creates a directory named <code>path</code>, along with any necessary parents (no-op if it already exists).</p> <p>Parameters: - <code>path</code>: Directory path</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#removeallpath","title":"<code>RemoveAll(path)</code>","text":"<p>Removes <code>path</code> and any children it contains (files or directories).</p> <p>Parameters: - <code>path</code>: Path to remove recursively</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#isemptypath","title":"<code>IsEmpty(path)</code>","text":"<p>Checks if a directory at <code>path</code> is empty.</p> <p>Parameters: - <code>path</code>: Directory path</p> <p>Returns: - <code>(boolean, error)</code></p>"},{"location":"stdlib/file/#getallfilespath-recursive-filetype-gethidden-ignoredirectories","title":"<code>GetAllFiles(path, recursive, fileType, getHidden[, ignoreDirectories])</code>","text":"<p>Gets all files inside a directory with optional recursion and filtering.</p> <p>Parameters: - <code>path</code>: Directory to scan - <code>recursive</code>: If <code>true</code>, walk subdirectories - <code>fileType</code>: Extension(s) to include. Accepts <code>\"txt\"</code>, <code>\".txt\"</code>, or comma-separated like <code>\"txt,log\"</code>. Use <code>\"\"</code> or <code>\"*\"</code> for all. - <code>getHidden</code>: If <code>true</code>, include dotfiles - <code>ignoreDirectories</code> (optional): Array of directory names or full paths to skip</p> <p>Returns: - <code>(array, error)</code> \u2014 Array of file paths</p> <p>Example: <pre><code>package main\nimport file\nimport fmt\n\n// All .ha files under ./examples, recursively, including hidden, ignoring vendor\nvar files, err = file.GetAllFiles(\"examples\", true, \"ha\", true, [\"vendor\"])\nif err == None { fmt.Println(files) }\n</code></pre></p>"},{"location":"stdlib/file/#openpath-mode","title":"<code>Open(path, mode)</code>","text":"<p>Opens a file and returns a handle object for granular operations.</p> <p>Supported modes: <code>\"r\"</code>, <code>\"w\"</code>, <code>\"a\"</code>, <code>\"c\"</code> (create-only, fail if exists), <code>\"rw\"</code>/<code>\"r+\"</code>, <code>\"w+\"</code>, <code>\"a+\"</code>.</p> <p>Parameters: - <code>path</code>: File path - <code>mode</code>: Open mode</p> <p>Returns: - <code>(object, error)</code> \u2014 file handle object</p> <p>Example: <pre><code>import file\nimport fmt\n\nvar h, err = file.Open(\"log.txt\", \"a+\")\nif err == None {\n    var _, _ = file.WriteTo(h, \"hello\\n\")\n    var _, _ = file.Close(h)\n}\n</code></pre></p>"},{"location":"stdlib/file/#closehandle","title":"<code>Close(handle)</code>","text":"<p>Closes an open file handle.</p> <p>Parameters: - <code>handle</code>: File handle returned by <code>file.Open</code></p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/file/#readfromhandle-n","title":"<code>ReadFrom(handle, n)</code>","text":"<p>Reads up to <code>n</code> bytes from a file handle and returns a string. If <code>n &lt; 0</code>, reads all remaining bytes from the current offset.</p> <p>Parameters: - <code>handle</code>: File handle - <code>n</code>: Number of bytes to read (use <code>-1</code> for all remaining)</p> <p>Returns: - <code>(string, error)</code></p>"},{"location":"stdlib/file/#writetohandle-data","title":"<code>WriteTo(handle, data)</code>","text":"<p>Writes the provided string to a file handle and returns the number of bytes written.</p> <p>Parameters: - <code>handle</code>: File handle - <code>data</code>: String to write</p> <p>Returns: - <code>(int, error)</code></p>"},{"location":"stdlib/file/#seekhandle-offset-whence","title":"<code>Seek(handle, offset, whence)</code>","text":"<p>Sets the offset for the next read or write on the file handle and returns the new offset.</p> <p><code>whence</code>: <code>0</code> (start), <code>1</code> (current), <code>2</code> (end)</p> <p>Parameters: - <code>handle</code>: File handle - <code>offset</code>: Byte offset - <code>whence</code>: Seek reference point (0/1/2)</p> <p>Returns: - <code>(int, error)</code> \u2014 New offset</p>"},{"location":"stdlib/file/#walkroot","title":"<code>Walk(root)</code>","text":"<p>Traverses a directory tree rooted at <code>root</code> and returns an array of tuples <code>(path string, isDir boolean, size int, modTime string)</code> where <code>modTime</code> is RFC3339 UTC.</p> <p>Parameters: - <code>root</code>: Root directory path to walk</p> <p>Returns: - <code>(array, error)</code></p> <p>Example: <pre><code>import file\nimport fmt\n\nvar entries, err = file.Walk(\".\")\nif err == None {\n    for e in entries {\n        var p, isDir, size, mt = e\n        fmt.Println(p, isDir, size, mt)\n    }\n}\n</code></pre></p>"},{"location":"stdlib/flags/","title":"<code>flags</code> Module","text":"<p>The <code>flags</code> module provides a simple command/flag system for Harneet programs.</p> <ul> <li>Nested commands (e.g., <code>tool user add</code>)</li> <li>Per-command flags with optional short aliases</li> <li>Global flags that are available to all commands</li> <li>Interleaved command selection (commands can appear anywhere in argv)</li> <li>Ancestor-chain flag lookup (current \u2192 parent \u2192 \u2026 \u2192 global)</li> <li>Unknown flags produce errors (e.g., <code>unknown flag: --foo</code>)</li> <li><code>--</code> terminator makes the rest positional</li> </ul>"},{"location":"stdlib/flags/#quick-start","title":"Quick Start","text":"<pre><code>package main\nimport flags, fmt\n\n// Define commands\nflags.Command(\"tool\", \"Top-level tool\")\nflags.Subcommand(\"tool\", \"user\", \"User management\", \"u\")\nflags.Subcommand(\"user\", \"add\", \"Add a user\", \"a\")\n\n// Define flags\nflags.String(\"config\", \"app.yaml\", \"Config file\", \"c\")     // global\nflags.String(\"name\", \"\", \"User name\", \"n\")                 // for current command\nflags.Bool(\"admin\", false, \"Admin user\", \"A\")              // for current command\n\n// Simulated argv (no program name)\nvar argv = [\"tool\", \"user\", \"add\", \"--name=bob\", \"-A\", \"pos1\", \"pos2\"]\nflags.Parse(argv)\n\nvar sel, _ = flags.Selected()                // [\"tool\",\"user\",\"add\"]\nvar name, _ = flags.GetString(\"name\")       // \"bob\"\nvar admin, _ = flags.GetBool(\"admin\")       // true\nvar cfg, _ = flags.GetString(\"config\")      // \"app.yaml\"\nvar rest, _ = flags.Args()                   // [\"pos1\",\"pos2\"]\n\nfmt.Println(sel, name, admin, cfg, rest)\n</code></pre>"},{"location":"stdlib/flags/#api","title":"API","text":"<ul> <li><code>flags.Command(name, usage [, alias])</code> \u2013 Define a top-level command.</li> <li><code>flags.Subcommand(parent, name, usage [, alias])</code> \u2013 Define a nested command.</li> <li><code>flags.String(name, default, usage [, alias])</code> \u2013 Define a string flag.</li> <li><code>flags.Bool(name, default, usage [, alias])</code> \u2013 Define a boolean flag.</li> <li><code>flags.Int(name, default, usage [, alias])</code> \u2013 Define an integer flag.</li> <li><code>flags.Parse(argv array)</code> \u2013 Parse args. Commands can be interleaved with   flags; the command path is resolved respecting parent relationships.</li> <li><code>flags.Selected()</code> \u2013 Returns the selected command path as an array.</li> <li><code>flags.Args()</code> \u2013 Returns positional arguments for the selected command.</li> <li><code>flags.GetString/Bool/Int(name)</code> \u2013 Get parsed values. Lookup order is   current command, then parent(s), then global.</li> <li><code>flags.Reset()</code> \u2013 Reset all definitions and parsed values (handy for tests).</li> </ul>"},{"location":"stdlib/flags/#dispatch-return-dispatch-pattern","title":"Dispatch (Return-Dispatch pattern)","text":"<ul> <li><code>flags.Handle(path array[string], tag any)</code> \u2013 Register a handler tag for a   command path. The tag is any value your program can switch on.</li> <li><code>flags.Run(argv array)</code> \u2013 Parse and return <code>(selectedPath array, args array,   handlerTag any, error)</code>. Your program performs the call based on <code>handlerTag</code>.</li> </ul>"},{"location":"stdlib/flags/#usage-patterns","title":"Usage Patterns","text":"<ul> <li> <p>Define your command tree upfront, then declare flags for the current context.   Global flags are declared at the global context (no current command selected).</p> </li> <li> <p>Populate <code>argv</code> from your environment if needed (e.g., a future <code>os.Args()</code>);   for now our examples manually create <code>argv</code> arrays.</p> </li> <li> <p>Short alias flags support <code>-x value</code> and <code>-x=value</code> forms. Booleans support   <code>--bool</code> (sets true) and <code>--bool=false</code>.</p> </li> </ul>"},{"location":"stdlib/flags/#examples","title":"Examples","text":"<p>See <code>examples/flags/</code>: - <code>nested_commands_basic.ha</code> \u2013 Command path selection and command-local flags - <code>alias_and_fallback.ha</code> \u2013 Short aliases and fallback to global flags - <code>dispatch_demo.ha</code> \u2013 Register tags with <code>flags.Handle</code>, parse with   <code>flags.Run</code>, then dispatch in user code</p>"},{"location":"stdlib/fmt/","title":"<code>fmt</code> Module","text":"<p>The <code>fmt</code> module provides functions for formatting and printing output to the console.</p>"},{"location":"stdlib/fmt/#functions","title":"Functions","text":""},{"location":"stdlib/fmt/#printlnargs","title":"<code>Println(args...)</code>","text":"<p>Prints the given arguments to the console, followed by a newline character.</p> <p>Parameters: - <code>args...</code>: A variable number of arguments of any type.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Example: <pre><code>package main\nimport fmt\n\nfmt.Println(\"Hello, World!\")\nvar x = 42\nfmt.Println(\"The value of x is:\", x)\n</code></pre></p>"},{"location":"stdlib/fmt/#printargs","title":"<code>Print(args...)</code>","text":"<p>Prints the given arguments to the console without a newline character at the end.</p> <p>Parameters: - <code>args...</code>: A variable number of arguments of any type.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Example: <pre><code>package main\nimport fmt\n\nfmt.Print(\"Hello, \")\nfmt.Print(\"World!\")\n// Output: Hello, World!\n</code></pre></p>"},{"location":"stdlib/fmt/#printfformat-args","title":"<code>Printf(format, args...)</code>","text":"<p>Prints formatted output to the console. It uses a format string and a variable number of arguments.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(None, error)</code>: This function does not return a value, but it follows the standard error handling pattern.</p> <p>Format Specifiers: - <code>%v</code>: The default format for the value. - <code>%s</code>: A string. - <code>%d</code>: A decimal integer. - <code>%f</code>: A floating-point number.</p> <p>Example: <pre><code>package main\nimport fmt\n\nvar name = \"Alice\"\nvar age = 30\nfmt.Printf(\"Name: %s, Age: %d\", name, age)\n</code></pre></p>"},{"location":"stdlib/fmt/#errorfformat-args","title":"<code>Errorf(format, args...)</code>","text":"<p>Creates a new error with a formatted error message.</p> <p>Parameters: - <code>format</code>: A string that contains format specifiers. - <code>args...</code>: The arguments to be formatted.</p> <p>Returns: - <code>(error, None)</code>: A new error object.</p> <p>Example: <pre><code>package main\nimport fmt\nimport errors\n\nfunction divide(a, b) {\n    if b == 0 {\n        return None, errors.Errorf(\"division by zero: %d / %d\", a, b)\n    }\n    return a / b, None\n}\n\nvar result, err = divide(10, 0)\nif err != None {\n    fmt.Println(err)\n}\n</code></pre></p>"},{"location":"stdlib/fmt/#sprintargs","title":"<code>Sprint(args...)</code>","text":"<p>Builds and returns a string by concatenating the default format of each argument separated by spaces. No trailing newline.</p> <p>Parameters: - <code>args...</code>: Arguments to concatenate.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar s, err = fmt.Sprint(\"alpha\", 123, true)\nif err == None {\n    fmt.Println(\"Sprint:\", s)\n}\n</code></pre></p>"},{"location":"stdlib/fmt/#sprintlnargs","title":"<code>Sprintln(args...)</code>","text":"<p>Like <code>Sprint</code> but appends a trailing newline to the result.</p> <p>Parameters: - <code>args...</code>: Arguments to concatenate.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar line, err = fmt.Sprintln(\"line\", 456)\nif err == None {\n    // Print to show the raw value (includes newline)\n    fmt.Print(line)\n}\n</code></pre></p>"},{"location":"stdlib/fmt/#sprintfformat-args","title":"<code>Sprintf(format, args...)</code>","text":"<p>Formats according to a format specifier and returns the resulting string.</p> <p>Parameters: - <code>format</code>: Format string (supports <code>%s</code>, <code>%d</code>, <code>%f</code>, <code>%t</code>, <code>%v</code>, <code>%+v</code>, <code>%#v</code>, <code>%T</code>). - <code>args...</code>: Arguments to format.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar s, err = fmt.Sprintf(\"name=%s id=%d ok=%t\", \"bob\", 7, true)\nif err == None {\n    fmt.Println(\"Sprintf:\", s)\n}\n</code></pre></p>"},{"location":"stdlib/fmt/#stdout-and-stderr","title":"<code>Stdout()</code> and <code>Stderr()</code>","text":"<p>Return handles that represent standard output and standard error. These handles can be used with <code>Fprint</code>, <code>Fprintln</code>, and <code>Fprintf</code>.</p> <p>Returns: - <code>(any, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar out, outErr = fmt.Stdout()\nif outErr == None {\n    var _, e1 = fmt.Fprintln(out, \"hello stdout\")\n}\n\nvar errOut, errOutErr = fmt.Stderr()\nif errOutErr == None {\n    var _, e2 = fmt.Fprintln(errOut, \"hello stderr\")\n}\n</code></pre></p>"},{"location":"stdlib/fmt/#fprintw-args","title":"<code>Fprint(w, args...)</code>","text":"<p>Writes arguments to the given writer handle without a trailing newline.</p> <p>Parameters: - <code>w</code>: Writer handle (use <code>fmt.Stdout()</code> or <code>fmt.Stderr()</code>). - <code>args...</code>: Values to write.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar out, _ = fmt.Stdout()\nvar _, err = fmt.Fprint(out, \"Fprint \", 123, \" ok\")\n</code></pre></p>"},{"location":"stdlib/fmt/#fprintlnw-args","title":"<code>Fprintln(w, args...)</code>","text":"<p>Writes arguments to the writer followed by a newline.</p> <p>Parameters: - <code>w</code>: Writer handle. - <code>args...</code>: Values to write.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar out, _ = fmt.Stdout()\nvar _, err = fmt.Fprintln(out, \"Fprintln line\")\n</code></pre></p>"},{"location":"stdlib/fmt/#fprintfw-format-args","title":"<code>Fprintf(w, format, args...)</code>","text":"<p>Formats according to a format specifier and writes to the writer.</p> <p>Parameters: - <code>w</code>: Writer handle. - <code>format</code>: Format string. - <code>args...</code>: Arguments to format.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>package main\nimport fmt\n\nvar out, _ = fmt.Stdout()\nvar _, err = fmt.Fprintf(out, \"id=%d ok=%t\\n\", 42, true)\n</code></pre></p>"},{"location":"stdlib/fmt/#scan","title":"<code>Scan()</code>","text":"<p>Reads a line from standard input and splits it by whitespace into fields.</p> <p>Returns: - <code>(array, error)</code></p>"},{"location":"stdlib/fmt/#scanln","title":"<code>Scanln()</code>","text":"<p>Reads a line from standard input and returns it as a string (without trailing newline).</p> <p>Returns: - <code>(string, error)</code></p>"},{"location":"stdlib/fmt/#scanfformat","title":"<code>Scanf(format)</code>","text":"<p>Reads a line from standard input and parses it according to the format string. Supported verbs: <code>%s</code>, <code>%d</code>, <code>%f</code>, <code>%t</code>.</p> <p>Parameters: - <code>format</code>: Format string.</p> <p>Returns: - <code>(array, error)</code></p> <p>Note: The <code>Scan*</code> functions block waiting for input. Use them interactively or in dedicated examples.</p>"},{"location":"stdlib/input/","title":"<code>input</code> Module","text":"<p>The <code>input</code> module provides buffered console input utilities (built on Go's <code>bufio</code> over <code>os.Stdin</code>). All functions follow Harneet's convention of returning <code>(result, error)</code> tuples.</p> <p>When an input parse fails (e.g., invalid integer), the function returns <code>(None, error)</code> with a helpful message.</p>"},{"location":"stdlib/input/#functions","title":"Functions","text":""},{"location":"stdlib/input/#readline","title":"<code>ReadLine()</code>","text":"<p>Reads a single line from standard input and returns it without the trailing newline.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(string, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter a line:\")\nvar line, err = input.ReadLine()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"You entered:\", line)\n}\n</code></pre></p>"},{"location":"stdlib/input/#readword","title":"<code>ReadWord()</code>","text":"<p>Reads the first whitespace-delimited token from the next line of input.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(string, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter some words:\")\nvar w, err = input.ReadWord()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"First word:\", w)\n}\n</code></pre></p>"},{"location":"stdlib/input/#readwords","title":"<code>ReadWords()</code>","text":"<p>Reads a line from standard input and splits it into whitespace-delimited tokens.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(array, error)</code> (array of strings)</li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter some words:\")\nvar words, err = input.ReadWords()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Words:\", words)\n}\n</code></pre></p>"},{"location":"stdlib/input/#readint","title":"<code>ReadInt()</code>","text":"<p>Reads a line and parses it as a base-10 integer.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(int, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter an integer:\")\nvar iv, err = input.ReadInt()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"You entered:\", iv)\n}\n</code></pre></p>"},{"location":"stdlib/input/#readfloat","title":"<code>ReadFloat()</code>","text":"<p>Reads a line and parses it as a float64.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(float64, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter a float:\")\nvar fv, err = input.ReadFloat()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"You entered:\", fv)\n}\n</code></pre></p>"},{"location":"stdlib/input/#readbool","title":"<code>ReadBool()</code>","text":"<p>Reads a line and parses it as a boolean. Accepted values (case-insensitive): <code>true</code>, <code>t</code>, <code>1</code>, <code>yes</code>, <code>y</code>, <code>false</code>, <code>f</code>, <code>0</code>, <code>no</code>, <code>n</code>.</p> <ul> <li>Parameters: none</li> <li>Returns: <code>(bool, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nfmt.Println(\"Enter a boolean (true/false, yes/no, 1/0):\")\nvar bv, err = input.ReadBool()\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"You entered:\", bv)\n}\n</code></pre></p>"},{"location":"stdlib/input/#promptmessage-string","title":"<code>Prompt(message string)</code>","text":"<p>Prints a prompt message to stdout and reads a single line from standard input.</p> <ul> <li>Parameters:</li> <li><code>message</code> (string): prompt to display before reading input</li> <li>Returns: <code>(string, error)</code></li> </ul> <p>Example: <pre><code>import input, fmt\n\nvar name, err1 = input.Prompt(\"Name: \")\nif err1 != None {\n    fmt.Println(\"Error:\", err1)\n}\n\nvar age, err2 = input.Prompt(\"Age: \")\nif err2 != None {\n    fmt.Println(\"Error:\", err2)\n}\n\nfmt.Println(\"Hello\", name, \"you are\", age, \"years old!\")\n</code></pre></p>"},{"location":"stdlib/json/","title":"<code>json</code> Module","text":"<p>The <code>json</code> module provides functions for working with JSON data, including seamless integration with Harneet's map and array types.</p>"},{"location":"stdlib/json/#functions","title":"Functions","text":""},{"location":"stdlib/json/#marshalvalue","title":"<code>Marshal(value)</code>","text":"<p>Converts a Harneet value to a JSON string. Supports strings, numbers, booleans, arrays, and maps.</p> <p>Parameters: - <code>value</code>: The value to convert (string, integer, boolean, None, array, or map).</p> <p>Returns: - <code>(string, error)</code>: The JSON string representation of the value.</p> <p>Examples:</p> <p>Basic types: <pre><code>import fmt\nimport json\n\nvar data = [\"apple\", \"banana\", \"cherry\"]\nvar jsonString, err = json.Marshal(data)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n} else {\n    fmt.Println(jsonString) // Output: [\"apple\",\"banana\",\"cherry\"]\n}\n</code></pre></p> <p>Maps to JSON objects: <pre><code>import fmt\nimport json\n\nvar user = {\"name\": \"Alice\", \"age\": 25, \"active\": true}\nvar jsonResult, err = json.Marshal(user)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n} else {\n    fmt.Println(jsonResult) // Output: {\"age\":25,\"active\":true,\"name\":\"Alice\"}\n}\n</code></pre></p> <p>Nested structures: <pre><code>import fmt\nimport json\n\nvar config = {\"database\": {\"host\": \"localhost\", \"port\": 5432}, \"debug\": true}\nvar jsonConfig, err = json.Marshal(config)\nif err != None {\n    fmt.Println(\"Marshal error:\", err)\n} else {\n    fmt.Println(jsonConfig) // Output: {\"database\":{\"host\":\"localhost\",\"port\":5432},\"debug\":true}\n}\n</code></pre></p>"},{"location":"stdlib/json/#unmarshaljson_string","title":"<code>Unmarshal(json_string)</code>","text":"<p>Parses a JSON string into a Harneet value. JSON objects become Harneet maps, JSON arrays become Harneet arrays.</p> <p>Parameters: - <code>json_string</code>: The JSON string to parse.</p> <p>Returns: - <code>(any, error)</code>: The parsed Harneet value (string, integer, boolean, None, array, or map).</p> <p>Examples:</p> <p>JSON arrays to Harneet arrays: <pre><code>import fmt\nimport json\n\nvar jsonString = \"[\\\"apple\\\",\\\"banana\\\",\\\"cherry\\\"]\"\nvar parsed, parseErr = json.Unmarshal(jsonString)\nif parseErr != None {\n    fmt.Println(\"Parse error:\", parseErr)\n} else {\n    fmt.Println(parsed) // Output: [apple, banana, cherry]\n}\n</code></pre></p> <p>JSON objects to Harneet maps: <pre><code>import fmt\nimport json\n\nvar jsonUser = \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 25, \\\"active\\\": true}\"\nvar user, err = json.Unmarshal(jsonUser)\nif err != None {\n    fmt.Println(\"Parse error:\", err)\n} else {\n    fmt.Printf(\"User: %s\\n\", user) // Output: User: {name: Alice, age: 25, active: true}\n    // Access map values\n    // var name = user[\"name\"]  // Returns \"Alice\"\n    // var age = user[\"age\"]    // Returns 25\n}\n</code></pre></p> <p>Nested JSON structures: <pre><code>import fmt\nimport json\n\nvar complexJson = \"{\\\"users\\\": [{\\\"name\\\": \\\"Alice\\\"}, {\\\"name\\\": \\\"Bob\\\"}], \\\"meta\\\": {\\\"count\\\": 2}}\"\nvar data, err = json.Unmarshal(complexJson)\nif err != None {\n    fmt.Println(\"Parse error:\", err)\n} else {\n    fmt.Printf(\"Data: %s\\n\", data)\n    // Access nested structures\n    // var users = data[\"users\"]     // Array of user maps\n    // var meta = data[\"meta\"]       // Meta information map\n    // var count = meta[\"count\"]     // Returns 2\n}\n</code></pre></p>"},{"location":"stdlib/json/#validjson_string","title":"<code>Valid(json_string)</code>","text":"<p>Checks if a string is a valid JSON.</p> <p>Parameters: - <code>json_string</code>: The string to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the string is valid JSON, <code>false</code> otherwise.</p>"},{"location":"stdlib/json/#indentjson-prefix-indent","title":"<code>Indent(json, prefix, indent)</code>","text":"<p>Formats a JSON string with indentation.</p> <p>Parameters: - <code>json</code>: The JSON string to format. - <code>prefix</code>: The prefix for each line. - <code>indent</code>: The indentation string.</p> <p>Returns: - <code>(string, error)</code>: The indented JSON string.</p>"},{"location":"stdlib/json/#json-maps-integration","title":"JSON-Maps Integration","text":"<p>The <code>json</code> module provides seamless integration with Harneet's map and array types, making JSON processing natural and efficient.</p>"},{"location":"stdlib/json/#type-mapping","title":"Type Mapping","text":"JSON Type Harneet Type Example <code>object</code> <code>map</code> <code>{\"key\": \"value\"}</code> \u2192 <code>{key: value}</code> <code>array</code> <code>array</code> <code>[1, 2, 3]</code> \u2192 <code>[1, 2, 3]</code> <code>string</code> <code>string</code> <code>\"hello\"</code> \u2192 <code>\"hello\"</code> <code>number</code> <code>int</code> or <code>float64</code> <code>42</code> \u2192 <code>42</code>, <code>3.14</code> \u2192 <code>3.14</code> <code>boolean</code> <code>bool</code> <code>true</code> \u2192 <code>true</code> <code>null</code> <code>None</code> <code>null</code> \u2192 <code>None</code>"},{"location":"stdlib/json/#round-trip-conversion","title":"Round-trip Conversion","text":"<p>JSON data can be converted to Harneet types and back without data loss:</p> <pre><code>import fmt\nimport json\n\n// Original Harneet data\nvar original = {\"name\": \"Alice\", \"scores\": [95, 87, 92], \"active\": true}\n\n// Convert to JSON\nvar jsonStr, err1 = json.Marshal(original)\nif err1 != None {\n    fmt.Println(\"Marshal error:\", err1)\n    return\n}\n\nfmt.Printf(\"JSON: %s\\n\", jsonStr)\n\n// Convert back to Harneet\nvar restored, err2 = json.Unmarshal(jsonStr)\nif err2 != None {\n    fmt.Println(\"Unmarshal error:\", err2)\n    return\n}\n\nfmt.Printf(\"Restored: %s\\n\", restored)\n// Output: Restored: {name: Alice, scores: [95, 87, 92], active: true}\n</code></pre>"},{"location":"stdlib/json/#working-with-api-responses","title":"Working with API Responses","text":"<p>JSON APIs can be easily processed using Harneet's map operations:</p> <pre><code>import fmt\nimport json\n\n// Simulate API response\nvar apiResponse = \"{\\\"users\\\": [{\\\"id\\\": 1, \\\"name\\\": \\\"Alice\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"Bob\\\"}], \\\"total\\\": 2}\"\n\nvar data, err = json.Unmarshal(apiResponse)\nif err != None {\n    fmt.Println(\"API parse error:\", err)\n    return\n}\n\n// Access API data using map operations\n// var users = data[\"users\"]\n// var total = data[\"total\"]\n// var firstUser = users[0]\n// var firstName = firstUser[\"name\"]\n\nfmt.Printf(\"API Data: %s\\n\", data)\n</code></pre>"},{"location":"stdlib/json/#configuration-management","title":"Configuration Management","text":"<p>JSON configuration files can be loaded as Harneet maps:</p> <pre><code>import fmt\nimport json\n\nvar configJson = \"{\\\"database\\\": {\\\"host\\\": \\\"localhost\\\", \\\"port\\\": 5432}, \\\"cache\\\": {\\\"ttl\\\": 300, \\\"enabled\\\": true}}\"\n\nvar config, err = json.Unmarshal(configJson)\nif err != None {\n    fmt.Println(\"Config parse error:\", err)\n    return\n}\n\n// Access configuration values\n// var dbHost = config[\"database\"][\"host\"]\n// var cacheEnabled = config[\"cache\"][\"enabled\"]\n\nfmt.Printf(\"Configuration: %s\\n\", config)\n</code></pre>"},{"location":"stdlib/json/#error-handling","title":"Error Handling","text":"<p>The JSON module provides comprehensive error handling for invalid data:</p> <pre><code>import fmt\nimport json\n\n// Invalid JSON\nvar invalidJson = \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": }\"\nvar data, err = json.Unmarshal(invalidJson)\nif err != None {\n    fmt.Printf(\"JSON Error: %s\\n\", err)\n} else {\n    fmt.Printf(\"Data: %s\\n\", data)\n}\n\n// Map with non-string keys (not JSON compatible)\nvar invalidMap = {42: \"number key\", \"string\": \"string key\"}\nvar jsonStr, marshalErr = json.Marshal(invalidMap)\nif marshalErr != None {\n    fmt.Printf(\"Marshal Error: %s\\n\", marshalErr)\n} else {\n    fmt.Printf(\"JSON: %s\\n\", jsonStr)\n}\n</code></pre>"},{"location":"stdlib/json/#see-also","title":"See Also","text":"<ul> <li>Maps - Harneet's map data structure</li> <li>Arrays - Harneet's array data structure</li> <li>Error Handling - Error handling patterns</li> </ul>"},{"location":"stdlib/log/","title":"<code>log</code> Module","text":"<p>The <code>log</code> module provides structured logging powered by Go's <code>slog</code>. It supports levels, structured fields, persistent context, and file rotation in text or JSON format.</p>"},{"location":"stdlib/log/#functions","title":"Functions","text":""},{"location":"stdlib/log/#infovalues","title":"<code>Info(values...)</code>","text":"<p>Logs at INFO level. If arguments are key/value pairs (<code>string</code> key), they are logged as structured fields. Otherwise, they are joined into a message.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.Info(\"service started\")\nlog.Info(\"user\", \"42\", \"action\", \"login\", \"ok\", true)\n</code></pre></p>"},{"location":"stdlib/log/#warnvalues","title":"<code>Warn(values...)</code>","text":"<p>Logs at WARN level.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.Warn(\"cache miss\", \"key\", \"sess:1\")\n</code></pre></p>"},{"location":"stdlib/log/#errorvalues","title":"<code>Error(values...)</code>","text":"<p>Logs at ERROR level.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.Error(\"db down\", \"retries\", 3)\n</code></pre></p>"},{"location":"stdlib/log/#debugvalues","title":"<code>Debug(values...)</code>","text":"<p>Logs at DEBUG level.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.Debug(\"details\", \"module\", \"auth\")\n</code></pre></p>"},{"location":"stdlib/log/#setlevellevel","title":"<code>SetLevel(level)</code>","text":"<p>Sets the current log level. Supported values: <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>.</p> <p>Parameters: - <code>level</code> (string)</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.SetLevel(\"WARN\")\nlog.Info(\"hidden\")     // below WARN\nlog.Warn(\"visible\")\n</code></pre></p>"},{"location":"stdlib/log/#setoutputpath","title":"<code>SetOutput(path)</code>","text":"<p>Directs logs to a rotating file with text format using defaults: <code>10MB</code> max size, <code>5</code> backups, <code>7</code> days retention, no compression.</p> <p>Parameters: - <code>path</code> (string): Log file path.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.SetOutput(\"./logs/app.log\")\nlog.Info(\"file output configured\")\n</code></pre></p>"},{"location":"stdlib/log/#configurerotationformat-path-maxsizemb-maxbackups-maxagedays-compress","title":"<code>ConfigureRotation(format, path, maxSizeMB, maxBackups, maxAgeDays, compress)</code>","text":"<p>Configures rotation and output format.</p> <p>Parameters: - <code>format</code> (string): <code>text</code> or <code>json</code>. - <code>path</code> (string): Log file path. - <code>maxSizeMB</code> (int): Max file size in MB before rotation. - <code>maxBackups</code> (int): Number of rotated files to keep. - <code>maxAgeDays</code> (int): Delete files older than this many days (0 disables). - <code>compress</code> (boolean): Gzip rotated files.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\n// Text handler\nlog.ConfigureRotation(\"text\", \"./logs/app-rotating.log\", 50, 10, 14, false)\nlog.Info(\"rotation configured\")\n\n// JSON handler\nlog.ConfigureRotation(\"json\", \"./logs/app.jsonl\", 50, 10, 14, true)\nlog.Error(\"failure\", \"code\", 500)\n</code></pre></p>"},{"location":"stdlib/log/#withkey-value","title":"<code>With(key, value)</code>","text":"<p>Adds a persistent structured attribute to the logger. Subsequent logs include this field.</p> <p>Parameters: - <code>key</code> (string) - <code>value</code> (any)</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import log\n\nlog.With(\"service\", \"payments\")\nlog.With(\"instance\", \"i-12345\")\nlog.Info(\"startup\", true)\n</code></pre></p>"},{"location":"stdlib/math/","title":"<code>math</code> Module","text":"<p>The <code>math</code> module provides basic mathematical operations.</p>"},{"location":"stdlib/math/#functions","title":"Functions","text":""},{"location":"stdlib/math/#absnumber","title":"<code>Abs(number)</code>","text":"<p>Returns the absolute value of a number.</p> <p>Parameters:</p> <ul> <li><code>number</code>: An integer or a float.</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The absolute value of the number, or an error if the argument is not a number.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Abs(-42)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 42\n}\n</code></pre>"},{"location":"stdlib/math/#ceilx","title":"<code>Ceil(x)</code>","text":"<p>Returns the least integer value greater than or equal to <code>x</code>.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The ceiling of <code>x</code> as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Ceil(3.14)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: 4\n}\n</code></pre>"},{"location":"stdlib/math/#floorx","title":"<code>Floor(x)</code>","text":"<p>Returns the greatest integer value less than or equal to <code>x</code>.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The floor of <code>x</code> as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Floor(3.14)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: 3\n}\n</code></pre>"},{"location":"stdlib/math/#roundx","title":"<code>Round(x)</code>","text":"<p>Returns the nearest integer to <code>x</code>, rounding halves away from zero.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The rounded value as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Round(3.5)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: 4\n}\n</code></pre>"},{"location":"stdlib/math/#roundtoevenx","title":"<code>RoundToEven(x)</code>","text":"<p>Returns the nearest integer to <code>x</code>, rounding ties to even.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The rounded value as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.RoundToEven(2.5)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: 2\n}\n</code></pre>"},{"location":"stdlib/math/#truncx","title":"<code>Trunc(x)</code>","text":"<p>Returns the integer value of <code>x</code> toward zero.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The truncated value as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Trunc(-3.9)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: -3\n}\n</code></pre>"},{"location":"stdlib/math/#pow10n","title":"<code>Pow10(n)</code>","text":"<p>Returns <code>10**n</code>.</p> <p>Parameters:</p> <ul> <li><code>n</code>: An integer exponent.</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The result as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Pow10(3)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: 1000\n}\n</code></pre>"},{"location":"stdlib/math/#sqrtx-and-cbrtx","title":"<code>Sqrt(x)</code> and <code>Cbrt(x)</code>","text":"<p>Return the square root and cube root of <code>x</code> respectively.</p> <p>Parameters:</p> <ul> <li><code>x</code>: A number (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The root as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar s, es = math.Sqrt(9)\nvar c, ec = math.Cbrt(27)\nfmt.Println(\"Sqrt(9) =\", s)   // 3\nfmt.Println(\"Cbrt(27) =\", c)  // 3\n</code></pre>"},{"location":"stdlib/math/#modx-y-and-remainderx-y","title":"<code>Mod(x, y)</code> and <code>Remainder(x, y)</code>","text":"<p><code>Mod</code> returns the truncating floating remainder of <code>x/y</code>. <code>Remainder</code> returns the IEEE 754 floating remainder.</p> <p>Parameters:</p> <ul> <li><code>x</code>, <code>y</code>: Numbers (int or float).</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The remainder as a float, or an error.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar m, em = math.Mod(5.5, 2)\nvar r, er = math.Remainder(5.5, 2)\nfmt.Println(\"Mod(5.5,2) =\", m)       // 1.5\nfmt.Println(\"Remainder(5.5,2) =\", r) // may be -0.5 or 1.5 depending on rule\n</code></pre>"},{"location":"stdlib/math/#expx-exp2x-expm1x-logx-log10x-log2x-log1px","title":"<code>Exp(x)</code>, <code>Exp2(x)</code>, <code>Expm1(x)</code>, <code>Log(x)</code>, <code>Log10(x)</code>, <code>Log2(x)</code>, <code>Log1p(x)</code>","text":"<p>Exponential and logarithmic functions.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar e, ee = math.Exp(1)\nvar l, el = math.Log(1)\nfmt.Println(\"Exp(1) =\", e)\nfmt.Println(\"Log(1) =\", l)   // 0\n</code></pre>"},{"location":"stdlib/math/#trigonometric-sinx-cosx-tanx-asinx-acosx-atanx-atan2y-x-sincosx","title":"Trigonometric: <code>Sin(x)</code>, <code>Cos(x)</code>, <code>Tan(x)</code>, <code>Asin(x)</code>, <code>Acos(x)</code>, <code>Atan(x)</code>, <code>Atan2(y, x)</code>, <code>Sincos(x)</code>","text":"<p>Compute trigonometric values in radians.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar s, es = math.Sin(1.57079632679) // ~pi/2\nvar a2, ea2 = math.Atan2(1, 0)\nvar sn, cs, esc = math.Sincos(0.5)\nfmt.Println(\"Sin(pi/2) =\", s)\nfmt.Println(\"Atan2(1,0) =\", a2)\nfmt.Println(\"Sincos(0.5) =\", sn, cs)\n</code></pre>"},{"location":"stdlib/math/#hyperbolic-sinhx-coshx-tanhx-asinhx-acoshx-atanhx","title":"Hyperbolic: <code>Sinh(x)</code>, <code>Cosh(x)</code>, <code>Tanh(x)</code>, <code>Asinh(x)</code>, <code>Acosh(x)</code>, <code>Atanh(x)</code>","text":"<p>Hyperbolic functions and their inverses.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar sh, eh = math.Sinh(1)\nvar ah, eah = math.Asinh(1)\nfmt.Println(\"Sinh(1) =\", sh)\nfmt.Println(\"Asinh(1) =\", ah)\n</code></pre>"},{"location":"stdlib/math/#special-gammax-lgammax-erfx-erfcx","title":"Special: <code>Gamma(x)</code>, <code>Lgamma(x)</code>, <code>Erf(x)</code>, <code>Erfc(x)</code>","text":"<p>Special functions from mathematics and statistics.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar g, eg = math.Gamma(5)           // 24\nvar lg, sign, elg = math.Lgamma(5)  // (log gamma, sign)\nfmt.Println(\"Gamma(5) =\", g)\nfmt.Println(\"Lgamma(5) =\", lg, sign)\n</code></pre>"},{"location":"stdlib/math/#utilities-copysign-signbit-dim-fma-hypot-frexp-ldexp-modf-nextafter-nextafter32","title":"Utilities: <code>Copysign</code>, <code>Signbit</code>, <code>Dim</code>, <code>FMA</code>, <code>Hypot</code>, <code>Frexp</code>, <code>Ldexp</code>, <code>Modf</code>, <code>Nextafter</code>, <code>Nextafter32</code>","text":"<p>Floating helpers and IEEE 754 utilities.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar cps, ecps = math.Copysign(3.5, -1)\nvar hyp, ehyp = math.Hypot(3, 4)\nvar intp, frac, em = math.Modf(3.14)\nfmt.Println(\"Copysign(3.5,-1) =\", cps)\nfmt.Println(\"Hypot(3,4) =\", hyp)\nfmt.Println(\"Modf(3.14) =\", intp, frac)\n</code></pre>"},{"location":"stdlib/math/#bit-level-float32bits-float64bits-float32frombits-float64frombits-inf-isinf-isnan-nan-ilogb-logb","title":"Bit-level: <code>Float32bits</code>, <code>Float64bits</code>, <code>Float32frombits</code>, <code>Float64frombits</code>, <code>Inf</code>, <code>IsInf</code>, <code>IsNaN</code>, <code>NaN</code>, <code>Ilogb</code>, <code>Logb</code>","text":"<p>Inspect and construct floating point values and metadata.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar bits, eb = math.Float64bits(3.5)\nvar f, ef = math.Float64frombits(bits)\nvar pinf, ei = math.Inf(1)\nvar infp, eip = math.IsInf(pinf, 1)\nvar nanv, en = math.NaN()\nfmt.Println(\"bits:\", bits, \" value:\", f)\nfmt.Println(\"IsInf(Inf,+1) =\", infp)\nfmt.Println(\"NaN() =\", nanv)\n</code></pre>"},{"location":"stdlib/math/#constants-pi-e-phi","title":"Constants: <code>Pi()</code>, <code>E()</code>, <code>Phi()</code>","text":"<p>Return common mathematical constants.</p> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar pi, epi = math.Pi()\nvar e, ee = math.E()\nvar phi, ephi = math.Phi()\nfmt.Println(\"Pi:\", pi)\nfmt.Println(\"E:\", e)\nfmt.Println(\"Phi:\", phi)\n</code></pre>"},{"location":"stdlib/math/#maxa-b","title":"<code>Max(a, b)</code>","text":"<p>Returns the maximum of two numbers.</p> <p>Parameters:</p> <ul> <li><code>a</code>: An integer or a float.</li> <li><code>b</code>: An integer or a float.</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The larger of the two numbers, or an error if the arguments are not numbers.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Max(10, 20)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 20\n}\n</code></pre>"},{"location":"stdlib/math/#mina-b","title":"<code>Min(a, b)</code>","text":"<p>Returns the minimum of two numbers.</p> <p>Parameters:</p> <ul> <li><code>a</code>: An integer or a float.</li> <li><code>b</code>: An integer or a float.</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The smaller of the two numbers, or an error if the arguments are not numbers.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Min(10, 20)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 10\n}\n</code></pre>"},{"location":"stdlib/math/#powbase-exponent","title":"<code>Pow(base, exponent)</code>","text":"<p>Returns the base to the power of the exponent.</p> <p>Parameters:</p> <ul> <li><code>base</code>: An integer or a float.</li> <li><code>exponent</code>: An integer or a float.</li> </ul> <p>Returns:</p> <ul> <li><code>(number, error)</code>: The result of the power operation, or an error if the arguments are not numbers.</li> </ul> <p>Example:</p> <pre><code>import fmt\nimport math\n\nvar result, err = math.Pow(2, 3)\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Result:\", result) // Output: Result: 8\n}\n</code></pre>"},{"location":"stdlib/os/","title":"<code>os</code> Module","text":"<p>The <code>os</code> module provides a comprehensive way to interact with the operating system, including structured device information through maps, file operations, environment variables, and system utilities.</p>"},{"location":"stdlib/os/#functions","title":"Functions","text":""},{"location":"stdlib/os/#args","title":"<code>Args()</code>","text":"<p>Returns the process arguments excluding the interpreter binary. Index 0 is typically the script path, and subsequent elements are the CLI arguments you passed when invoking Harneet.</p> <p>Returns: - <code>(array, error)</code>: An array of strings with the process arguments (script path first).</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar argv, _ = os.Args()\nfmt.Println(\"argv:\", argv)\n\n// Often you'll drop the script path (index 0) and pass the rest to flags:\n// var sel, args, tag, err = flags.Run(argv[1:])\n</code></pre></p>"},{"location":"stdlib/os/#getenvname","title":"<code>Getenv(name)</code>","text":"<p>Gets the value of an environment variable.</p> <p>Parameters: - <code>name</code>: The name of the environment variable.</p> <p>Returns: - <code>(string, error)</code>: The value of the environment variable, or an empty string if it's not set.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar home, _ = os.Getenv(\"HOME\")\nfmt.Println(\"HOME directory:\", home)\n</code></pre></p>"},{"location":"stdlib/os/#setenvname-value","title":"<code>Setenv(name, value)</code>","text":"<p>Sets the value of an environment variable.</p> <p>Parameters: - <code>name</code>: The name of the environment variable. - <code>value</code>: The value to set.</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import os\n\nos.Setenv(\"MY_VAR\", \"my_value\")\n</code></pre></p>"},{"location":"stdlib/os/#type","title":"<code>Type()</code>","text":"<p>Returns the operating system type.</p> <p>Returns: - <code>(string, error)</code>: The OS type (e.g., \"darwin\", \"linux\", \"windows\").</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar osType, _ = os.Type()\nfmt.Println(\"OS Type:\", osType)\n</code></pre></p>"},{"location":"stdlib/os/#version","title":"<code>Version()</code>","text":"<p>Returns the operating system version.</p> <p>Returns: - <code>(string, error)</code>: The OS version.</p>"},{"location":"stdlib/os/#arch","title":"<code>Arch()</code>","text":"<p>Returns the system architecture.</p> <p>Returns: - <code>(string, error)</code>: The architecture (e.g., \"amd64\", \"arm64\").</p>"},{"location":"stdlib/os/#getwd","title":"<code>Getwd()</code>","text":"<p>Returns the current working directory.</p> <p>Returns: - <code>(string, error)</code>: The current working directory path.</p>"},{"location":"stdlib/os/#chdirpath","title":"<code>Chdir(path)</code>","text":"<p>Changes the current working directory.</p> <p>Parameters: - <code>path</code>: The path to the new directory.</p>"},{"location":"stdlib/os/#mkdirpath","title":"<code>Mkdir(path)</code>","text":"<p>Creates a new directory.</p> <p>Parameters: - <code>path</code>: The path of the directory to create.</p>"},{"location":"stdlib/os/#removepath","title":"<code>Remove(path)</code>","text":"<p>Removes a file or directory.</p> <p>Parameters: - <code>path</code>: The path of the file or directory to remove.</p>"},{"location":"stdlib/os/#existspath","title":"<code>Exists(path)</code>","text":"<p>Checks if a file or directory exists.</p> <p>Parameters: - <code>path</code>: The path to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the path exists, <code>false</code> otherwise.</p>"},{"location":"stdlib/os/#tempdir","title":"<code>TempDir()</code>","text":"<p>Returns the default directory to use for temporary files.</p> <p>Returns: - <code>(string, error)</code>: The temporary directory path (e.g., \"/tmp\" on Unix systems).</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar tmpDir, _ = os.TempDir()\nfmt.Printf(\"Temp directory: %s\\n\", tmpDir)\n</code></pre></p>"},{"location":"stdlib/os/#createtempdir-pattern","title":"<code>CreateTemp(dir, pattern)</code>","text":"<p>Creates a new temporary file in the directory <code>dir</code> with a name beginning with <code>pattern</code> and returns the file path. The file is created on disk immediately with a unique name.</p> <p>Parameters: - <code>dir</code> (string): Directory for temp file (use empty string \"\" for os.TempDir()) - <code>pattern</code> (string): Name pattern (e.g., \"myapp-*.txt\" where * is replaced with random string)</p> <p>Returns: - <code>(string, error)</code>: The full path to the created temporary file.</p> <p>Key Features: - Automatic location: Empty string uses system temp directory (<code>/tmp</code> on Unix, <code>%TEMP%</code> on Windows) - Pattern matching: The <code>*</code> in pattern is replaced with a random string to ensure uniqueness - File created: File is created on disk immediately and returned closed - No collisions: Guaranteed unique filename prevents conflicts</p> <p>Pattern Examples: - <code>\"upload-*.dat\"</code> \u2192 <code>upload-1234567.dat</code> - <code>\"cache-*.json\"</code> \u2192 <code>cache-9876543.json</code> - <code>\"test-*\"</code> \u2192 <code>test-4567890</code></p> <p>Example 1 - Basic Usage: <pre><code>import fmt\nimport os\n\n// Create temp file in default temp directory\nvar tmpFile, err = os.CreateTemp(\"\", \"upload-*.dat\")\nif err == None {\n    fmt.Printf(\"Created temp file: %s\\n\", tmpFile)\n    // Example output: /tmp/upload-2289271499.dat\n\n    // Write data to it\n    os.WriteFile(tmpFile, \"temporary data\")\n\n    // Read it back\n    var content, _ = os.ReadFile(tmpFile)\n    fmt.Println(content)\n\n    // Clean up when done\n    os.Remove(tmpFile)\n}\n</code></pre></p> <p>Example 2 - Upload Processing: <pre><code>import os\nimport fmt\n\nfunction processUpload(data string) {\n    var tmp, err = os.CreateTemp(\"\", \"upload-*.dat\")\n    if err != None {\n        fmt.Printf(\"Error creating temp file: %s\\n\", err)\n        return\n    }\n\n    // Write uploaded data\n    var _, writeErr = os.WriteFile(tmp, data)\n    if writeErr != None {\n        os.Remove(tmp)\n        return\n    }\n\n    // Process the file\n    fmt.Printf(\"Processing %s...\\n\", tmp)\n    // ... your processing logic ...\n\n    // Clean up\n    os.Remove(tmp)\n    fmt.Println(\"Processing complete\")\n}\n</code></pre></p> <p>Example 3 - Custom Directory: <pre><code>import os\nimport fmt\n\n// Create temp file in specific directory\nvar tmp, err = os.CreateTemp(\"/var/tmp\", \"custom-*.log\")\nif err == None {\n    fmt.Println(tmp)  // Output: /var/tmp/custom-1234567.log\n\n    // Use the file...\n    os.WriteFile(tmp, \"log data\")\n\n    // Clean up\n    os.Remove(tmp)\n}\n</code></pre></p> <p>Example 4 - Safe Pattern with Defer (Future): <pre><code>import os\n\nfunction doWork() {\n    var tmp, err = os.CreateTemp(\"\", \"work-*.tmp\")\n    if err != None {\n        return\n    }\n    // Note: defer will be supported in future for automatic cleanup\n    // defer os.Remove(tmp)\n\n    // Do work with temp file...\n    os.WriteFile(tmp, \"work data\")\n\n    // Manual cleanup for now\n    os.Remove(tmp)\n}\n</code></pre></p>"},{"location":"stdlib/os/#chmodname-mode","title":"<code>Chmod(name, mode)</code>","text":"<p>Changes the mode (permissions) of the named file to <code>mode</code>.</p> <p>Parameters: - <code>name</code> (string): Path to the file - <code>mode</code> (int): Unix file permissions as decimal (e.g., 420 for 0644, 493 for 0755)</p> <p>Returns: - <code>(None, error)</code>: None on success, error on failure.</p> <p>Common Permission Values: - <code>420</code> (0644): rw-r--r-- - Owner read/write, group/others read - <code>384</code> (0600): rw------- - Owner read/write only - <code>493</code> (0755): rwxr-xr-x - Owner full, group/others read/execute</p> <p>Example: <pre><code>import os\n\n// Create file with default permissions\nos.WriteFile(\"config.json\", configData)\n\n// Restrict to owner-only read/write\nvar _, err = os.Chmod(\"config.json\", 384)  // 0600\nif err == None {\n    fmt.Println(\"Permissions changed to owner-only\")\n}\n</code></pre></p>"},{"location":"stdlib/os/#chtimesname-atime-mtime","title":"<code>Chtimes(name, atime, mtime)</code>","text":"<p>Changes the access and modification times of the named file.</p> <p>Parameters: - <code>name</code> (string): Path to the file - <code>atime</code> (int): Access time as Unix timestamp (seconds since epoch) - <code>mtime</code> (int): Modification time as Unix timestamp (seconds since epoch)</p> <p>Returns: - <code>(None, error)</code>: None on success, error on failure.</p> <p>Example: <pre><code>import os\nimport time\n\n// Set file times to a specific date\n// 1609459200 = 2021-01-01 00:00:00 UTC\nvar _, err = os.Chtimes(\"document.txt\", 1609459200, 1609459200)\nif err == None {\n    fmt.Println(\"File times updated\")\n}\n\n// Copy file while preserving timestamps\nvar _, _, modTime, _ = os.Stat(\"original.txt\")\nvar content, _ = os.ReadFile(\"original.txt\")\nos.WriteFile(\"copy.txt\", content)\n// Note: modTime needs to be converted to Unix timestamp\n</code></pre></p>"},{"location":"stdlib/os/#clearenv","title":"<code>Clearenv()</code>","text":"<p>Deletes all environment variables. Use with caution - this clears the entire environment!</p> <p>Returns: - <code>(None, error)</code>: None on success.</p> <p>Example: <pre><code>import os\n\n// Save important variables first\nvar originalPath, _ = os.Getenv(\"PATH\")\nvar originalHome, _ = os.Getenv(\"HOME\")\n\n// Clear all environment variables\nos.Clearenv()\n\n// Restore critical variables\nos.Setenv(\"PATH\", originalPath)\nos.Setenv(\"HOME\", originalHome)\n</code></pre></p>"},{"location":"stdlib/os/#environ","title":"<code>Environ()</code>","text":"<p>Returns a copy of strings representing the environment, in the form \"KEY=value\".</p> <p>Returns: - <code>(array, error)</code>: Array of strings, each in \"KEY=value\" format.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar env, _ = os.Environ()\nfmt.Printf(\"Environment has %d variables\\n\", len(env))\n\nfor envVar in env {\n    fmt.Println(envVar)\n}\n</code></pre></p>"},{"location":"stdlib/os/#getpid","title":"<code>Getpid()</code>","text":"<p>Returns the process ID of the caller.</p> <p>Returns: - <code>(int, error)</code>: The process ID.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar pid, _ = os.Getpid()\nfmt.Printf(\"Current process ID: %d\\n\", pid)\n</code></pre></p>"},{"location":"stdlib/os/#getppid","title":"<code>Getppid()</code>","text":"<p>Returns the process ID of the caller's parent.</p> <p>Returns: - <code>(int, error)</code>: The parent process ID.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar ppid, _ = os.Getppid()\nfmt.Printf(\"Parent process ID: %d\\n\", ppid)\n</code></pre></p>"},{"location":"stdlib/os/#lookupuserusername","title":"<code>LookupUser(username)</code>","text":"<p>Looks up a user by username and returns a map with user information.</p> <p>Parameters: - <code>username</code> (string): The username to look up</p> <p>Returns: - <code>(map, error)</code>: Map with keys: <code>uid</code>, <code>gid</code>, <code>username</code>, <code>name</code>, <code>homedir</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar user, err = os.LookupUser(\"alice\")\nif err == None {\n    fmt.Printf(\"User: %s\\n\", user[\"username\"])\n    fmt.Printf(\"UID: %s\\n\", user[\"uid\"])\n    fmt.Printf(\"GID: %s\\n\", user[\"gid\"])\n    fmt.Printf(\"Full name: %s\\n\", user[\"name\"])\n    fmt.Printf(\"Home: %s\\n\", user[\"homedir\"])\n}\n</code></pre></p>"},{"location":"stdlib/os/#lookupgroupgroupname","title":"<code>LookupGroup(groupname)</code>","text":"<p>Looks up a group by name and returns a map with group information.</p> <p>Parameters: - <code>groupname</code> (string): The group name to look up</p> <p>Returns: - <code>(map, error)</code>: Map with keys: <code>gid</code>, <code>name</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar group, err = os.LookupGroup(\"wheel\")\nif err == None {\n    fmt.Printf(\"Group: %s\\n\", group[\"name\"])\n    fmt.Printf(\"GID: %s\\n\", group[\"gid\"])\n}\n</code></pre></p>"},{"location":"stdlib/os/#hostname","title":"<code>Hostname()</code>","text":"<p>Returns the host name reported by the kernel.</p> <p>Returns: - <code>(string, error)</code>: The hostname.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar hostname, _ = os.Hostname()\nfmt.Printf(\"Hostname: %s\\n\", hostname)\n</code></pre></p>"},{"location":"stdlib/os/#userhomedir","title":"<code>UserHomeDir()</code>","text":"<p>Returns the current user's home directory.</p> <p>Returns: - <code>(string, error)</code>: The home directory path.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar home, _ = os.UserHomeDir()\nfmt.Printf(\"Home directory: %s\\n\", home)\n</code></pre></p>"},{"location":"stdlib/os/#execcmd-args","title":"<code>Exec(cmd, args)</code>","text":"<p>Runs an external command and returns its stdout as a string. On non-zero exit, returns an error containing stderr.</p> <p>Parameters: - <code>cmd</code> (string): Command to execute - <code>args</code> (array): Array of string arguments</p> <p>Returns: - <code>(string, error)</code>: Command output or error with stderr.</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar output, err = os.Exec(\"ls\", [\"-la\", \"/tmp\"])\nif err == None {\n    fmt.Println(output)\n} else {\n    fmt.Printf(\"Command failed: %s\\n\", err)\n}\n</code></pre></p>"},{"location":"stdlib/os/#device-functions","title":"Device Functions","text":"<p>The following functions provide structured device information through maps, enabling modern programmatic access to system hardware data.</p>"},{"location":"stdlib/os/#listdevices","title":"<code>ListDevices()</code>","text":"<p>Returns an array of device information maps for system devices.</p> <p>Returns: - <code>(array, error)</code>: Array of device maps, each containing device information.</p> <p>Device Map Structure: Each device map contains the following keys: - <code>type</code>: Device type (\"USB\", \"Storage\", \"Network\") - <code>name</code>: Human-readable device name - <code>id</code>: Device identifier - <code>status</code>: Device status (\"available\", \"connected\", \"mounted\") - <code>count</code>: Number of devices (for USB devices)</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar devices, err = os.ListDevices()\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    fmt.Printf(\"Found %d device types\\n\", len(devices))\n\n    // Access individual device maps\n    for device in devices {\n        var deviceType = device[\"type\"]\n        var deviceName = device[\"name\"]\n        var deviceStatus = device[\"status\"]\n\n        fmt.Printf(\"Device: %s - %s (%s)\\n\", deviceType, deviceName, deviceStatus)\n    }\n\n    // Access specific device properties\n    var firstDevice = devices[0]\n    var usbCount = firstDevice[\"count\"]  // For USB devices\n}\n</code></pre></p> <p>Cross-Platform Support: - macOS: USB devices and storage drives - Linux: Individual USB devices with detailed information - Windows: Storage devices and system drives</p>"},{"location":"stdlib/os/#getdeviceinfodeviceid","title":"<code>GetDeviceInfo(deviceId)</code>","text":"<p>Returns detailed information about a specific device as a structured map.</p> <p>Parameters: - <code>deviceId</code>: Device identifier string (e.g., \"system\", \"cpu\")</p> <p>Returns: - <code>(map, error)</code>: Device information map with detailed hardware data.</p> <p>Device Info Map Structure: The returned map contains the following keys: - <code>id</code>: Device identifier - <code>type</code>: Device type (\"macOS Device\", \"Linux Device\", \"Windows Device\") - <code>name</code>: Device name - <code>status</code>: Device status (\"active\", \"inactive\") - <code>details</code>: Nested map with hardware-specific information</p> <p>Example: <pre><code>import fmt\nimport os\n\nvar deviceInfo, err = os.GetDeviceInfo(\"system\")\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    // Access basic device information\n    var deviceId = deviceInfo[\"id\"]\n    var deviceType = deviceInfo[\"type\"]\n    var deviceName = deviceInfo[\"name\"]\n    var deviceStatus = deviceInfo[\"status\"]\n\n    fmt.Printf(\"Device: %s (%s)\\n\", deviceName, deviceType)\n    fmt.Printf(\"Status: %s\\n\", deviceStatus)\n\n    // Access detailed hardware information\n    var deviceDetails = deviceInfo[\"details\"]\n    if deviceDetails != None {\n        // On macOS, details include:\n        var chip = deviceDetails[\"Chip\"]              // \"Apple M2 Pro\"\n        var memory = deviceDetails[\"Memory\"]          // \"16 GB\"\n        var model = deviceDetails[\"Model Name\"]       // \"MacBook Pro\"\n        var serial = deviceDetails[\"Serial Number\"]   // System serial\n\n        fmt.Printf(\"Hardware: %s with %s\\n\", chip, memory)\n        fmt.Printf(\"Model: %s\\n\", model)\n    }\n}\n</code></pre></p> <p>Platform-Specific Details:</p> <p>macOS (<code>system_profiler</code>): - Chip/Processor information - Memory specifications - Model details and serial numbers - Hardware UUID and identifiers</p> <p>Linux (<code>lscpu</code>): - CPU architecture and specifications - Core count and threading - Cache information - Processor features</p> <p>Windows (<code>wmic</code>): - System manufacturer and model - Total physical memory - Computer system information</p> <p>JSON Integration: Device information maps work seamlessly with JSON serialization:</p> <pre><code>import fmt\nimport os\nimport json\n\nvar devices, _ = os.ListDevices()\nvar deviceInfo, _ = os.GetDeviceInfo(\"system\")\n\n// Create system report\nvar systemReport = {\n    \"timestamp\": \"2024-09-24T13:30:00Z\",\n    \"devices\": devices,\n    \"primary_device\": deviceInfo\n}\n\nvar reportJson, err = json.Marshal(systemReport)\nif err == None {\n    fmt.Printf(\"System Report JSON: %s\\n\", reportJson)\n}\n</code></pre>"},{"location":"stdlib/os/#mkdirallpath","title":"<code>MkdirAll(path)</code>","text":"<p>Creates a directory and all necessary parents.</p> <p>Parameters: - <code>path</code>: Directory to create (parents will be created as needed).</p> <p>Returns: - <code>(None, error)</code></p> <p>Example: <pre><code>import os\nvar _, err = os.MkdirAll(\"/tmp/harneet/demo/sub/dir\")\n</code></pre></p>"},{"location":"stdlib/os/#removeallpath","title":"<code>RemoveAll(path)</code>","text":"<p>Removes a path and everything it contains.</p> <p>Parameters: - <code>path</code>: File or directory to remove recursively.</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/os/#renameold-new","title":"<code>Rename(old, new)</code>","text":"<p>Renames (moves) a file or directory.</p> <p>Parameters: - <code>old</code>: Source path. - <code>new</code>: Destination path.</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/os/#readfilepath","title":"<code>ReadFile(path)</code>","text":"<p>Reads a file and returns its contents as a string.</p> <p>Parameters: - <code>path</code>: File path to read.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar data, err = os.ReadFile(\"/etc/hosts\")\nif err == None { fmt.Println(data) }\n</code></pre></p>"},{"location":"stdlib/os/#writefilepath-data","title":"<code>WriteFile(path, data)</code>","text":"<p>Writes a string to a file (creates or overwrites) using 0644 permissions.</p> <p>Parameters: - <code>path</code>: Target file path. - <code>data</code>: String content to write.</p> <p>Returns: - <code>(None, error)</code></p>"},{"location":"stdlib/os/#readdirpath","title":"<code>ReadDir(path)</code>","text":"<p>Reads a directory and returns an array of tuples for each entry: <code>(name string, isDir boolean, size int, modTime string)</code> where <code>modTime</code> is RFC3339 UTC.</p> <p>Parameters: - <code>path</code>: Directory path.</p> <p>Returns: - <code>(array, error)</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar entries, err = os.ReadDir(\"/tmp\")\nif err == None {\n    // entries[i] is a tuple: (name, isDir, size, modTime)\n    fmt.Println(entries)\n}\n</code></pre></p>"},{"location":"stdlib/os/#statpath","title":"<code>Stat(path)</code>","text":"<p>Returns basic file information: size (bytes), isDir (boolean), modTime (RFC3339 UTC).</p> <p>Parameters: - <code>path</code>: File or directory path.</p> <p>Returns: - <code>(int, boolean, string, error)</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar size, isDir, mt, err = os.Stat(\"/etc/hosts\")\nif err == None {\n    fmt.Printf(\"size=%d isDir=%t mtime=%s\\n\", size, isDir, mt)\n}\n</code></pre></p>"},{"location":"stdlib/os/#exitcode","title":"<code>Exit(code)</code>","text":"<p>Terminates the current process with the given status code.</p> <p>Parameters: - <code>code</code>: Exit status code (int).</p> <p>Returns: - <code>(None, error)</code></p> <p>Note: This will terminate the program immediately.</p>"},{"location":"stdlib/os/#expandenvs","title":"<code>ExpandEnv(s)</code>","text":"<p>Expands <code>${VAR}</code> or <code>$VAR</code> in a string using the current environment.</p> <p>Parameters: - <code>s</code>: Input string containing env references.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>import fmt\nimport os\n\nvar out, err = os.ExpandEnv(\"HOME=$HOME USER=$USER\")\nif err == None { fmt.Println(out) }\n</code></pre></p>"},{"location":"stdlib/os/#device-information-maps","title":"Device Information Maps","text":"<p>The <code>os</code> module provides structured device information through maps, making system data easy to access and process programmatically.</p>"},{"location":"stdlib/os/#map-based-device-data","title":"Map-Based Device Data","text":"<p>Unlike traditional string-based system information, Harneet's OS module returns structured maps that can be easily accessed, filtered, and serialized.</p> <p>Benefits: - Structured Access: Use map indexing to access specific properties - Type Safety: Consistent data types for device properties - JSON Ready: Seamless integration with JSON serialization - Programmatic Processing: Easy filtering and data manipulation</p>"},{"location":"stdlib/os/#device-list-structure","title":"Device List Structure","text":"<pre><code>// Example device list output\n[\n    {\n        \"type\": \"USB\",\n        \"name\": \"USB Devices\", \n        \"status\": \"available\",\n        \"count\": 141\n    },\n    {\n        \"type\": \"Storage\",\n        \"name\": \"Disk Drives\",\n        \"status\": \"mounted\"\n    }\n]\n</code></pre>"},{"location":"stdlib/os/#device-info-structure","title":"Device Info Structure","text":"<pre><code>// Example device info output\n{\n    \"id\": \"system\",\n    \"type\": \"macOS Device\",\n    \"name\": \"Mac Hardware\", \n    \"status\": \"active\",\n    \"details\": {\n        \"Chip\": \"Apple M2 Pro\",\n        \"Memory\": \"16 GB\",\n        \"Model Name\": \"MacBook Pro\",\n        \"Serial Number\": \"K4V7JN6RW1\",\n        \"Hardware UUID\": \"D867AE5E-6481-5E87-B778-24EAA3458572\"\n    }\n}\n</code></pre>"},{"location":"stdlib/os/#common-use-cases","title":"Common Use Cases","text":"<p>System Monitoring: <pre><code>import os\n\nvar devices, _ = os.ListDevices()\nfor device in devices {\n    if device[\"type\"] == \"USB\" &amp;&amp; device[\"count\"] &gt; 100 {\n        fmt.Printf(\"High USB device count: %s\\n\", device[\"count\"])\n    }\n}\n</code></pre></p> <p>Hardware Inventory: <pre><code>import os\n\nvar info, _ = os.GetDeviceInfo(\"system\")\nvar inventory = {\n    \"model\": info[\"details\"][\"Model Name\"],\n    \"memory\": info[\"details\"][\"Memory\"],\n    \"processor\": info[\"details\"][\"Chip\"],\n    \"serial\": info[\"details\"][\"Serial Number\"]\n}\n</code></pre></p> <p>API Integration: <pre><code>import os\nimport json\n\nvar devices, _ = os.ListDevices()\nvar deviceInfo, _ = os.GetDeviceInfo(\"system\")\n\nvar apiPayload = {\n    \"hostname\": \"server-01\",\n    \"devices\": devices,\n    \"hardware\": deviceInfo,\n    \"timestamp\": \"2024-09-24T13:30:00Z\"\n}\n\nvar jsonData, _ = json.Marshal(apiPayload)\n// Send jsonData to monitoring API\n</code></pre></p> <p>Configuration Management: <pre><code>import os\n\nvar systemInfo, _ = os.GetDeviceInfo(\"system\")\nvar config = {\n    \"deployment\": {\n        \"target\": systemInfo[\"details\"][\"Model Name\"],\n        \"memory_gb\": systemInfo[\"details\"][\"Memory\"],\n        \"architecture\": systemInfo[\"type\"]\n    }\n}\n</code></pre></p>"},{"location":"stdlib/os/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>The device information maps provide consistent structure across platforms while including platform-specific details:</p> Platform Device Types Hardware Details Special Features macOS USB, Storage Full system profiler data Hardware UUID, Model numbers Linux USB (individual) CPU specifications Detailed USB device info Windows Storage System manufacturer info Drive information"},{"location":"stdlib/os/#error-handling","title":"Error Handling","text":"<p>Device functions return structured error information:</p> <pre><code>import fmt\nimport os\n\nvar devices, err = os.ListDevices()\nif err != None {\n    fmt.Printf(\"Device listing failed: %s\\n\", err)\n} else {\n    if len(devices) == 0 {\n        fmt.Println(\"No devices found\")\n    } else {\n        fmt.Printf(\"Found %d device types\\n\", len(devices))\n    }\n}\n</code></pre>"},{"location":"stdlib/os/#see-also","title":"See Also","text":"<ul> <li>Maps - Harneet's map data structure</li> <li>JSON - JSON serialization for device data</li> <li>Arrays - Working with device lists</li> </ul>"},{"location":"stdlib/path/","title":"<code>path</code> Module","text":"<p>The <code>path</code> module provides functions for working with file paths.</p>"},{"location":"stdlib/path/#functions","title":"Functions","text":""},{"location":"stdlib/path/#joinparts","title":"<code>Join(parts...)</code>","text":"<p>Joins any number of path elements into a single path.</p> <p>Parameters: - <code>parts...</code>: The path elements to join.</p> <p>Returns: - <code>(string, error)</code>: The joined path.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar p, _ = path.Join(\"/home\", \"user\", \"file.txt\")\nfmt.Println(p) // Output: /home/user/file.txt\n</code></pre></p>"},{"location":"stdlib/path/#dirpath","title":"<code>Dir(path)</code>","text":"<p>Returns the directory portion of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The directory portion.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar dir, _ = path.Dir(\"/home/user/file.txt\")\nfmt.Println(dir) // Output: /home/user\n</code></pre></p>"},{"location":"stdlib/path/#basepath","title":"<code>Base(path)</code>","text":"<p>Returns the last element of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The last element.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar base, _ = path.Base(\"/home/user/file.txt\")\nfmt.Println(base) // Output: file.txt\n</code></pre></p>"},{"location":"stdlib/path/#extpath","title":"<code>Ext(path)</code>","text":"<p>Returns the file extension of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The file extension.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar ext, _ = path.Ext(\"/home/user/file.txt\")\nfmt.Println(ext) // Output: .txt\n</code></pre></p>"},{"location":"stdlib/path/#abspath","title":"<code>Abs(path)</code>","text":"<p>Returns an absolute representation of a path.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The absolute path.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar abs, _ = path.Abs(\"file.txt\")\nfmt.Println(abs)\n</code></pre></p>"},{"location":"stdlib/path/#cleanpath","title":"<code>Clean(path)</code>","text":"<p>Returns the shortest path name equivalent to <code>path</code> by purely lexical processing.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, error)</code>: The cleaned path.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar cleaned, _ = path.Clean(\"/foo//bar/../baz/./\")\nfmt.Println(cleaned) // Output: /foo/baz\n</code></pre></p>"},{"location":"stdlib/path/#isabspath","title":"<code>IsAbs(path)</code>","text":"<p>Reports whether a path is absolute.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if absolute, else <code>false</code>.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar abs, _ = path.IsAbs(\"/usr/local\")\nfmt.Println(abs) // Output: 1 (true)\n</code></pre></p>"},{"location":"stdlib/path/#splitpath","title":"<code>Split(path)</code>","text":"<p>Splits a path immediately following the final separator, returning directory and file name.</p> <p>Parameters: - <code>path</code>: The file path.</p> <p>Returns: - <code>(string, string, error)</code>: <code>(dir, file)</code>.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar dir, file, _ = path.Split(\"/home/user/file.txt\")\nfmt.Println(dir)  // Output: /home/user/\nfmt.Println(file) // Output: file.txt\n</code></pre></p>"},{"location":"stdlib/path/#relbase-target","title":"<code>Rel(base, target)</code>","text":"<p>Returns a relative path that is lexically equivalent to <code>target</code> when joined to <code>base</code>.</p> <p>Parameters: - <code>base</code>: Base path. - <code>target</code>: Target path.</p> <p>Returns: - <code>(string, error)</code>: The relative path.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar rel, _ = path.Rel(\"/home/user\", \"/home/user/projects/app\")\nfmt.Println(rel) // Output: projects/app\n</code></pre></p>"},{"location":"stdlib/path/#toslashpath","title":"<code>ToSlash(path)</code>","text":"<p>Replaces OS-specific separators with <code>/</code>.</p> <p>Parameters: - <code>path</code>: Input path.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>import fmt\nimport path\n\nvar s, _ = path.ToSlash(\"C:\\\\Users\\\\Alice\\\\file.txt\")\nfmt.Println(s) // Output on Windows: C:/Users/Alice/file.txt\n</code></pre></p>"},{"location":"stdlib/path/#fromslashpath","title":"<code>FromSlash(path)</code>","text":"<p>Replaces <code>/</code> with OS-specific separators.</p> <p>Parameters: - <code>path</code>: Input path.</p> <p>Returns: - <code>(string, error)</code></p> <p>Example: <pre><code>import fmt\nimport path\n\nvar s, _ = path.FromSlash(\"C:/Users/Alice/file.txt\")\nfmt.Println(s)\n</code></pre></p>"},{"location":"stdlib/path/#matchpattern-name","title":"<code>Match(pattern, name)</code>","text":"<p>Reports whether <code>name</code> matches the shell file name <code>pattern</code>.</p> <p>Parameters: - <code>pattern</code>: Glob-style pattern (e.g. <code>*.txt</code>). - <code>name</code>: Name to match.</p> <p>Returns: - <code>(boolean, error)</code></p> <p>Example: <pre><code>import fmt\nimport path\n\nvar ok, _ = path.Match(\"*.go\", \"main.go\")\nfmt.Println(ok) // Output: 1 (true)\n</code></pre></p>"},{"location":"stdlib/path/#globpattern","title":"<code>Glob(pattern)</code>","text":"<p>Returns the names of all files matching <code>pattern</code>, or an empty array if none.</p> <p>Parameters: - <code>pattern</code>: Glob pattern.</p> <p>Returns: - <code>(array, error)</code>: Array of matching paths.</p> <p>Example: <pre><code>import fmt\nimport path\n\nvar matches, _ = path.Glob(\"/tmp/*.log\")\nfmt.Println(matches)\n</code></pre></p>"},{"location":"stdlib/path/#splitlistpathlist","title":"<code>SplitList(pathList)</code>","text":"<p>Splits a list of paths joined by the OS-specific ListSeparator (<code>:</code> on Unix, <code>;</code> on Windows).</p> <p>Parameters: - <code>pathList</code> (string): Path list string (e.g., from PATH environment variable)</p> <p>Returns: - <code>(array, error)</code>: Array of individual path strings.</p> <p>Example: <pre><code>import fmt\nimport path\nimport os\n\n// Process PATH environment variable\nvar pathEnv, _ = os.Getenv(\"PATH\")\nvar paths, _ = path.SplitList(pathEnv)\n\nfmt.Printf(\"Found %d paths in PATH:\\n\", len(paths))\nfor p in paths {\n    fmt.Printf(\"  - %s\\n\", p)\n}\n\n// Manual path list\nvar manualList = \"/usr/bin:/usr/local/bin:/bin\"\nvar manualPaths, _ = path.SplitList(manualList)\nfmt.Println(manualPaths)  // [/usr/bin, /usr/local/bin, /bin]\n</code></pre></p>"},{"location":"stdlib/path/#volumenamepath","title":"<code>VolumeName(path)</code>","text":"<p>Returns the leading volume name. On Windows, returns the drive letter (e.g., \"C:\"). On Unix systems, returns an empty string.</p> <p>Parameters: - <code>path</code> (string): File path</p> <p>Returns: - <code>(string, error)</code>: Volume name or empty string.</p> <p>Example: <pre><code>import fmt\nimport path\n\n// Windows paths\nvar vol1, _ = path.VolumeName(\"C:\\\\Windows\\\\System32\")\nfmt.Println(vol1)  // Windows: \"C:\", Unix: \"\"\n\nvar vol2, _ = path.VolumeName(\"D:\\\\Data\\\\files\")\nfmt.Println(vol2)  // Windows: \"D:\", Unix: \"\"\n\n// Unix paths (no volume)\nvar vol3, _ = path.VolumeName(\"/usr/local/bin\")\nfmt.Println(vol3)  // Always: \"\"\n\n// Use for cross-platform path handling\nvar fullPath = \"C:\\\\projects\\\\myapp\\\\file.txt\"\nvar volume, _ = path.VolumeName(fullPath)\nif volume != \"\" {\n    fmt.Printf(\"Windows path with volume: %s\\n\", volume)\n} else {\n    fmt.Println(\"Unix-style path (no volume)\")\n}\n</code></pre></p>"},{"location":"stdlib/path/#see-also","title":"See Also","text":"<ul> <li>OS Module - Operating system interactions</li> <li>String Module - String manipulation functions</li> </ul>"},{"location":"stdlib/reflect/","title":"reflect","text":"<p>Runtime type introspection utilities inspired by Go's reflect.</p> <p>Reflect exposes function-style APIs to inspect values and types at runtime. It represents a Type and a Value as Harneet maps, so you can pass them around and inspect their content.</p>"},{"location":"stdlib/reflect/#overview","title":"Overview","text":"<ul> <li>Values are Harneet <code>core.Object</code>s.</li> <li><code>Type</code> is a map with at least keys: <code>name</code> (string), <code>kind</code> (string). Struct types also include <code>fields</code> (array of field names).</li> <li><code>Value</code> is a map with keys: <code>value</code> (any), <code>type</code> (Type).</li> </ul>"},{"location":"stdlib/reflect/#functions","title":"Functions","text":"<ul> <li> <p><code>reflect.TypeOf(value any) Type</code>   Returns a <code>Type</code> map describing the value.</p> </li> <li> <p><code>reflect.ValueOf(value any) Value</code>   Returns a <code>Value</code> map wrapping the value with its <code>Type</code>.</p> </li> <li> <p><code>reflect.KindOf(value any) string</code>   Returns the basic kind of a value: <code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code>, <code>array</code>, <code>map</code>, <code>struct</code>, <code>tuple</code>, <code>nil</code>, <code>error</code>.</p> </li> <li> <p><code>reflect.TypeName(t Type) string</code>   Returns <code>t</code>'s <code>name</code>.</p> </li> <li> <p><code>reflect.TypeKind(t Type) string</code>   Returns <code>t</code>'s <code>kind</code>.</p> </li> <li> <p><code>reflect.TypeString(t Type) string</code>   Returns a readable type string (same as <code>name</code>).</p> </li> <li> <p><code>reflect.ValueType(v Value) Type</code>   Returns the <code>Type</code> contained in <code>v</code>.</p> </li> <li> <p><code>reflect.ValueInterface(v Value) any</code>   Returns the underlying value from <code>v</code>.</p> </li> <li> <p><code>reflect.ValueKind(v Value) string</code>   Returns the kind of the underlying value from <code>v</code>.</p> </li> <li> <p><code>reflect.ValueIsNil(v Value) bool</code>   True if the underlying value is <code>None</code>.</p> </li> <li> <p><code>reflect.ValueIsValid(v Value) bool</code>   True if the underlying value is not <code>None</code>.</p> </li> </ul>"},{"location":"stdlib/reflect/#kinds","title":"Kinds","text":"<p>Possible results from <code>KindOf</code>/<code>TypeKind</code>: - <code>int</code>, <code>float</code>, <code>string</code>, <code>bool</code> - <code>array</code>, <code>map</code>, <code>struct</code>, <code>tuple</code> - <code>nil</code>, <code>error</code></p>"},{"location":"stdlib/reflect/#struct-field-metadata","title":"Struct Field Metadata","text":"<p>For struct values, <code>TypeOf(structValue)</code> includes a <code>fields</code> entry with all field names.</p> <p>Example: <pre><code>import reflect\n\ntype Person struct { name string; age int }\nvar p = Person{name: \"Bob\", age: 28}\nvar pt = reflect.TypeOf(p)\n// pt[\"fields\"] might be [\"name\", \"age\"]\n</code></pre></p>"},{"location":"stdlib/reflect/#examples","title":"Examples","text":"<p>See <code>examples/reflect/basic_test.ha</code> for a runnable demo: <pre><code>import fmt\nimport reflect\n\nfmt.Println(\"=== reflect: Basic Demo ===\")\n\nvar n = 42\nfmt.Printf(\"KindOf(n): %s\\n\", reflect.KindOf(n))\nvar nt = reflect.TypeOf(n)\nfmt.Printf(\"TypeName(n): %s\\n\", reflect.TypeName(nt))\n\nvar nv = reflect.ValueOf(n)\nfmt.Printf(\"ValueKind(n): %s\\n\", reflect.ValueKind(nv))\nfmt.Printf(\"ValueIsValid(n): %v\\n\", reflect.ValueIsValid(nv))\nfmt.Printf(\"ValueInterface(n): %v\\n\", reflect.ValueInterface(nv))\n</code></pre></p>"},{"location":"stdlib/reflect/#notes","title":"Notes","text":"<ul> <li>Reflect API is function-only; there are no methods attached to Type/Value.</li> <li>Type and Value are plain maps; do not mutate their internal keys.</li> </ul>"},{"location":"stdlib/regex/","title":"Regex","text":"<p>Regular expressions using Go's RE2 engine (same syntax as Go's <code>regexp</code>). All functions return a tuple <code>(result, error)</code> following Harneet's stdlib conventions. </p>"},{"location":"stdlib/regex/#import","title":"Import","text":"<pre><code>import regex\n</code></pre>"},{"location":"stdlib/regex/#functions","title":"Functions","text":""},{"location":"stdlib/regex/#basic-pattern-matching","title":"Basic Pattern Matching","text":"<ul> <li><code>regex.Match(pattern string, s string) (boolean, error)</code></li> <li><code>regex.FindString(pattern string, s string) (string, error)</code></li> <li><code>regex.FindAllString(pattern string, s string, n int) (array, error)</code></li> <li><code>regex.FindStringIndex(pattern string, s string) (array, error)</code></li> </ul>"},{"location":"stdlib/regex/#capture-groups","title":"Capture Groups","text":"<ul> <li><code>regex.FindStringSubmatch(pattern string, s string) (array, error)</code></li> <li><code>regex.FindAllStringSubmatch(pattern string, s string, n int) (array, error)</code></li> <li><code>regex.FindStringSubmatchIndex(pattern string, s string) (array, error)</code></li> </ul>"},{"location":"stdlib/regex/#string-manipulation","title":"String Manipulation","text":"<ul> <li><code>regex.ReplaceAllString(pattern string, s string, repl string) (string, error)</code></li> <li><code>regex.Split(pattern string, s string, n int) (array, error)</code></li> </ul> <p>Notes: - Patterns use RE2 syntax (same as Go) - Escape sequences need double escaping inside strings, e.g. <code>\"\\\\d+\"</code> - Capture groups use parentheses: <code>\"(\\\\w+)@(\\\\w+\\\\.\\\\w+)\"</code> - Index 0 is the full match, index 1+ are capture groups</p>"},{"location":"stdlib/regex/#basic-examples","title":"Basic Examples","text":""},{"location":"stdlib/regex/#match","title":"Match","text":"<pre><code>import regex\nimport fmt\n\nvar matched, err = regex.Match(\"h.llo\", \"hello\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(\"matched:\", matched)\n}\n</code></pre>"},{"location":"stdlib/regex/#findstring","title":"FindString","text":"<pre><code>var fs, err = regex.FindString(\"[a-z]+\", \"Go123lang\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(\"first word:\", fs)\n}\n</code></pre>"},{"location":"stdlib/regex/#capture-groups-examples","title":"\ud83d\udd25 Capture Groups Examples","text":""},{"location":"stdlib/regex/#email-parsing-with-capture-groups","title":"Email Parsing with Capture Groups","text":"<pre><code>import regex\nimport fmt\n\n// Extract username and domain from email\nvar matches, err = regex.FindStringSubmatch(\"(\\\\w+)@(\\\\w+\\\\.\\\\w+)\", \"Contact: user@example.com\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(matches) &gt;= 3 {\n    fmt.Printf(\"Full match: %s\\n\", matches[0])    // \"user@example.com\"\n    fmt.Printf(\"Username: %s\\n\", matches[1])      // \"user\"\n    fmt.Printf(\"Domain: %s\\n\", matches[2])        // \"example.com\"\n}\n</code></pre>"},{"location":"stdlib/regex/#phone-number-extraction","title":"Phone Number Extraction","text":"<pre><code>import regex\nimport fmt\n\n// Extract all phone numbers with area codes\nvar text = \"Call 123-456-7890 or 987-654-3210\"\nvar phoneMatches, err = regex.FindAllStringSubmatch(\"(\\\\d{3})-(\\\\d{3})-(\\\\d{4})\", text, -1)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    for i, match in phoneMatches {\n        fmt.Printf(\"Phone %d: %s\\n\", i+1, match[0])     // Full number\n        fmt.Printf(\"  Area: %s\\n\", match[1])            // Area code\n        fmt.Printf(\"  Exchange: %s\\n\", match[2])        // Exchange\n        fmt.Printf(\"  Number: %s\\n\", match[3])          // Last 4 digits\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#url-parsing","title":"URL Parsing","text":"<pre><code>import regex\nimport fmt\n\n// Parse URL components\nvar url = \"https://api.example.com:8080/v1/users\"\nvar matches, err = regex.FindStringSubmatch(\"(\\\\w+)://([^:/]+)(:(\\\\d+))?(/.*)?\", url)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(matches) &gt;= 3 {\n    fmt.Printf(\"Protocol: %s\\n\", matches[1])     // \"https\"\n    fmt.Printf(\"Host: %s\\n\", matches[2])         // \"api.example.com\"\n    if matches[4] != \"\" {\n        fmt.Printf(\"Port: %s\\n\", matches[4])     // \"8080\"\n    }\n    if matches[5] != \"\" {\n        fmt.Printf(\"Path: %s\\n\", matches[5])     // \"/v1/users\"\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#date-format-parsing","title":"Date Format Parsing","text":"<pre><code>import regex\nimport fmt\n\n// Parse different date formats\nvar dates = [\"2024-09-25\", \"09/25/2024\", \"September 25, 2024\"]\nvar patterns = [\n    {\"pattern\": \"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\", \"name\": \"ISO\"},\n    {\"pattern\": \"(\\\\d{2})/(\\\\d{2})/(\\\\d{4})\", \"name\": \"US\"},\n    {\"pattern\": \"(\\\\w+)\\\\s+(\\\\d{1,2}),\\\\s+(\\\\d{4})\", \"name\": \"Long\"}\n]\n\nfor date in dates {\n    fmt.Printf(\"Parsing: %s\\n\", date)\n    for pattern in patterns {\n        var matches, err = regex.FindStringSubmatch(pattern[\"pattern\"], date)\n        if err == None and len(matches) &gt;= 4 {\n            fmt.Printf(\"  %s format: %s/%s/%s\\n\", \n                      pattern[\"name\"], matches[1], matches[2], matches[3])\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#log-entry-parsing","title":"Log Entry Parsing","text":"<pre><code>import regex\nimport fmt\n\n// Parse structured log entries\nvar logEntry = \"2024-09-25 14:30:15 [INFO] User login successful for user123\"\nvar matches, err = regex.FindStringSubmatch(\"(\\\\d{4}-\\\\d{2}-\\\\d{2})\\\\s+(\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\s+\\\\[(\\\\w+)\\\\]\\\\s+(.*)\", logEntry)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(matches) &gt;= 5 {\n    fmt.Printf(\"Date: %s\\n\", matches[1])         // \"2024-09-25\"\n    fmt.Printf(\"Time: %s\\n\", matches[2])         // \"14:30:15\"\n    fmt.Printf(\"Level: %s\\n\", matches[3])        // \"INFO\"\n    fmt.Printf(\"Message: %s\\n\", matches[4])      // \"User login successful for user123\"\n}\n</code></pre>"},{"location":"stdlib/regex/#position-tracking-with-findstringsubmatchindex","title":"Position Tracking with FindStringSubmatchIndex","text":"<p>Harneet does not support slicing strings with <code>text[a:b]</code> syntax. Use capture groups (strings) directly, or print indices for reference.</p> <p>Working approach using capture groups (strings):</p> <pre><code>import regex\nimport fmt\n\nvar text = \"The price is $123.45\"\nvar matches, err = regex.FindStringSubmatch(\"\\\\$(\\\\d+)\\\\.(\\\\d+)\", text)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(matches) &gt;= 3 {\n    fmt.Printf(\"Full match: '%s'\\n\", matches[0])   // \"$123.45\"\n    fmt.Printf(\"Dollars: '%s'\\n\", matches[1])     // \"123\"\n    fmt.Printf(\"Cents: '%s'\\n\", matches[2])       // \"45\"\n}\n</code></pre> <p>If you still need byte indices for integration or tooling, you can print them like this:</p> <pre><code>import regex\nimport fmt\n\nvar text = \"The price is $123.45\"\nvar idx, err = regex.FindStringSubmatchIndex(\"\\\\$(\\\\d+)\\\\.(\\\\d+)\", text)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(idx) &gt;= 6 {\n    fmt.Printf(\"Full match bytes:   [%d:%d]\\n\", idx[0], idx[1])\n    fmt.Printf(\"Dollars group bytes: [%d:%d]\\n\", idx[2], idx[3])\n    fmt.Printf(\"Cents group bytes:   [%d:%d]\\n\", idx[4], idx[5])\n}\n</code></pre>"},{"location":"stdlib/regex/#unicode-safe-slicing-from-regex-indices","title":"Unicode-safe slicing from regex indices","text":"<p>If your text may contain non-ASCII characters, convert byte indices to rune indices and then slice safely:</p> <pre><code>import regex\nimport strings\nimport fmt\n\nvar text = \"Price: $\uff11\uff12\uff13.\uff14\uff15\"  // full-width digits to illustrate multibyte\nvar idx, err = regex.FindStringSubmatchIndex(\"\\\\$(.+)\\\\.(.+)\", text)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else if len(idx) &gt;= 2 {\n    // Convert full match byte range to rune range\n    var rr, rerr = strings.ByteRangeToRuneRange(text, idx[0], idx[1])\n    if rerr == None {\n        var full, serr = strings.Substring(text, rr[0], rr[1])\n        if serr == None {\n            fmt.Printf(\"Full (rune-safe): '%s'\\n\", full)\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"stdlib/regex/#data-validation","title":"Data Validation","text":"<pre><code>import regex\nimport fmt\n\nfunction validateEmail(email string) bool {\n    var matches, err = regex.FindStringSubmatch(\"^([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})$\", email)\n    return err == None and len(matches) &gt;= 3\n}\n\nfunction extractEmailParts(email string) map {\n    var matches, err = regex.FindStringSubmatch(\"^([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})$\", email)\n    if err != None or len(matches) &lt; 3 {\n        return None\n    }\n\n    return {\n        \"username\": matches[1],\n        \"domain\": matches[2],\n        \"valid\": true\n    }\n}\n\n// Usage\nvar email = \"user.name+tag@example.co.uk\"\nif validateEmail(email) {\n    var parts = extractEmailParts(email)\n    fmt.Printf(\"Valid email - Username: %s, Domain: %s\\n\", \n              parts[\"username\"], parts[\"domain\"])\n}\n</code></pre>"},{"location":"stdlib/regex/#configuration-parsing","title":"Configuration Parsing","text":"<pre><code>import regex\nimport fmt\n\nfunction parseConfigLine(line string) map {\n    // Parse key=value or key=\"quoted value\"\n    var matches, err = regex.FindStringSubmatch(\"^\\\\s*(\\\\w+)\\\\s*=\\\\s*(?:\\\"([^\\\"]*)\\\"|([^\\\\s#]+))\", line)\n    if err != None or len(matches) &lt; 4 {\n        return None\n    }\n\n    var value = matches[2]  // Quoted value\n    if value == \"\" {\n        value = matches[3]  // Unquoted value\n    }\n\n    return {\n        \"key\": matches[1],\n        \"value\": value\n    }\n}\n\n// Usage\nvar configLines = [\n    \"port=8080\",\n    \"host=\\\"localhost\\\"\",\n    \"debug=true\"\n]\n\nfor line in configLines {\n    var config = parseConfigLine(line)\n    if config != None {\n        fmt.Printf(\"%s = %s\\n\", config[\"key\"], config[\"value\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#http-header-parsing","title":"HTTP Header Parsing","text":"<pre><code>import regex\nimport fmt\n\nfunction parseContentType(header string) map {\n    // Parse Content-Type: text/html; charset=utf-8\n    var matches, err = regex.FindStringSubmatch(\"^([^/]+)/([^;\\\\s]+)(?:;\\\\s*charset=([^;\\\\s]+))?\", header)\n    if err != None or len(matches) &lt; 3 {\n        return None\n    }\n\n    return {\n        \"type\": matches[1],\n        \"subtype\": matches[2],\n        \"charset\": matches[3]\n    }\n}\n\n// Usage for HTTP module integration\nvar contentType = \"application/json; charset=utf-8\"\nvar parsed = parseContentType(contentType)\nif parsed != None {\n    fmt.Printf(\"Type: %s/%s, Charset: %s\\n\", \n              parsed[\"type\"], parsed[\"subtype\"], parsed[\"charset\"])\n}\n</code></pre>"},{"location":"stdlib/regex/#basic-pattern-matching-examples","title":"Basic Pattern Matching Examples","text":""},{"location":"stdlib/regex/#findallstring","title":"FindAllString","text":"<pre><code>var all, err = regex.FindAllString(\"[a-z]+\", \"go is fun\", -1)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(all)  // [\"go\", \"is\", \"fun\"]\n}\n</code></pre>"},{"location":"stdlib/regex/#findstringindex","title":"FindStringIndex","text":"<pre><code>var idx, err = regex.FindStringIndex(\"foo\", \"xxfooYY\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(idx)  // [2, 5]\n}\n</code></pre>"},{"location":"stdlib/regex/#replaceallstring","title":"ReplaceAllString","text":"<pre><code>var out, err = regex.ReplaceAllString(\"\\\\d+\", \"abc123xyz456\", \"#\")\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(out)  // \"abc#xyz#\"\n}\n</code></pre>"},{"location":"stdlib/regex/#split","title":"Split","text":"<pre><code>var parts, err = regex.Split(\"\\\\s+\", \"a   b c\", -1)\nif err != None {\n    fmt.Println(\"error:\", err)\n} else {\n    fmt.Println(parts)  // [\"a\", \"b\", \"c\"]\n}\n</code></pre>"},{"location":"stdlib/regex/#function-reference","title":"Function Reference","text":""},{"location":"stdlib/regex/#basic-functions","title":"Basic Functions","text":"Function Description Returns <code>Match(pattern, s)</code> Test if pattern matches string <code>(boolean, error)</code> <code>FindString(pattern, s)</code> Find first match <code>(string, error)</code> <code>FindAllString(pattern, s, n)</code> Find all matches <code>(array, error)</code> <code>FindStringIndex(pattern, s)</code> Find position of first match <code>(array, error)</code>"},{"location":"stdlib/regex/#capture-group-functions","title":"Capture Group Functions","text":"Function Description Returns <code>FindStringSubmatch(pattern, s)</code> Extract capture groups from first match <code>(array, error)</code> <code>FindAllStringSubmatch(pattern, s, n)</code> Extract capture groups from all matches <code>(array, error)</code> <code>FindStringSubmatchIndex(pattern, s)</code> Get positions of capture groups <code>(array, error)</code>"},{"location":"stdlib/regex/#string-manipulation_1","title":"String Manipulation","text":"Function Description Returns <code>ReplaceAllString(pattern, s, repl)</code> Replace all matches <code>(string, error)</code> <code>Split(pattern, s, n)</code> Split string by pattern <code>(array, error)</code>"},{"location":"stdlib/regex/#common-patterns","title":"Common Patterns","text":""},{"location":"stdlib/regex/#email-validation","title":"Email Validation","text":"<pre><code>var isValidEmail = function(email string) bool {\n    var matches, err = regex.FindStringSubmatch(\"^([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})$\", email)\n    return err == None and len(matches) &gt;= 3\n}\n</code></pre>"},{"location":"stdlib/regex/#phone-number-formats","title":"Phone Number Formats","text":"<pre><code>// US phone numbers: (555) 123-4567 or 555-123-4567\nvar phonePattern = \"(?:\\\\((\\\\d{3})\\\\)\\\\s+|)(\\\\d{3})-(\\\\d{4})\"\n</code></pre>"},{"location":"stdlib/regex/#url-components","title":"URL Components","text":"<pre><code>// Extract protocol, host, port, path from URLs\nvar urlPattern = \"(https?)://([^:/]+)(?::(\\\\d+))?(/.*)?(?:\\\\?(.*))?\"\n</code></pre>"},{"location":"stdlib/regex/#date-formats","title":"Date Formats","text":"<pre><code>var isoDate = \"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\"           // 2024-09-25\nvar usDate = \"(\\\\d{2})/(\\\\d{2})/(\\\\d{4})\"           // 09/25/2024\nvar longDate = \"(\\\\w+)\\\\s+(\\\\d{1,2}),\\\\s+(\\\\d{4})\"  // September 25, 2024\n</code></pre>"},{"location":"stdlib/regex/#log-parsing","title":"Log Parsing","text":"<pre><code>// Parse log entries: 2024-09-25 14:30:15 [ERROR] Message\nvar logPattern = \"(\\\\d{4}-\\\\d{2}-\\\\d{2})\\\\s+(\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\s+\\\\[(\\\\w+)\\\\]\\\\s+(.*)\"\n</code></pre>"},{"location":"stdlib/regex/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/regex/#1-always-handle-errors","title":"1. Always Handle Errors","text":"<pre><code>var matches, err = regex.FindStringSubmatch(pattern, text)\nif err != None {\n    fmt.Printf(\"Regex error: %s\\n\", err)\n    return\n}\n</code></pre>"},{"location":"stdlib/regex/#2-use-raw-strings-for-complex-patterns","title":"2. Use Raw Strings for Complex Patterns","text":"<pre><code>// Easier to read and maintain\nvar emailPattern = \"([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})\"\n</code></pre>"},{"location":"stdlib/regex/#3-validate-before-processing","title":"3. Validate Before Processing","text":"<pre><code>var matches, err = regex.FindStringSubmatch(pattern, text)\nif err != None or len(matches) &lt; expectedGroups {\n    // Handle invalid input\n    return\n}\n</code></pre>"},{"location":"stdlib/regex/#4-use-descriptive-variable-names","title":"4. Use Descriptive Variable Names","text":"<pre><code>var emailMatches, _ = regex.FindStringSubmatch(emailPattern, userInput)\nvar username = emailMatches[1]\nvar domain = emailMatches[2]\n</code></pre>"},{"location":"stdlib/regex/#error-handling","title":"Error Handling","text":"<pre><code>var bad, err = regex.Match(\"(\", \"test\")\nif err != None {\n    fmt.Println(\"got expected error:\", err)\n}\n</code></pre> <p>Common regex errors: - Invalid syntax: Unclosed groups, invalid escape sequences - Compilation errors: Malformed patterns, unsupported features - Runtime errors: Pattern too complex, stack overflow</p>"},{"location":"stdlib/regex/#performance-tips","title":"Performance Tips","text":""},{"location":"stdlib/regex/#1-compile-once-use-many-times","title":"1. Compile Once, Use Many Times","text":"<pre><code>// Good: Reuse the same pattern\nvar emailPattern = \"([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})\"\n\nfunction validateEmails(emails array) {\n    for email in emails {\n        var matches, _ = regex.FindStringSubmatch(emailPattern, email)\n        // Process matches...\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#2-use-specific-patterns","title":"2. Use Specific Patterns","text":"<pre><code>// Better: More specific\nvar phonePattern = \"\\\\d{3}-\\\\d{3}-\\\\d{4}\"\n\n// Avoid: Too general\nvar badPattern = \".*-.*-.*\"\n</code></pre>"},{"location":"stdlib/regex/#3-limit-backtracking","title":"3. Limit Backtracking","text":"<pre><code>// Good: Non-greedy quantifiers when appropriate\nvar htmlTag = \"&lt;(\\\\w+).*?&gt;\"\n\n// Can be slow: Excessive backtracking\nvar slowPattern = \"(a+)+b\"\n</code></pre>"},{"location":"stdlib/regex/#integration-examples","title":"Integration Examples","text":""},{"location":"stdlib/regex/#with-http-module","title":"With HTTP Module","text":"<pre><code>import http\nimport regex\nimport fmt\n\nfunction parseUserAgent(userAgent string) map {\n    var pattern = \"([^/]+)/([\\\\d\\\\.]+)\\\\s*\\\\(([^)]+)\\\\)\"\n    var matches, err = regex.FindStringSubmatch(pattern, userAgent)\n\n    if err != None or len(matches) &lt; 4 {\n        return None\n    }\n\n    return {\n        \"browser\": matches[1],\n        \"version\": matches[2],\n        \"platform\": matches[3]\n    }\n}\n\n// Usage in HTTP handler\nfunction handleRequest(request map, response map) {\n    var userAgent = request[\"headers\"][\"User-Agent\"]\n    var parsed = parseUserAgent(userAgent)\n\n    if parsed != None {\n        fmt.Printf(\"Browser: %s %s on %s\\n\", \n                  parsed[\"browser\"], parsed[\"version\"], parsed[\"platform\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/regex/#with-json-module","title":"With JSON Module","text":"<pre><code>import json\nimport regex\nimport fmt\n\nfunction extractDataFromText(text string) map {\n    var emailPattern = \"([\\\\w\\\\._%+-]+)@([\\\\w\\\\.-]+\\\\.[A-Za-z]{2,})\"\n    var phonePattern = \"(\\\\d{3})-(\\\\d{3})-(\\\\d{4})\"\n\n    var emails, _ = regex.FindAllStringSubmatch(emailPattern, text, -1)\n    var phones, _ = regex.FindAllStringSubmatch(phonePattern, text, -1)\n\n    var result = {\n        \"emails\": [],\n        \"phones\": []\n    }\n\n    // Process emails\n    for email in emails {\n        var emailData = {\"full\": email[0], \"username\": email[1], \"domain\": email[2]}\n        result[\"emails\"] = append(result[\"emails\"], emailData)\n    }\n\n    // Process phones  \n    for phone in phones {\n        var phoneData = {\"full\": phone[0], \"area\": phone[1], \"exchange\": phone[2], \"number\": phone[3]}\n        result[\"phones\"] = append(result[\"phones\"], phoneData)\n    }\n\n    return result\n}\n</code></pre>"},{"location":"stdlib/regex/#with-cast-module","title":"With Cast Module","text":"<pre><code>import cast\nimport regex\nimport fmt\n\nfunction parseConfigValue(line string) map {\n    var pattern = \"^\\\\s*(\\\\w+)\\\\s*=\\\\s*([\\\"']?)([^\\\"'\\\\n]*?)\\\\2\\\\s*$\"\n    var matches, err = regex.FindStringSubmatch(pattern, line)\n\n    if err != None or len(matches) &lt; 4 {\n        return None\n    }\n\n    var key = matches[1]\n    var value = matches[3]\n\n    // Try to cast to appropriate type\n    var intValue, intErr = cast.ToInt(value)\n    if intErr == None {\n        return {\"key\": key, \"value\": intValue, \"type\": \"int\"}\n    }\n\n    var boolValue, boolErr = cast.ToBool(value)\n    if boolErr == None {\n        return {\"key\": key, \"value\": boolValue, \"type\": \"bool\"}\n    }\n\n    return {\"key\": key, \"value\": value, \"type\": \"string\"}\n}\n</code></pre>"},{"location":"stdlib/regex/#regular-expression-syntax","title":"Regular Expression Syntax","text":"<p>Harneet uses Go's RE2 syntax. Key features:</p>"},{"location":"stdlib/regex/#character-classes","title":"Character Classes","text":"<ul> <li><code>\\d</code> - Digits (0-9)</li> <li><code>\\w</code> - Word characters (a-z, A-Z, 0-9, _)</li> <li><code>\\s</code> - Whitespace</li> <li><code>[abc]</code> - Character set</li> <li><code>[^abc]</code> - Negated character set</li> <li><code>[a-z]</code> - Character range</li> </ul>"},{"location":"stdlib/regex/#quantifiers","title":"Quantifiers","text":"<ul> <li><code>*</code> - Zero or more</li> <li><code>+</code> - One or more</li> <li><code>?</code> - Zero or one</li> <li><code>{n}</code> - Exactly n</li> <li><code>{n,}</code> - n or more</li> <li><code>{n,m}</code> - Between n and m</li> </ul>"},{"location":"stdlib/regex/#anchors","title":"Anchors","text":"<ul> <li><code>^</code> - Start of string</li> <li><code>$</code> - End of string</li> <li><code>\\b</code> - Word boundary</li> </ul>"},{"location":"stdlib/regex/#groups","title":"Groups","text":"<ul> <li><code>(...)</code> - Capture group</li> <li><code>(?:...)</code> - Non-capture group</li> <li><code>(?P&lt;name&gt;...)</code> - Named group (not yet supported)</li> </ul>"},{"location":"stdlib/regex/#escape-sequences","title":"Escape Sequences","text":"<p>Remember to double-escape in Harneet strings: - <code>\\\\d</code> for <code>\\d</code> - <code>\\\\\\\\</code> for <code>\\\\</code> - <code>\\\\\"</code> for <code>\"</code></p>"},{"location":"stdlib/regex/#limitations","title":"Limitations","text":"<p>Current limitations in Harneet's regex implementation: - No named capture groups yet - No lookahead/lookbehind assertions - No conditional expressions - No recursive patterns</p>"},{"location":"stdlib/regex/#see-also","title":"See Also","text":"<ul> <li>HTTP Module - For parsing HTTP headers and URLs</li> <li>JSON Module - For processing extracted data</li> <li>Cast Module - For type conversion of matched strings</li> <li>String Module - For additional string processing</li> </ul> <p>Note: All regex functions follow Harneet's standard <code>(result, error)</code> tuple return pattern for consistent error handling.</p>"},{"location":"stdlib/strings/","title":"<code>strings</code> Module","text":"<p>The <code>strings</code> module provides functions for string manipulation.</p>"},{"location":"stdlib/strings/#slicing-strings","title":"Slicing strings","text":"<p>Strings in Harneet support Go-like slicing using the <code>s[a:b]</code> syntax (and the shorthand forms <code>[:b]</code>, <code>[a:]</code>, and <code>[:]</code>).</p> <p>Rules and semantics: - Indices <code>a</code> and <code>b</code> must be integers. The type checker validates this. - Bounds are clamped to the valid range <code>[0, len(s)]</code>. - Half-open interval: <code>a</code> is inclusive, <code>b</code> is exclusive. - If <code>a &gt; b</code>, the result is an empty string. - Slicing is currently byte-based. If your strings contain multi-byte UTF-8 characters, make sure your indices align with character boundaries to avoid splitting a rune. Rune-aware slicing may be added in the future.</p> <p>Examples: <pre><code>import fmt\n\nvar s = \"abcdef\"\nfmt.Println(s[0:3]) // \"abc\"\nfmt.Println(s[2:])  // \"cdef\"\nfmt.Println(s[:])   // \"abcdef\"\n</code></pre></p> <p>See array and typed-array slicing semantics: arrays module documentation.</p>"},{"location":"stdlib/strings/#functions","title":"Functions","text":""},{"location":"stdlib/strings/#lenstring","title":"<code>Len(string)</code>","text":"<p>Returns the length of a string.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(integer, error)</code>: The length of the string, or an error if the argument is not a string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar length, err = strings.Len(\"hello\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Length:\", length) // Output: Length: 5\n}\n</code></pre></p>"},{"location":"stdlib/strings/#upperstring","title":"<code>Upper(string)</code>","text":"<p>Converts a string to uppercase.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(string, error)</code>: The uppercase version of the string, or an error if the argument is not a string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar upper, err = strings.Upper(\"hello\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Uppercase:\", upper) // Output: Uppercase: HELLO\n}\n</code></pre></p>"},{"location":"stdlib/strings/#lowerstring","title":"<code>Lower(string)</code>","text":"<p>Converts a string to lowercase.</p> <p>Parameters: - <code>string</code>: A string.</p> <p>Returns: - <code>(string, error)</code>: The lowercase version of the string, or an error if the argument is not a string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar lower, err = strings.Lower(\"HELLO\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Lowercase:\", lower) // Output: Lowercase: hello\n}\n</code></pre></p>"},{"location":"stdlib/strings/#containsstring-substring","title":"<code>Contains(string, substring)</code>","text":"<p>Checks if a string contains a substring.</p> <p>Parameters: - <code>string</code>: The string to search in. - <code>substring</code>: The substring to search for.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if the substring is found, <code>false</code> otherwise. Returns an error if the arguments are not strings.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar found, err = strings.Contains(\"hello world\", \"world\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Found:\", found) // Output: Found: true\n}\n</code></pre></p>"},{"location":"stdlib/strings/#replacestring-old-new","title":"<code>Replace(string, old, new)</code>","text":"<p>Replaces all occurrences of a substring with a new string.</p> <p>Parameters: - <code>string</code>: The original string. - <code>old</code>: The substring to be replaced. - <code>new</code>: The new string to replace with.</p> <p>Returns: - <code>(string, error)</code>: A new string with all occurrences of <code>old</code> replaced by <code>new</code>. Returns an error if the arguments are not strings.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar replaced, err = strings.Replace(\"hello world\", \"world\", \"Harneet\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Replaced:\", replaced) // Output: Replaced: hello Harneet\n}\n</code></pre></p>"},{"location":"stdlib/strings/#splitstring-separator","title":"<code>Split(string, separator)</code>","text":"<p>Splits a string into an array of substrings.</p> <p>Parameters: - <code>string</code>: The string to be split. - <code>separator</code>: The separator to split by.</p> <p>Returns: - <code>(array, error)</code>: An array of strings. Returns an error if the arguments are not strings.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar parts, err = strings.Split(\"a,b,c\", \",\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Parts:\", parts) // Output: Parts: [a, b, c]\n}\n</code></pre></p>"},{"location":"stdlib/strings/#tointstring","title":"<code>ToInt(string)</code>","text":"<p>Parses a string to an integer.</p> <p>Parameters: - <code>string</code>: The string to be parsed.</p> <p>Returns: - <code>(integer, error)</code>: The integer value, or an error if the string cannot be parsed as an integer.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar number, err = strings.ToInt(\"42\")\nif err != None {\n    fmt.Println(\"Error:\", err)\n} else {\n    fmt.Println(\"Number:\", number) // Output: Number: 42\n}\n\nvar invalid, err2 = strings.ToInt(\"hello\")\nif err2 != None {\n    fmt.Println(\"Error:\", err2) // Output: Error: cannot convert 'hello' to int\n}\n</code></pre></p>"},{"location":"stdlib/strings/#hasprefixstring-prefix","title":"<code>HasPrefix(string, prefix)</code>","text":"<p>Checks whether a string begins with the given prefix.</p> <p>Parameters: - <code>string</code>: The string to test. - <code>prefix</code>: The prefix to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if <code>string</code> starts with <code>prefix</code>, else <code>false</code>.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar ok, err = strings.HasPrefix(\"foobar\", \"foo\")\nfmt.Println(ok) // true\n</code></pre></p>"},{"location":"stdlib/strings/#hassuffixstring-suffix","title":"<code>HasSuffix(string, suffix)</code>","text":"<p>Checks whether a string ends with the given suffix.</p> <p>Parameters: - <code>string</code>: The string to test. - <code>suffix</code>: The suffix to check.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if <code>string</code> ends with <code>suffix</code>, else <code>false</code>.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar ok, err = strings.HasSuffix(\"foobar\", \"bar\")\nfmt.Println(ok) // true\n</code></pre></p>"},{"location":"stdlib/strings/#indexstring-substr","title":"<code>Index(string, substr)</code>","text":"<p>Returns the index of the first occurrence of <code>substr</code> in <code>string</code>, or -1 if not present.</p> <p>Parameters: - <code>string</code>: The string to search. - <code>substr</code>: The substring to find.</p> <p>Returns: - <code>(integer, error)</code>: The index or -1.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar i, err = strings.Index(\"hello\", \"l\")\nfmt.Println(i) // 2\n</code></pre></p>"},{"location":"stdlib/strings/#lastindexstring-substr","title":"<code>LastIndex(string, substr)</code>","text":"<p>Returns the index of the last occurrence of <code>substr</code> in <code>string</code>, or -1 if not present.</p> <p>Parameters: - <code>string</code>: The string to search. - <code>substr</code>: The substring to find.</p> <p>Returns: - <code>(integer, error)</code>: The index or -1.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar i, err = strings.LastIndex(\"hello\", \"l\")\nfmt.Println(i) // 3\n</code></pre></p>"},{"location":"stdlib/strings/#trimstring-cutset","title":"<code>Trim(string, cutset)</code>","text":"<p>Removes all leading and trailing characters in <code>cutset</code> from <code>string</code>.</p> <p>Parameters: - <code>string</code>: The string to trim. - <code>cutset</code>: Characters to trim from both ends.</p> <p>Returns: - <code>(string, error)</code>: The trimmed string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out, err = strings.Trim(\"--hello--\", \"-\")\nfmt.Println(out) // hello\n</code></pre></p>"},{"location":"stdlib/strings/#trimspacestring","title":"<code>TrimSpace(string)</code>","text":"<p>Removes leading and trailing Unicode whitespace.</p> <p>Parameters: - <code>string</code>: The string to trim.</p> <p>Returns: - <code>(string, error)</code>: The trimmed string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out, err = strings.TrimSpace(\"  spaced  \")\nfmt.Println(out) // spaced\n</code></pre></p>"},{"location":"stdlib/strings/#trimprefixstring-prefix","title":"<code>TrimPrefix(string, prefix)</code>","text":"<p>Removes <code>prefix</code> from the start of <code>string</code> if present.</p> <p>Parameters: - <code>string</code>: The input string. - <code>prefix</code>: Prefix to remove.</p> <p>Returns: - <code>(string, error)</code>: The result string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out, err = strings.TrimPrefix(\"prefix_value\", \"prefix_\")\nfmt.Println(out) // value\n</code></pre></p>"},{"location":"stdlib/strings/#trimsuffixstring-suffix","title":"<code>TrimSuffix(string, suffix)</code>","text":"<p>Removes <code>suffix</code> from the end of <code>string</code> if present.</p> <p>Parameters: - <code>string</code>: The input string. - <code>suffix</code>: Suffix to remove.</p> <p>Returns: - <code>(string, error)</code>: The result string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out, err = strings.TrimSuffix(\"value_suffix\", \"_suffix\")\nfmt.Println(out) // value\n</code></pre></p>"},{"location":"stdlib/strings/#repeatstring-count","title":"<code>Repeat(string, count)</code>","text":"<p>Returns a new string consisting of <code>count</code> copies of <code>string</code>.</p> <p>Parameters: - <code>string</code>: The string to repeat. - <code>count</code>: Number of repetitions (non-negative).</p> <p>Returns: - <code>(string, error)</code>: The repeated string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out, err = strings.Repeat(\"ha\", 3)\nfmt.Println(out) // hahaha\n</code></pre></p>"},{"location":"stdlib/strings/#countstring-substr","title":"<code>Count(string, substr)</code>","text":"<p>Counts non-overlapping instances of <code>substr</code> in <code>string</code>.</p> <p>Parameters: - <code>string</code>: The string to search. - <code>substr</code>: The substring to count.</p> <p>Returns: - <code>(integer, error)</code>: The count.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar c, err = strings.Count(\"banana\", \"na\")\nfmt.Println(c) // 2\n</code></pre></p>"},{"location":"stdlib/strings/#joinarray-sep","title":"<code>Join(array, sep)</code>","text":"<p>Joins an array of strings using the separator <code>sep</code>.</p> <p>Parameters: - <code>array</code>: Array of strings. - <code>sep</code>: Separator string.</p> <p>Returns: - <code>(string, error)</code>: The joined string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar parts = [\"go\", \"is\", \"fun\"]\nvar out, err = strings.Join(parts, \" \")\nfmt.Println(out) // go is fun\n</code></pre></p>"},{"location":"stdlib/strings/#fieldsstring","title":"<code>Fields(string)</code>","text":"<p>Splits a string around runs of Unicode whitespace.</p> <p>Parameters: - <code>string</code>: Input string.</p> <p>Returns: - <code>(array, error)</code>: Array of fields.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar arr, err = strings.Fields(\" a  b\\t c\\n\")\nfmt.Println(arr) // [a, b, c]\n</code></pre></p>"},{"location":"stdlib/strings/#replacenstring-old-new-n","title":"<code>ReplaceN(string, old, new, n)</code>","text":"<p>Replaces up to <code>n</code> non-overlapping instances of <code>old</code> with <code>new</code>. If <code>n &lt; 0</code>, replaces all.</p> <p>Parameters: - <code>string</code>: Source string. - <code>old</code>: Substring to replace. - <code>new</code>: Replacement string. - <code>n</code>: Maximum number of replacements (<code>-1</code> for all).</p> <p>Returns: - <code>(string, error)</code>: The result string.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar out1, err1 = strings.ReplaceN(\"aaaa\", \"a\", \"b\", 2)\nfmt.Println(out1) // bbaa\n\nvar out2, err2 = strings.ReplaceN(\"aaaa\", \"a\", \"b\", -1)\nfmt.Println(out2) // bbbb\n</code></pre></p>"},{"location":"stdlib/strings/#equalfolda-b","title":"<code>EqualFold(a, b)</code>","text":"<p>Reports whether <code>a</code> and <code>b</code> are equal under simple Unicode case-folding.</p> <p>Parameters: - <code>a</code>: First string. - <code>b</code>: Second string.</p> <p>Returns: - <code>(boolean, error)</code>: <code>true</code> if equal ignoring case.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar ok, err = strings.EqualFold(\"GoLang\", \"golang\")\nfmt.Println(ok) // true\n</code></pre></p>"},{"location":"stdlib/strings/#comparea-b","title":"<code>Compare(a, b)</code>","text":"<p>Lexicographically compares two strings.</p> <p>Parameters: - <code>a</code>: First string. - <code>b</code>: Second string.</p> <p>Returns: - <code>(integer, error)</code>: <code>0</code> if equal, <code>-1</code> if <code>a &lt; b</code>, <code>+1</code> if <code>a &gt; b</code>.</p> <p>Example: <pre><code>import fmt\nimport strings\n\nvar c1, err1 = strings.Compare(\"abc\", \"abd\")\nfmt.Println(c1) // -1\n\nvar c2, err2 = strings.Compare(\"same\", \"same\")\nfmt.Println(c2) // 0\n</code></pre></p>"},{"location":"stdlib/structs/","title":"Structs in Harneet","text":"<p>Harneet supports Go-like struct types for creating custom data structures with named fields, methods, and seamless integration with maps and JSON.</p>"},{"location":"stdlib/structs/#struct-definitions","title":"Struct Definitions","text":"<p>Define struct types using the <code>type</code> keyword:</p> <pre><code>type Person struct {\n    name string\n    age int\n}\n\ntype Point struct {\n    x int\n    y int\n}\n\ntype Employee struct {\n    id int\n    name string\n    department string\n    salary float64\n    active bool\n}\n</code></pre>"},{"location":"stdlib/structs/#struct-literals","title":"Struct Literals","text":"<p>Create struct instances using struct literals:</p>"},{"location":"stdlib/structs/#single-line-literals","title":"Single-line Literals","text":"<pre><code>var person1 = Person{name: \"Alice\", age: 30}\nvar point1 = Point{x: 10, y: 20}\n</code></pre>"},{"location":"stdlib/structs/#multi-line-literals","title":"Multi-line Literals","text":"<pre><code>var employee = Employee{\n    id: 1001,\n    name: \"John Smith\",\n    department: \"Engineering\",\n    salary: 75000.0,\n    active: true\n}\n</code></pre>"},{"location":"stdlib/structs/#field-access","title":"Field Access","text":"<p>Access struct fields using dot notation:</p> <pre><code>var person = Person{name: \"Alice\", age: 30}\n\n// Access individual fields\nvar name = person.name     // \"Alice\"\nvar age = person.age       // 30\n\nfmt.Printf(\"Name: %s, Age: %d\\n\", name, age)\n</code></pre>"},{"location":"stdlib/structs/#struct-methods","title":"Struct Methods","text":"<p>Define methods on struct types using receiver syntax:</p>"},{"location":"stdlib/structs/#method-definition","title":"Method Definition","text":"<pre><code>type Person struct {\n    name string\n    age int\n}\n\n// Method with no return value\nfunc (p Person) greet() {\n    fmt.Printf(\"Hello, my name is %s\\n\", p.name)\n}\n\n// Method with return value\nfunc (p Person) getAge() int {\n    return p.age\n}\n\n// Method with boolean return\nfunc (p Person) isAdult() bool {\n    return p.age &gt;= 18\n}\n</code></pre>"},{"location":"stdlib/structs/#method-calls","title":"Method Calls","text":"<pre><code>var person = Person{name: \"Alice\", age: 30}\n\n// Call methods on struct instances\nperson.greet()                    // \"Hello, my name is Alice\"\nvar age = person.getAge()         // 30\nvar adult = person.isAdult()      // true\n</code></pre>"},{"location":"stdlib/structs/#complex-methods","title":"Complex Methods","text":"<pre><code>type Rectangle struct {\n    width int\n    height int\n}\n\nfunc (r Rectangle) area() int {\n    return r.width * r.height\n}\n\nfunc (r Rectangle) perimeter() int {\n    return 2 * (r.width + r.height)\n}\n\nfunc (r Rectangle) describe() {\n    fmt.Printf(\"Rectangle: %dx%d (area=%d, perimeter=%d)\\n\", \n        r.width, r.height, r.area(), r.perimeter())\n}\n\nvar rect = Rectangle{width: 10, height: 5}\nrect.describe()  // \"Rectangle: 10x5 (area=50, perimeter=30)\"\n</code></pre>"},{"location":"stdlib/structs/#struct-to-map-casting","title":"Struct-to-Map Casting","text":"<p>Structs can be seamlessly converted to maps using the cast module:</p> <pre><code>import cast\n\ntype User struct {\n    id int\n    username string\n    active bool\n}\n\nvar user = User{id: 123, username: \"alice\", active: true}\n\n// Convert struct to map\nvar userMap, err = cast.ToMap(user)\nif err == None {\n    fmt.Printf(\"User as map: %s\\n\", userMap)\n    // Output: User as map: {id: 123, username: alice, active: true}\n}\n\n// Check if conversion is possible\nvar canCast, _ = cast.CanCast(user, \"map\")\nfmt.Printf(\"Can cast to map: %s\\n\", canCast)  // true\n</code></pre>"},{"location":"stdlib/structs/#json-integration","title":"JSON Integration","text":"<p>Structs integrate seamlessly with JSON through map conversion:</p> <pre><code>import cast\nimport json\n\ntype Product struct {\n    id int\n    name string\n    price float64\n    inStock bool\n}\n\nvar product = Product{\n    id: 12345,\n    name: \"Laptop Computer\",\n    price: 999.99,\n    inStock: true\n}\n\n// Struct \u2192 Map \u2192 JSON\nvar productMap, _ = cast.ToMap(product)\nvar jsonStr, _ = json.Marshal(productMap)\nfmt.Printf(\"JSON: %s\\n\", jsonStr)\n// Output: {\"id\":12345,\"name\":\"Laptop Computer\",\"price\":999.99,\"inStock\":true}\n</code></pre>"},{"location":"stdlib/structs/#typed-arrays","title":"Typed Arrays","text":"<p>Harneet supports typed arrays with a specified size and element type:</p>"},{"location":"stdlib/structs/#primitive-type-arrays","title":"Primitive Type Arrays","text":"<pre><code>var numbers = int[5]{1, 2, 3, 4, 5}\nvar names = string[3]{\"Alice\", \"Bob\", \"Charlie\"}\nvar flags = bool[2]{true, false}\nvar scores = float64[4]{95.5, 87.2, 92.8, 88.1}\n</code></pre>"},{"location":"stdlib/structs/#struct-type-arrays","title":"Struct Type Arrays","text":"<pre><code>var points = Point[3]{\n    Point{x: 0, y: 0},\n    Point{x: 10, y: 20},\n    Point{x: 30, y: 40}\n}\n\nvar people = Person[2]{\n    Person{name: \"Alice\", age: 30},\n    Person{name: \"Bob\", age: 25}\n}\n</code></pre>"},{"location":"stdlib/structs/#field-types","title":"Field Types","text":"<p>Structs support all Harneet primitive types:</p> <ul> <li><code>string</code> - Text values</li> <li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> - Integer values</li> <li><code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code> - Unsigned integers</li> <li><code>float32</code>, <code>float64</code> - Floating-point values</li> <li><code>bool</code> - Boolean values</li> </ul>"},{"location":"stdlib/structs/#type-safety","title":"Type Safety","text":"<p>Harneet enforces type safety for structs:</p>"},{"location":"stdlib/structs/#required-fields","title":"Required Fields","text":"<p>All fields must be provided in struct literals:</p> <pre><code>// \u2705 Valid - all fields provided\nvar person = Person{name: \"Alice\", age: 30}\n\n// \u274c Error - missing 'age' field\nvar person = Person{name: \"Alice\"}\n</code></pre>"},{"location":"stdlib/structs/#field-validation","title":"Field Validation","text":"<p>Only defined fields are allowed:</p> <pre><code>// \u274c Error - 'height' is not a field of Person\nvar person = Person{name: \"Alice\", age: 30, height: 170}\n</code></pre>"},{"location":"stdlib/structs/#method-validation","title":"Method Validation","text":"<p>Methods are type-checked and validated:</p> <pre><code>// \u2705 Valid method call\nvar age = person.getAge()\n\n// \u274c Error - method doesn't exist\nvar invalid = person.nonExistentMethod()\n</code></pre>"},{"location":"stdlib/structs/#zero-values","title":"Zero Values","text":"<p>Struct fields can be explicitly set to zero values:</p> <pre><code>var emptyPerson = Person{name: \"\", age: 0}\nvar emptyPoint = Point{x: 0, y: 0}\n</code></pre>"},{"location":"stdlib/structs/#advanced-examples","title":"Advanced Examples","text":""},{"location":"stdlib/structs/#complete-struct-with-methods-and-casting","title":"Complete Struct with Methods and Casting","text":"<pre><code>import fmt\nimport cast\nimport json\n\ntype Account struct {\n    id int\n    name string\n    balance float64\n    active bool\n}\n\nfunc (a Account) getBalance() float64 {\n    return a.balance\n}\n\nfunc (a Account) isActive() bool {\n    return a.active\n}\n\nfunc (a Account) getInfo() string {\n    return a.name\n}\n\nfunc (a Account) describe() {\n    fmt.Printf(\"Account %d: %s (Balance: %.2f, Active: %s)\\n\", \n        a.id, a.name, a.balance, a.active)\n}\n\nvar account = Account{\n    id: 1001,\n    name: \"Alice Johnson\",\n    balance: 2500.50,\n    active: true\n}\n\n// Use methods\naccount.describe()\nvar balance = account.getBalance()\nvar active = account.isActive()\n\n// Access fields\nvar name = account.name\nvar id = account.id\n\n// Convert to map and JSON\nvar accountMap, _ = cast.ToMap(account)\nvar accountJson, _ = json.Marshal(accountMap)\n\nfmt.Printf(\"As JSON: %s\\n\", accountJson)\n</code></pre>"},{"location":"stdlib/structs/#multiple-struct-types","title":"Multiple Struct Types","text":"<pre><code>type Customer struct {\n    id int\n    name string\n    email string\n}\n\nfunc (c Customer) getContact() string {\n    return c.email\n}\n\ntype Order struct {\n    id int\n    customerId int\n    amount float64\n    status string\n}\n\nfunc (o Order) isComplete() bool {\n    return o.status == \"completed\"\n}\n\nvar customer = Customer{id: 1, name: \"Alice\", email: \"alice@example.com\"}\nvar order = Order{id: 100, customerId: 1, amount: 99.99, status: \"completed\"}\n\n// Use methods on different types\nvar contact = customer.getContact()\nvar complete = order.isComplete()\n\n// Convert both to maps\nvar customerMap, _ = cast.ToMap(customer)\nvar orderMap, _ = cast.ToMap(order)\n</code></pre>"},{"location":"stdlib/structs/#current-capabilities","title":"Current Capabilities \u2705","text":"<p>\u2705 Struct Definitions: <code>type Name struct { field type }</code> \u2705 Struct Literals: <code>Name{field: value}</code> (single and multi-line) \u2705 Field Access: <code>struct.field</code> syntax \u2705 Methods: <code>func (receiver Type) method() { ... }</code> \u2705 Method Calls: <code>struct.method()</code> syntax \u2705 Typed Arrays: <code>type[size]{elements}</code> for all types \u2705 Struct-to-Map Casting: <code>cast.ToMap(struct)</code> \u2705 JSON Integration: Full struct \u2194 map \u2194 JSON workflow \u2705 Type Safety: Compile-time and runtime validation \u2705 Error Handling: Clear, actionable error messages  </p>"},{"location":"stdlib/structs/#future-enhancements","title":"Future Enhancements","text":"<p>The struct system is designed to be extensible for future features:</p> <ul> <li>Struct embedding for composition</li> <li>Constructor functions</li> <li>Access control modifiers (public/private)</li> <li>Interface implementations</li> <li>Pointer receivers for methods</li> <li>Map-to-struct casting</li> </ul>"},{"location":"stdlib/structs/#integration-with-other-modules","title":"Integration with Other Modules","text":""},{"location":"stdlib/structs/#cast-module","title":"Cast Module","text":"<ul> <li><code>cast.ToMap(struct)</code> - Convert struct to map</li> <li><code>cast.CanCast(struct, \"map\")</code> - Check conversion possibility</li> <li>Full type validation and error handling</li> </ul>"},{"location":"stdlib/structs/#json-module","title":"JSON Module","text":"<ul> <li>Seamless struct \u2192 map \u2192 JSON conversion</li> <li>Perfect for API responses and data serialization</li> <li>Round-trip conversion support</li> </ul>"},{"location":"stdlib/structs/#type-system","title":"Type System","text":"<ul> <li>Full compile-time type checking</li> <li>Method signature validation</li> <li>Field access validation</li> <li>Type compatibility checking</li> </ul> <p>This makes Harneet's struct system as powerful and developer-friendly as Go's, with the added benefit of seamless JSON integration and comprehensive type safety.</p>"},{"location":"stdlib/http/advanced/","title":"HTTP Advanced Features - Complete Guide with Latest Syntax","text":"<p>This document covers advanced HTTP capabilities in Harneet for enterprise-level web development. All examples use the latest tuple destructuring syntax for modern, clean code.</p>"},{"location":"stdlib/http/advanced/#range-requests","title":"Range Requests","text":"<p>Support for HTTP range requests and partial content responses.</p>"},{"location":"stdlib/http/advanced/#range-requests-with-headers","title":"Range Requests with Headers","text":"<p>Support for HTTP range requests and partial content responses for efficient file downloads and streaming.</p> <p>Examples:</p> <p>Download File in Chunks with Tuple Destructuring: <pre><code>import http\nimport fmt\n\nfunction downloadFileInChunks(url string, chunkSize int) {\n    fmt.Printf(\"\ud83d\udce5 Downloading %s in %d byte chunks\\n\", url, chunkSize)\n\n    // First, get file size with HEAD request\n    var headResponse, headErr = http.Head(url)\n    if headErr != None {\n        fmt.Printf(\"\u274c Failed to get file info: %s\\n\", headErr)\n        return\n    }\n\n    var contentLength = headResponse[\"headers\"][\"Content-Length\"]\n    fmt.Printf(\"\ud83d\udcca File size: %s bytes\\n\", contentLength)\n\n    var downloaded = 0\n    var totalSize = 10000  // Simulated file size\n\n    for downloaded &lt; totalSize {\n        var start = downloaded\n        var end = downloaded + chunkSize - 1\n        if end &gt;= totalSize {\n            end = totalSize - 1\n        }\n\n        // Create request with Range header\n        var request, _ = http.NewRequest(\"GET\", url, \"\")\n        var rangeHeader = \"bytes=\" + start + \"-\" + end\n        var rangeRequest, _ = http.SetHeader(request, \"Range\", rangeHeader)\n\n        var response, err = http.Do(rangeRequest)\n        if err != None {\n            fmt.Printf(\"\u274c Chunk download failed: %s\\n\", err)\n            return\n        }\n\n        if response[\"status\"] == 206 {  // Partial Content\n            fmt.Printf(\"\u2705 Downloaded bytes %d-%d (%d bytes)\\n\", start, end, end-start+1)\n            downloaded = end + 1\n        } else {\n            fmt.Printf(\"\u274c Server doesn't support range requests (Status: %d)\\n\", response[\"status\"])\n            return\n        }\n    }\n\n    fmt.Printf(\"\ud83c\udf89 Download complete!\\n\")\n}\n</code></pre></p> <p>Resume Interrupted Download: <pre><code>import http\nimport fmt\n\nfunction resumeDownload(url string, existingBytes int) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n    var rangeHeader = \"bytes=\" + existingBytes + \"-\"\n    var resumeRequest, _ = http.SetHeader(request, \"Range\", rangeHeader)\n\n    var response, err = http.Do(resumeRequest)\n    if err != None {\n        fmt.Printf(\"\u274c Resume failed: %s\\n\", err)\n        return\n    }\n\n    if response[\"status\"] == 206 {\n        fmt.Printf(\"\u2705 Resuming download from byte %d\\n\", existingBytes)\n    } else {\n        fmt.Printf(\"\u26a0\ufe0f  Server doesn't support resume, starting over\\n\")\n    }\n}\n</code></pre></p>"},{"location":"stdlib/http/advanced/#conditional-requests","title":"Conditional Requests","text":"<p>Support for If-Modified-Since, ETag, and other conditional headers for efficient caching.</p>"},{"location":"stdlib/http/advanced/#etag-validation","title":"ETag Validation","text":"<pre><code>import http\nimport fmt\n\n// Fetch with ETag validation\nfunction fetchWithETag(url string, cachedETag string) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n\n    if cachedETag != \"\" {\n        var conditionalRequest, _ = http.SetHeader(request, \"If-None-Match\", cachedETag)\n        var response, err = http.Do(conditionalRequest)\n\n        if err != None {\n            fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n            return\n        }\n\n        if response[\"status\"] == 304 {\n            fmt.Printf(\"\u2705 Content not modified - using cache\\n\")\n            return  // Use cached content\n        }\n    }\n\n    // Fetch new content\n    var response, err = http.Get(url)\n    if err != None {\n        fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        return\n    }\n\n    var newETag = response[\"headers\"][\"ETag\"]\n    fmt.Printf(\"\u2705 New content received - ETag: %s\\n\", newETag)\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#if-modified-since-validation","title":"If-Modified-Since Validation","text":"<pre><code>import http\nimport fmt\n\nfunction fetchIfModified(url string, lastModified string) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n\n    if lastModified != \"\" {\n        request, _ = http.SetHeader(request, \"If-Modified-Since\", lastModified)\n    }\n\n    var response, err = http.Do(request)\n    if err != None {\n        fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        return\n    }\n\n    if response[\"status\"] == 304 {\n        fmt.Printf(\"\u2705 Content not modified since %s\\n\", lastModified)\n    } else {\n        var newLastModified = response[\"headers\"][\"Last-Modified\"]\n        fmt.Printf(\"\u2705 Content updated - Last-Modified: %s\\n\", newLastModified)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#request-cancellation","title":"Request Cancellation","text":"<p>Context-based request cancellation and timeout management.</p>"},{"location":"stdlib/http/advanced/#request-with-timeout","title":"Request with Timeout","text":"<pre><code>import http\nimport fmt\n\nfunction requestWithTimeout(url string, timeoutSeconds int) {\n    fmt.Printf(\"\u23f1\ufe0f  Making request with %d second timeout\\n\", timeoutSeconds)\n\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n    // Note: In full implementation, timeout would be set on request\n\n    var response, err = http.Do(request)\n\n    if err != None {\n        if err == \"request timeout\" or err == \"context deadline exceeded\" {\n            fmt.Printf(\"\u23f0 Request timed out after %d seconds\\n\", timeoutSeconds)\n        } else {\n            fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        }\n        return\n    }\n\n    fmt.Printf(\"\u2705 Request completed within timeout - Status: %d\\n\", response[\"status\"])\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#cancellable-request-chain","title":"Cancellable Request Chain","text":"<pre><code>import http\nimport fmt\n\nfunction cancellableRequestChain(urls array, timeoutPerRequest int) {\n    fmt.Printf(\"\ud83d\udd17 Processing %d URLs with %ds timeout each\\n\", len(urls), timeoutPerRequest)\n\n    for i, url in urls {\n        fmt.Printf(\"\ud83d\udd04 Request %d/%d: %s\\n\", i+1, len(urls), url)\n\n        var response, err = http.Get(url)\n\n        if err != None {\n            fmt.Printf(\"\u274c Request %d failed: %s\\n\", i+1, err)\n            continue  // Continue with next URL\n        }\n\n        fmt.Printf(\"\u2705 Request %d completed - Status: %d\\n\", i+1, response[\"status\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#middleware-chain","title":"Middleware Chain","text":"<p>Easy middleware composition through handler wrapping and function chaining.</p>"},{"location":"stdlib/http/advanced/#basic-middleware-components","title":"Basic Middleware Components","text":"<pre><code>import http\nimport fmt\n\n// Logging middleware\nfunction loggingMiddleware(next function) {\n    return function(request, response) {\n        var method = request[\"method\"]\n        var path = request[\"url\"]\n        fmt.Printf(\"\ud83d\udd04 [LOG] %s %s - Started\\n\", method, path)\n\n        next(request, response)\n\n        var status = response[\"status\"]\n        fmt.Printf(\"\u2705 [LOG] %s %s - Completed (%d)\\n\", method, path, status)\n    }\n}\n\n// Authentication middleware\nfunction authMiddleware(next function) {\n    return function(request, response) {\n        var authHeader = request[\"headers\"][\"Authorization\"]\n\n        if authHeader == None or authHeader == \"\" {\n            fmt.Printf(\"\u274c [AUTH] No authorization header\\n\")\n            response[\"status\"] = 401\n            return\n        }\n\n        if authHeader == \"Bearer valid-token\" {\n            fmt.Printf(\"\u2705 [AUTH] Valid token\\n\")\n            next(request, response)\n        } else {\n            fmt.Printf(\"\u274c [AUTH] Invalid token\\n\")\n            response[\"status\"] = 403\n        }\n    }\n}\n\n// CORS middleware\nfunction corsMiddleware(next function) {\n    return function(request, response) {\n        fmt.Printf(\"\ud83c\udf10 [CORS] Adding CORS headers\\n\")\n\n        if request[\"method\"] == \"OPTIONS\" {\n            fmt.Printf(\"\u2705 [CORS] Preflight handled\\n\")\n            response[\"status\"] = 200\n            return\n        }\n\n        next(request, response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#middleware-chain-composition","title":"Middleware Chain Composition","text":"<pre><code>import http\nimport fmt\n\n// Compose middleware chain\nfunction createMiddlewareChain(middlewares array, handler function) {\n    var result = handler\n\n    // Apply middlewares in reverse order\n    for middleware in middlewares {\n        result = middleware(result)\n    }\n\n    return result\n}\n\n// Example handler\nfunction apiHandler(request, response) {\n    fmt.Printf(\"\ud83d\udcc4 [HANDLER] Processing API request\\n\")\n    response[\"status\"] = 200\n}\n\n// Usage\nvar middlewares = [loggingMiddleware, corsMiddleware, authMiddleware]\nvar protectedHandler = createMiddlewareChain(middlewares, apiHandler)\n</code></pre>"},{"location":"stdlib/http/advanced/#request-cloning","title":"Request Cloning","text":"<p>Methods to clone and modify HTTP requests for middleware and testing.</p>"},{"location":"stdlib/http/advanced/#request-variation-testing","title":"Request Variation Testing","text":"<pre><code>import http\nimport fmt\n\nfunction testRequestVariations(baseURL string, endpoint string) {\n    // Test different authentication methods\n    var testCases = [\n        {\"name\": \"No Auth\", \"header\": \"\", \"value\": \"\"},\n        {\"name\": \"Bearer Token\", \"header\": \"Authorization\", \"value\": \"Bearer token123\"},\n        {\"name\": \"API Key\", \"header\": \"X-API-Key\", \"value\": \"api-key-456\"},\n        {\"name\": \"Basic Auth\", \"header\": \"Authorization\", \"value\": \"Basic dXNlcjpwYXNz\"}\n    ]\n\n    for testCase in testCases {\n        fmt.Printf(\"\\n\ud83e\uddea Testing: %s\\n\", testCase[\"name\"])\n\n        // Clone base request\n        var testRequest, _ = http.NewRequest(\"GET\", baseURL + endpoint, \"\")\n        testRequest, _ = http.SetHeader(testRequest, \"User-Agent\", \"TestClient/1.0\")\n\n        // Add test-specific header\n        if testCase[\"header\"] != \"\" {\n            testRequest, _ = http.SetHeader(testRequest, testCase[\"header\"], testCase[\"value\"])\n        }\n\n        var response, err = http.Do(testRequest)\n\n        if err != None {\n            fmt.Printf(\"\u274c Test failed: %s\\n\", err)\n        } else {\n            fmt.Printf(\"\u2705 Status: %d\\n\", response[\"status\"])\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#retry-with-request-modifications","title":"Retry with Request Modifications","text":"<pre><code>import http\nimport fmt\n\nfunction retryWithModifications(originalURL string, maxRetries int) {\n    for attempt in range(maxRetries) {\n        var request, _ = http.NewRequest(\"GET\", originalURL, \"\")\n\n        // Add retry-specific headers\n        request, _ = http.SetHeader(request, \"X-Retry-Attempt\", attempt + 1)\n        request, _ = http.SetHeader(request, \"X-Request-ID\", \"req-\" + (attempt + 1))\n\n        var response, err = http.Do(request)\n\n        if err == None and response[\"status\"] &lt; 500 {\n            fmt.Printf(\"\u2705 Success on attempt %d\\n\", attempt + 1)\n            return\n        }\n\n        fmt.Printf(\"\u23f3 Attempt %d failed, retrying...\\n\", attempt + 1)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#multipart-forms","title":"Multipart Forms","text":"<p>Built-in support for parsing multipart/form-data including file uploads.</p>"},{"location":"stdlib/http/advanced/#multipart-form-upload","title":"Multipart Form Upload","text":"<pre><code>import http\nimport fmt\n\nfunction uploadMultipartForm(url string, fields map, files array) {\n    var boundary = \"----WebKitFormBoundary7MA4YWxkTrZu0gW\"\n    var multipartBody = \"\"\n\n    // Add form fields\n    for key, value in fields {\n        multipartBody = multipartBody + \"--\" + boundary + \"\\r\\n\"\n        multipartBody = multipartBody + \"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"\\r\\n\\r\\n\"\n        multipartBody = multipartBody + value + \"\\r\\n\"\n    }\n\n    // Add files\n    for file in files {\n        multipartBody = multipartBody + \"--\" + boundary + \"\\r\\n\"\n        multipartBody = multipartBody + \"Content-Disposition: form-data; name=\\\"\" + file[\"field\"] + \"\\\"; filename=\\\"\" + file[\"name\"] + \"\\\"\\r\\n\"\n        multipartBody = multipartBody + \"Content-Type: \" + file[\"type\"] + \"\\r\\n\\r\\n\"\n        multipartBody = multipartBody + file[\"content\"] + \"\\r\\n\"\n    }\n\n    multipartBody = multipartBody + \"--\" + boundary + \"--\\r\\n\"\n\n    var response, err = http.Post(url, \"multipart/form-data; boundary=\" + boundary, multipartBody)\n\n    if err != None {\n        fmt.Printf(\"\u274c Upload failed: %s\\n\", err)\n    } else if response[\"status\"] == 200 {\n        fmt.Printf(\"\u2705 Upload successful!\\n\")\n    } else {\n        fmt.Printf(\"\u274c Upload failed - Status: %d\\n\", response[\"status\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#file-upload-with-validation","title":"File Upload with Validation","text":"<pre><code>import http\nimport fmt\n\nfunction uploadWithValidation(url string, filename string, content string, maxSize int) {\n    if len(content) &gt; maxSize {\n        fmt.Printf(\"\u274c File too large: %d bytes (max: %d)\\n\", len(content), maxSize)\n        return\n    }\n\n    var allowedTypes = [\"txt\", \"pdf\", \"jpg\", \"png\"]\n    var extension = getFileExtension(filename)\n    var isAllowed = false\n\n    for allowedType in allowedTypes {\n        if extension == allowedType {\n            isAllowed = true\n            break\n        }\n    }\n\n    if !isAllowed {\n        fmt.Printf(\"\u274c File type not allowed: %s\\n\", extension)\n        return\n    }\n\n    var fields = {\"description\": \"File upload\", \"category\": \"document\"}\n    var files = [{\"field\": \"file\", \"name\": filename, \"type\": \"text/plain\", \"content\": content}]\n\n    uploadMultipartForm(url, fields, files)\n}\n\nfunction getFileExtension(filename string) string {\n    // Simplified extension extraction\n    return \"txt\"  // In real implementation, extract from filename\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#keep-alive-control","title":"Keep-Alive Control","text":"<p>Connection keep-alive management and configuration options.</p>"},{"location":"stdlib/http/advanced/#optimized-client-with-keep-alive","title":"Optimized Client with Keep-Alive","text":"<pre><code>import http\nimport fmt\n\nfunction createOptimizedClient(maxConnections int, keepAliveTimeout int) map {\n    return {\n        \"maxConnections\": maxConnections,\n        \"keepAliveTimeout\": keepAliveTimeout,\n        \"userAgent\": \"OptimizedClient/1.0\"\n    }\n}\n\nfunction makeOptimizedRequest(client map, url string) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n\n    // Set keep-alive headers\n    request, _ = http.SetHeader(request, \"Connection\", \"keep-alive\")\n    request, _ = http.SetHeader(request, \"Keep-Alive\", \"timeout=\" + client[\"keepAliveTimeout\"])\n    request, _ = http.SetHeader(request, \"User-Agent\", client[\"userAgent\"])\n\n    var response, err = http.Do(request)\n\n    if err != None {\n        fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        return\n    }\n\n    var connection = response[\"headers\"][\"Connection\"]\n    if connection == \"keep-alive\" {\n        fmt.Printf(\"\u2705 Keep-alive connection established\\n\")\n    }\n\n    fmt.Printf(\"\u2705 Request completed - Status: %d\\n\", response[\"status\"])\n}\n</code></pre>"},{"location":"stdlib/http/advanced/#batch-requests-with-connection-reuse","title":"Batch Requests with Connection Reuse","text":"<pre><code>import http\nimport fmt\n\nfunction batchRequestsWithKeepAlive(client map, urls array) {\n    fmt.Printf(\"\ud83d\udce6 Processing %d URLs with connection reuse\\n\", len(urls))\n\n    for i, url in urls {\n        fmt.Printf(\"\ud83d\udd04 Request %d/%d: %s\\n\", i+1, len(urls), url)\n        makeOptimizedRequest(client, url)\n    }\n\n    fmt.Printf(\"\ud83c\udf89 Batch complete with optimized connections\\n\")\n}\n\n// Usage\nvar client = createOptimizedClient(10, 30)  // 10 connections, 30s timeout\nvar urls = [\n    \"https://api.example.com/users\",\n    \"https://api.example.com/posts\", \n    \"https://api.example.com/comments\"\n]\nbatchRequestsWithKeepAlive(client, urls)\n</code></pre>"},{"location":"stdlib/http/advanced/#integration-examples","title":"Integration Examples","text":""},{"location":"stdlib/http/advanced/#complete-advanced-http-client","title":"Complete Advanced HTTP Client","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction createAdvancedHTTPClient() map {\n    return {\n        \"timeout\": 30,\n        \"retries\": 3,\n        \"keepAlive\": true,\n        \"userAgent\": \"AdvancedClient/1.0\"\n    }\n}\n\nfunction advancedRequest(client map, method string, url string, body string, options map) {\n    var request, _ = http.NewRequest(method, url, body)\n\n    // Apply client defaults\n    request, _ = http.SetHeader(request, \"User-Agent\", client[\"userAgent\"])\n\n    // Apply conditional headers if provided\n    if options[\"etag\"] != None {\n        request, _ = http.SetHeader(request, \"If-None-Match\", options[\"etag\"])\n    }\n\n    if options[\"lastModified\"] != None {\n        request, _ = http.SetHeader(request, \"If-Modified-Since\", options[\"lastModified\"])\n    }\n\n    // Apply range if provided\n    if options[\"rangeStart\"] != None and options[\"rangeEnd\"] != None {\n        var rangeHeader = \"bytes=\" + options[\"rangeStart\"] + \"-\" + options[\"rangeEnd\"]\n        request, _ = http.SetHeader(request, \"Range\", rangeHeader)\n    }\n\n    // Retry with exponential backoff\n    var attempt = 0\n    for attempt &lt; client[\"retries\"] {\n        attempt = attempt + 1\n\n        var requestCopy, _ = http.NewRequest(method, url, body)\n        requestCopy, _ = http.SetHeader(requestCopy, \"X-Attempt\", attempt)\n\n        var response, err = http.Do(requestCopy)\n\n        if err == None {\n            return response, None\n        }\n\n        if attempt &lt; client[\"retries\"] {\n            var backoff = attempt * 2\n            fmt.Printf(\"\u23f3 Attempt %d failed, retrying in %d seconds...\\n\", attempt, backoff)\n        }\n    }\n\n    return None, \"All retry attempts failed\"\n}\n\n// Usage\nvar client = createAdvancedHTTPClient()\nvar options = {\"etag\": \"\\\"abc123\\\"\", \"rangeStart\": 0, \"rangeEnd\": 1023}\nvar response, err = advancedRequest(client, \"GET\", \"https://api.example.com/data\", \"\", options)\n</code></pre> <p>These advanced HTTP features provide enterprise-level capabilities for building robust web applications and APIs in Harneet with modern tuple destructuring syntax.     // Check existing file size     var existingSize, _ = os.FileSize(localFile)</p> <pre><code>if existingSize &gt; 0 {\n    fmt.Printf(\"\ud83d\udd04 Resuming download from byte %d\\n\", existingSize)\n\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n    var rangeRequest, _ = http.SetRange(request, existingSize, -1)  // -1 means to end\n    var response, err = http.Do(rangeRequest)\n\n    if err != None {\n        fmt.Printf(\"\u274c Resume failed: %s\\n\", err)\n        return\n    }\n\n    if response[\"status\"] == 206 {\n        fmt.Printf(\"\u2705 Resuming download...\\n\")\n        // Append to existing file: response[\"body\"]\n    } else {\n        fmt.Printf(\"\u26a0\ufe0f  Server doesn't support resume, starting over\\n\")\n        // Start fresh download\n    }\n}\n</code></pre> <p>} ``` </p>"},{"location":"stdlib/http/advanced/#conditional-requests_1","title":"Conditional Requests","text":"<p>Support for If-Modified-Since, ETag, and other conditional headers. </p>"},{"location":"stdlib/http/advanced/#httpsetconditionalrequest-headers","title":"http.SetConditional(request, headers)","text":"<p>Sets conditional headers for cache validation.  Examples: Cache Validation with ETag: <code>harneet import http import fmt  function fetchWithETag(url string, cachedETag string) {     var request, _ = http.NewRequest(\"GET\", url, \"\")      if cachedETag != \"\" {         var conditionalRequest, _ = http.SetHeader(request, \"If-None-Match\", cachedETag)         var response, err = http.Do(conditionalRequest)          if err != None {             fmt.Printf(\"\u274c Request failed: %s\\n\", err)             return None, \"\"         }          if response[\"status\"] == 304 {             fmt.Printf(\"\u2705 Content not modified, using cache\\n\")             return None, cachedETag  // Use cached content         }     }      var response, err = http.Do(request)     if err != None {         return None, \"\"     }      var newETag = response[\"headers\"][\"ETag\"]     fmt.Printf(\"\u2705 New content received, ETag: %s\\n\", newETag)     return response[\"body\"], newETag }  // Usage var cachedETag = \"\\\"abc123\\\"\" var content, etag = fetchWithETag(\"https://api.example.com/data\", cachedETag)</code></p> <p>If-Modified-Since Validation: <pre><code>import http\nimport fmt\n\nfunction fetchIfModified(url string, lastModified string) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n\n    if lastModified != \"\" {\n        var conditionalRequest, _ = http.SetHeader(request, \"If-Modified-Since\", lastModified)\n        var response, err = http.Do(conditionalRequest)\n\n        if err != None {\n            fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n            return None\n        }\n\n        if response[\"status\"] == 304 {\n            fmt.Printf(\"\u2705 Content not modified since %s\\n\", lastModified)\n            return None  // Use cached content\n        }\n    }\n\n    var response, err = http.Do(request)\n    if err != None {\n        return None\n    }\n\n    var newLastModified = response[\"headers\"][\"Last-Modified\"]\n    fmt.Printf(\"\u2705 Content modified, new date: %s\\n\", newLastModified)\n    return response[\"body\"]\n}\n</code></pre></p>"},{"location":"stdlib/http/advanced/#request-cancellation_1","title":"Request Cancellation","text":"<p>Context-based request cancellation for both client and server.</p>"},{"location":"stdlib/http/advanced/#httpwithtimeoutrequest-seconds","title":"http.WithTimeout(request, seconds)","text":"<p>Sets a timeout for request cancellation.</p> <p>Examples:</p> <p>Request with Timeout: <pre><code>import http\nimport fmt\n\nfunction fetchWithTimeout(url string, timeoutSeconds int) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n    var timeoutRequest, _ = http.WithTimeout(request, timeoutSeconds)\n\n    var response, err = http.Do(timeoutRequest)\n\n    if err != None {\n        if err == \"request timeout\" {\n            fmt.Printf(\"\u23f0 Request timed out after %d seconds\\n\", timeoutSeconds)\n        } else {\n            fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        }\n        return None\n    }\n\n    fmt.Printf(\"\u2705 Request completed within timeout\\n\")\n    return response\n}\n\n// Usage\nvar response = fetchWithTimeout(\"https://slow-api.example.com/data\", 5)\n</code></pre></p> <p>Cancellable Request Chain: <pre><code>import http\nimport fmt\n\nfunction fetchMultipleWithCancel(urls array, timeoutSeconds int) {\n    var results = []\n\n    for url in urls {\n        fmt.Printf(\"\ud83d\udd04 Fetching: %s\\n\", url)\n\n        var request, _ = http.NewRequest(\"GET\", url, \"\")\n        var timeoutRequest, _ = http.WithTimeout(request, timeoutSeconds)\n        var response, err = http.Do(timeoutRequest)\n\n        if err != None {\n            fmt.Printf(\"\u274c Failed to fetch %s: %s\\n\", url, err)\n            // Continue with next URL or break based on strategy\n            continue\n        }\n\n        results = append(results, {\n            \"url\": url,\n            \"status\": response[\"status\"],\n            \"data\": response[\"body\"]\n        })\n\n        fmt.Printf(\"\u2705 Completed: %s (Status: %d)\\n\", url, response[\"status\"])\n    }\n\n    return results\n}\n</code></pre></p>"},{"location":"stdlib/http/advanced/#middleware-chain_1","title":"Middleware Chain","text":"<p>Easy middleware composition through handler wrapping and function chaining.</p>"},{"location":"stdlib/http/advanced/#httpchainmiddlewares-handler","title":"http.Chain(middlewares, handler)","text":"<p>Chains multiple middleware functions around a handler.</p> <p>Examples:</p> <p>Logging Middleware: <pre><code>import http\nimport fmt\nimport time\n\nfunction loggingMiddleware(next function) {\n    return function(request, response) {\n        var start = time.Now()\n        var method = request[\"method\"]\n        var path = request[\"path\"]\n\n        fmt.Printf(\"\ud83d\udd04 %s %s - Started\\n\", method, path)\n\n        // Call next handler\n        next(request, response)\n\n        var duration = time.Since(start)\n        var status = response[\"status\"]\n        fmt.Printf(\"\u2705 %s %s - %d (%s)\\n\", method, path, status, duration)\n    }\n}\n\nfunction authMiddleware(next function) {\n    return function(request, response) {\n        var authHeader = request[\"headers\"][\"Authorization\"]\n\n        if authHeader == None or authHeader == \"\" {\n            http.WriteResponse(response, 401, \"application/json\", \n                \"{\\\"error\\\": \\\"Authorization required\\\"}\")\n            return\n        }\n\n        // Validate token (simplified)\n        if !isValidToken(authHeader) {\n            http.WriteResponse(response, 403, \"application/json\", \n                \"{\\\"error\\\": \\\"Invalid token\\\"}\")\n            return\n        }\n\n        // Add user info to request context\n        request[\"user\"] = getUserFromToken(authHeader)\n        next(request, response)\n    }\n}\n\nfunction corsMiddleware(next function) {\n    return function(request, response) {\n        // Set CORS headers\n        response[\"headers\"][\"Access-Control-Allow-Origin\"] = \"*\"\n        response[\"headers\"][\"Access-Control-Allow-Methods\"] = \"GET, POST, PUT, DELETE, OPTIONS\"\n        response[\"headers\"][\"Access-Control-Allow-Headers\"] = \"Content-Type, Authorization\"\n\n        if request[\"method\"] == \"OPTIONS\" {\n            http.WriteResponse(response, 200, \"text/plain\", \"\")\n            return\n        }\n\n        next(request, response)\n    }\n}\n\n// Chain middleware\nfunction createProtectedHandler(handler function) {\n    return corsMiddleware(\n        loggingMiddleware(\n            authMiddleware(handler)\n        )\n    )\n}\n\n// Usage\nfunction apiHandler(request, response) {\n    var user = request[\"user\"]\n    var data = {\"message\": \"Hello \" + user[\"name\"], \"protected\": true}\n    var jsonData, _ = json.Marshal(data)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nvar protectedHandler = createProtectedHandler(apiHandler)\nhttp.HandleFunc(mux, \"/api/protected\", protectedHandler)\n</code></pre></p> <p>Rate Limiting Middleware: <pre><code>import http\nimport fmt\nimport time\n\n// Simple in-memory rate limiter\nvar rateLimiter = {}\n\nfunction rateLimitMiddleware(requestsPerMinute int) {\n    return function(next function) {\n        return function(request, response) {\n            var clientIP = request[\"remote_addr\"]\n            var now = time.Now()\n            var minute = now / 60  // Simple minute bucket\n            var key = clientIP + \":\" + minute\n\n            var count = rateLimiter[key]\n            if count == None {\n                count = 0\n            }\n\n            if count &gt;= requestsPerMinute {\n                http.WriteResponse(response, 429, \"application/json\", \n                    \"{\\\"error\\\": \\\"Rate limit exceeded\\\"}\")\n                return\n            }\n\n            rateLimiter[key] = count + 1\n            next(request, response)\n        }\n    }\n}\n\n// Usage\nvar rateLimitedHandler = rateLimitMiddleware(100)(apiHandler)\n</code></pre></p>"},{"location":"stdlib/http/advanced/#request-cloning_1","title":"Request Cloning","text":"<p>Methods to clone and modify HTTP requests for middleware and testing.</p>"},{"location":"stdlib/http/advanced/#httpclonerequestrequest","title":"http.CloneRequest(request)","text":"<p>Creates a deep copy of an HTTP request.</p> <p>Examples:</p> <p>Request Modification for Testing: <pre><code>import http\nimport fmt\n\nfunction testAPIWithDifferentHeaders(baseRequest map) {\n    var testCases = [\n        {\"User-Agent\": \"TestBot/1.0\", \"expected\": 200},\n        {\"User-Agent\": \"BadBot/1.0\", \"expected\": 403},\n        {\"Authorization\": \"Bearer valid-token\", \"expected\": 200},\n        {\"Authorization\": \"Bearer invalid-token\", \"expected\": 401}\n    ]\n\n    for testCase in testCases {\n        // Clone the base request\n        var testRequest, _ = http.CloneRequest(baseRequest)\n\n        // Modify headers for this test\n        for header, value in testCase {\n            if header != \"expected\" {\n                testRequest, _ = http.SetHeader(testRequest, header, value)\n            }\n        }\n\n        var response, err = http.Do(testRequest)\n        var expectedStatus = testCase[\"expected\"]\n\n        if err != None {\n            fmt.Printf(\"\u274c Test failed: %s\\n\", err)\n            continue\n        }\n\n        if response[\"status\"] == expectedStatus {\n            fmt.Printf(\"\u2705 Test passed: %s = %d\\n\", testCase, expectedStatus)\n        } else {\n            fmt.Printf(\"\u274c Test failed: expected %d, got %d\\n\", expectedStatus, response[\"status\"])\n        }\n    }\n}\n\n// Usage\nvar baseRequest, _ = http.NewRequest(\"GET\", \"https://api.example.com/test\", \"\")\ntestAPIWithDifferentHeaders(baseRequest)\n</code></pre></p> <p>Request Retry with Modifications: <pre><code>import http\nimport fmt\nimport time\n\nfunction retryWithBackoff(originalRequest map, maxRetries int) {\n    var attempt = 0\n\n    for attempt &lt; maxRetries {\n        attempt = attempt + 1\n\n        // Clone request for this attempt\n        var request, _ = http.CloneRequest(originalRequest)\n\n        // Add retry headers\n        request, _ = http.SetHeader(request, \"X-Retry-Attempt\", attempt)\n        request, _ = http.SetHeader(request, \"X-Request-ID\", generateRequestID())\n\n        var response, err = http.Do(request)\n\n        if err == None and response[\"status\"] &lt; 500 {\n            fmt.Printf(\"\u2705 Request succeeded on attempt %d\\n\", attempt)\n            return response\n        }\n\n        if attempt &lt; maxRetries {\n            var backoffSeconds = attempt * 2  // Exponential backoff\n            fmt.Printf(\"\u23f3 Attempt %d failed, retrying in %d seconds...\\n\", attempt, backoffSeconds)\n            time.Sleep(backoffSeconds)\n        }\n    }\n\n    fmt.Printf(\"\u274c All %d attempts failed\\n\", maxRetries)\n    return None\n}\n</code></pre></p>"},{"location":"stdlib/http/advanced/#multipart-forms_1","title":"Multipart Forms","text":"<p>Built-in support for parsing multipart/form-data including file uploads.</p>"},{"location":"stdlib/http/advanced/#httpparsemultipartrequest","title":"http.ParseMultipart(request)","text":"<p>Parses multipart form data from a request.</p> <p>Examples:</p> <p>File Upload Handler: <pre><code>import http\nimport fmt\nimport os\n\nfunction fileUploadHandler(request, response) {\n    if request[\"method\"] != \"POST\" {\n        http.WriteResponse(response, 405, \"text/plain\", \"Method not allowed\")\n        return\n    }\n\n    var contentType = request[\"headers\"][\"Content-Type\"]\n    if !strings.Contains(contentType, \"multipart/form-data\") {\n        http.WriteResponse(response, 400, \"application/json\", \n            \"{\\\"error\\\": \\\"Expected multipart/form-data\\\"}\")\n        return\n    }\n\n    var multipart, err = http.ParseMultipart(request)\n    if err != None {\n        http.WriteResponse(response, 400, \"application/json\", \n            \"{\\\"error\\\": \\\"Failed to parse multipart data\\\"}\")\n        return\n    }\n\n    // Process form fields\n    var description = multipart[\"fields\"][\"description\"]\n    var category = multipart[\"fields\"][\"category\"]\n\n    // Process uploaded files\n    var uploadedFiles = []\n    for file in multipart[\"files\"] {\n        var filename = file[\"filename\"]\n        var content = file[\"content\"]\n        var size = file[\"size\"]\n\n        // Save file\n        var savedPath, saveErr = os.WriteFile(\"uploads/\" + filename, content)\n        if saveErr != None {\n            fmt.Printf(\"\u274c Failed to save %s: %s\\n\", filename, saveErr)\n            continue\n        }\n\n        uploadedFiles = append(uploadedFiles, {\n            \"filename\": filename,\n            \"size\": size,\n            \"path\": savedPath\n        })\n\n        fmt.Printf(\"\u2705 Saved file: %s (%d bytes)\\n\", filename, size)\n    }\n\n    var result = {\n        \"message\": \"Upload successful\",\n        \"description\": description,\n        \"category\": category,\n        \"files\": uploadedFiles\n    }\n\n    var jsonResponse, _ = json.Marshal(result)\n    http.WriteResponse(response, 200, \"application/json\", jsonResponse)\n}\n\n// Register handler\nhttp.HandleFunc(mux, \"/upload\", fileUploadHandler)\n</code></pre></p> <p>Form Data Processing: <pre><code>import http\nimport fmt\n\nfunction processFormData(request, response) {\n    var multipart, err = http.ParseMultipart(request)\n    if err != None {\n        http.WriteResponse(response, 400, \"application/json\", \n            \"{\\\"error\\\": \\\"Invalid form data\\\"}\")\n        return\n    }\n\n    // Validate required fields\n    var requiredFields = [\"name\", \"email\", \"message\"]\n    var missingFields = []\n\n    for field in requiredFields {\n        if multipart[\"fields\"][field] == None or multipart[\"fields\"][field] == \"\" {\n            missingFields = append(missingFields, field)\n        }\n    }\n\n    if len(missingFields) &gt; 0 {\n        var errorMsg = \"Missing required fields: \" + strings.Join(missingFields, \", \")\n        http.WriteResponse(response, 400, \"application/json\", \n            \"{\\\"error\\\": \\\"\" + errorMsg + \"\\\"}\")\n        return\n    }\n\n    // Process the form\n    var formData = {\n        \"name\": multipart[\"fields\"][\"name\"],\n        \"email\": multipart[\"fields\"][\"email\"],\n        \"message\": multipart[\"fields\"][\"message\"],\n        \"timestamp\": time.Now()\n    }\n\n    // Save to database or process as needed\n    fmt.Printf(\"\ud83d\udcdd Form submitted by: %s (%s)\\n\", formData[\"name\"], formData[\"email\"])\n\n    var response = {\"message\": \"Form submitted successfully\", \"id\": generateID()}\n    var jsonResponse, _ = json.Marshal(response)\n    http.WriteResponse(response, 200, \"application/json\", jsonResponse)\n}\n</code></pre></p>"},{"location":"stdlib/http/advanced/#keep-alive-control_1","title":"Keep-Alive Control","text":"<p>Connection keep-alive management and configuration options.</p>"},{"location":"stdlib/http/advanced/#httpsetkeepaliverequest-enabled-timeout","title":"http.SetKeepAlive(request, enabled, timeout)","text":"<p>Controls connection keep-alive behavior.</p> <p>Examples:</p> <p>Connection Pool Management: <pre><code>import http\nimport fmt\n\nfunction createOptimizedClient(maxConnections int, keepAliveTimeout int) {\n    var client = {\n        \"maxConnections\": maxConnections,\n        \"keepAliveTimeout\": keepAliveTimeout,\n        \"connections\": {}\n    }\n\n    return client\n}\n\nfunction makeOptimizedRequest(client map, url string) {\n    var request, _ = http.NewRequest(\"GET\", url, \"\")\n\n    // Enable keep-alive with timeout\n    var keepAliveRequest, _ = http.SetKeepAlive(request, true, client[\"keepAliveTimeout\"])\n\n    // Set connection pooling headers\n    keepAliveRequest, _ = http.SetHeader(keepAliveRequest, \"Connection\", \"keep-alive\")\n    keepAliveRequest, _ = http.SetHeader(keepAliveRequest, \"Keep-Alive\", \"timeout=\" + client[\"keepAliveTimeout\"])\n\n    var response, err = http.Do(keepAliveRequest)\n\n    if err != None {\n        fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        return None\n    }\n\n    fmt.Printf(\"\u2705 Request completed with keep-alive\\n\")\n    return response\n}\n\n// Usage\nvar client = createOptimizedClient(10, 30)  // 10 connections, 30s timeout\n\n// Make multiple requests that reuse connections\nvar urls = [\"https://api.example.com/users\", \"https://api.example.com/posts\", \"https://api.example.com/comments\"]\nfor url in urls {\n    var response = makeOptimizedRequest(client, url)\n    // Process response\n}\n</code></pre></p> <p>Server Keep-Alive Configuration: <pre><code>import http\nimport fmt\n\nfunction createKeepAliveServer(addr string, keepAliveTimeout int) {\n    var server, _ = http.NewServer(addr)\n\n    // Configure keep-alive settings\n    server[\"keepAliveTimeout\"] = keepAliveTimeout\n    server[\"maxKeepAliveRequests\"] = 100\n    server[\"keepAliveEnabled\"] = true\n\n    return server\n}\n\nfunction keepAliveHandler(request, response) {\n    // Set keep-alive response headers\n    response[\"headers\"][\"Connection\"] = \"keep-alive\"\n    response[\"headers\"][\"Keep-Alive\"] = \"timeout=30, max=100\"\n\n    var data = {\"message\": \"Keep-alive enabled\", \"timestamp\": time.Now()}\n    var jsonData, _ = json.Marshal(data)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// Usage\nvar server = createKeepAliveServer(\":8080\", 30)\nvar mux, _ = http.NewMux()\nhttp.HandleFunc(mux, \"/api/data\", keepAliveHandler)\nhttp.SetHandler(server, mux)\n\nfmt.Println(\"\ud83d\ude80 Keep-alive server starting on :8080\")\nhttp.ListenAndServe(server)\n</code></pre></p>"},{"location":"stdlib/http/advanced/#integration-examples_1","title":"Integration Examples","text":"<p>Complete Advanced HTTP Client: <pre><code>import http\nimport json\nimport fmt\nimport time\n\nfunction createAdvancedHTTPClient() {\n    return {\n        \"timeout\": 30,\n        \"retries\": 3,\n        \"keepAlive\": true,\n        \"userAgent\": \"AdvancedClient/1.0\"\n    }\n}\n\nfunction advancedRequest(client map, method string, url string, body string, options map) {\n    var request, _ = http.NewRequest(method, url, body)\n\n    // Apply client defaults\n    request, _ = http.WithTimeout(request, client[\"timeout\"])\n    request, _ = http.SetKeepAlive(request, client[\"keepAlive\"], 30)\n    request, _ = http.SetHeader(request, \"User-Agent\", client[\"userAgent\"])\n\n    // Apply conditional headers if provided\n    if options[\"etag\"] != None {\n        request, _ = http.SetHeader(request, \"If-None-Match\", options[\"etag\"])\n    }\n\n    if options[\"lastModified\"] != None {\n        request, _ = http.SetHeader(request, \"If-Modified-Since\", options[\"lastModified\"])\n    }\n\n    // Apply range if provided\n    if options[\"rangeStart\"] != None and options[\"rangeEnd\"] != None {\n        request, _ = http.SetRange(request, options[\"rangeStart\"], options[\"rangeEnd\"])\n    }\n\n    // Retry with exponential backoff\n    var attempt = 0\n    for attempt &lt; client[\"retries\"] {\n        attempt = attempt + 1\n\n        var requestCopy, _ = http.CloneRequest(request)\n        requestCopy, _ = http.SetHeader(requestCopy, \"X-Attempt\", attempt)\n\n        var response, err = http.Do(requestCopy)\n\n        if err == None {\n            return response, None\n        }\n\n        if attempt &lt; client[\"retries\"] {\n            var backoff = attempt * 2\n            fmt.Printf(\"\u23f3 Attempt %d failed, retrying in %d seconds...\\n\", attempt, backoff)\n            time.Sleep(backoff)\n        }\n    }\n\n    return None, \"All retry attempts failed\"\n}\n\n// Usage\nvar client = createAdvancedHTTPClient()\nvar options = {\"etag\": \"\\\"abc123\\\"\", \"rangeStart\": 0, \"rangeEnd\": 1023}\nvar response, err = advancedRequest(client, \"GET\", \"https://api.example.com/data\", \"\", options)\n</code></pre></p> <p>These advanced HTTP features provide enterprise-level capabilities for building robust web applications and APIs in Harneet.</p>"},{"location":"stdlib/http/auth/","title":"Authentication","text":"<p>Authentication is the process of verifying who a user is, while authorization determines what they can access. This section covers various authentication methods, token management, and security best practices for HTTP servers.</p>"},{"location":"stdlib/http/auth/#authentication-methods","title":"Authentication Methods","text":""},{"location":"stdlib/http/auth/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Bearer tokens are the most common authentication method for APIs, especially JWT (JSON Web Tokens).</p> <p>Examples:</p> <p>JWT Bearer Token Middleware: <pre><code>import http\nimport json\nimport strings\nimport fmt\n\n// JWT authentication middleware\nfunction jwtAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var authHeader = request[\"headers\"][\"Authorization\"]\n\n        if authHeader == None or authHeader == \"\" {\n            sendUnauthorizedResponse(response, \"Missing Authorization header\")\n            return\n        }\n\n        if !strings.HasPrefix(authHeader, \"Bearer \") {\n            sendUnauthorizedResponse(response, \"Invalid Authorization header format\")\n            return\n        }\n\n        var token = strings.TrimPrefix(authHeader, \"Bearer \")\n        var claims = validateJWTToken(token)\n\n        if claims == None {\n            sendUnauthorizedResponse(response, \"Invalid or expired token\")\n            return\n        }\n\n        // Add user information to request context\n        request[\"user\"] = claims[\"user\"]\n        request[\"userId\"] = claims[\"sub\"]\n        request[\"roles\"] = claims[\"roles\"]\n        request[\"authenticated\"] = true\n\n        next(request, response)\n    }\n}\n\n// JWT token validation\nfunction validateJWTToken(token string) {\n    // In a real implementation, this would:\n    // 1. Verify the token signature\n    // 2. Check expiration\n    // 3. Validate issuer and audience\n    // 4. Return decoded claims\n\n    // Simplified validation for example\n    if token == \"valid-jwt-token\" {\n        return {\n            \"sub\": \"user123\",\n            \"user\": {\n                \"id\": 123,\n                \"username\": \"alice\",\n                \"email\": \"alice@example.com\"\n            },\n            \"roles\": [\"user\", \"admin\"],\n            \"exp\": 1640995200,  // Expiration timestamp\n            \"iat\": 1640908800   // Issued at timestamp\n        }\n    }\n\n    return None\n}\n\nfunction sendUnauthorizedResponse(response map, message string) {\n    var errorResponse = {\n        \"error\": \"Unauthorized\",\n        \"message\": message,\n        \"status\": 401\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 401, \"application/json\", jsonData)\n}\n</code></pre></p>"},{"location":"stdlib/http/auth/#api-key-authentication","title":"API Key Authentication","text":"<p>API keys are simple tokens used for service-to-service authentication.</p> <p>Examples:</p> <p>API Key Middleware: <pre><code>import http\nimport json\nimport fmt\n\n// API key authentication middleware\nfunction apiKeyAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var apiKey = getAPIKeyFromRequest(request)\n\n        if apiKey == \"\" {\n            sendUnauthorizedResponse(response, \"Missing API key\")\n            return\n        }\n\n        var keyInfo = validateAPIKey(apiKey)\n        if keyInfo == None {\n            sendUnauthorizedResponse(response, \"Invalid API key\")\n            return\n        }\n\n        // Add API key information to request\n        request[\"apiKey\"] = apiKey\n        request[\"apiKeyInfo\"] = keyInfo\n        request[\"authenticated\"] = true\n\n        next(request, response)\n    }\n}\n\nfunction getAPIKeyFromRequest(request map) {\n    var headers = request[\"headers\"]\n    var query = request[\"query\"]\n\n    // Check X-API-Key header\n    var headerKey = headers[\"X-API-Key\"]\n    if headerKey != None and headerKey != \"\" {\n        return headerKey\n    }\n\n    // Check Authorization header with API key format\n    var authHeader = headers[\"Authorization\"]\n    if authHeader != None and strings.HasPrefix(authHeader, \"ApiKey \") {\n        return strings.TrimPrefix(authHeader, \"ApiKey \")\n    }\n\n    // Check query parameter\n    var queryKey = query[\"api_key\"]\n    if queryKey != None and queryKey != \"\" {\n        return queryKey\n    }\n\n    return \"\"\n}\n\nfunction validateAPIKey(apiKey string) {\n    // In a real implementation, this would check against a database\n    var validKeys = {\n        \"key_123abc\": {\n            \"id\": \"key_123abc\",\n            \"name\": \"Production API Key\",\n            \"userId\": 123,\n            \"permissions\": [\"read\", \"write\"],\n            \"rateLimit\": 1000,\n            \"active\": true\n        },\n        \"key_456def\": {\n            \"id\": \"key_456def\", \n            \"name\": \"Development API Key\",\n            \"userId\": 456,\n            \"permissions\": [\"read\"],\n            \"rateLimit\": 100,\n            \"active\": true\n        }\n    }\n\n    var keyInfo = validKeys[apiKey]\n    if keyInfo != None and keyInfo[\"active\"] {\n        return keyInfo\n    }\n\n    return None\n}\n</code></pre></p>"},{"location":"stdlib/http/auth/#basic-authentication","title":"Basic Authentication","text":"<p>HTTP Basic Authentication sends credentials in the Authorization header.</p> <p>Examples:</p> <p>Basic Auth Middleware: <pre><code>import http\nimport json\nimport strings\nimport fmt\n\n// Basic authentication middleware\nfunction basicAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var authHeader = request[\"headers\"][\"Authorization\"]\n\n        if authHeader == None or !strings.HasPrefix(authHeader, \"Basic \") {\n            sendBasicAuthChallenge(response)\n            return\n        }\n\n        var credentials = strings.TrimPrefix(authHeader, \"Basic \")\n        var decodedCreds = base64Decode(credentials)  // Simplified base64 decode\n        var parts = strings.Split(decodedCreds, \":\")\n\n        if len(parts) != 2 {\n            sendBasicAuthChallenge(response)\n            return\n        }\n\n        var username = parts[0]\n        var password = parts[1]\n\n        var user = authenticateUser(username, password)\n        if user == None {\n            sendBasicAuthChallenge(response)\n            return\n        }\n\n        // Add user to request context\n        request[\"user\"] = user\n        request[\"authenticated\"] = true\n\n        next(request, response)\n    }\n}\n\nfunction sendBasicAuthChallenge(response map) {\n    http.SetResponseHeader(response, \"WWW-Authenticate\", \"Basic realm=\\\"API\\\"\")\n\n    var errorResponse = {\n        \"error\": \"Unauthorized\",\n        \"message\": \"Basic authentication required\",\n        \"status\": 401\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 401, \"application/json\", jsonData)\n}\n\nfunction authenticateUser(username string, password string) {\n    // In a real implementation, this would check against a database\n    // with properly hashed passwords\n    var users = {\n        \"admin\": {\n            \"username\": \"admin\",\n            \"passwordHash\": \"hashed_password_123\",  // In reality, use bcrypt\n            \"roles\": [\"admin\", \"user\"],\n            \"active\": true\n        },\n        \"user\": {\n            \"username\": \"user\", \n            \"passwordHash\": \"hashed_password_456\",\n            \"roles\": [\"user\"],\n            \"active\": true\n        }\n    }\n\n    var user = users[username]\n    if user != None and user[\"active\"] and verifyPassword(password, user[\"passwordHash\"]) {\n        return user\n    }\n\n    return None\n}\n\nfunction verifyPassword(password string, hash string) {\n    // In a real implementation, use proper password hashing (bcrypt, scrypt, etc.)\n    return password == \"password123\"  // Simplified for example\n}\n</code></pre></p>"},{"location":"stdlib/http/auth/#session-based-authentication","title":"Session-Based Authentication","text":"<p>Session-based authentication uses server-side sessions with cookies.</p> <p>Examples:</p> <p>Session Authentication: <pre><code>import http\nimport json\nimport fmt\n\n// Session-based authentication middleware\nfunction sessionAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var sessionId = getSessionIdFromRequest(request)\n\n        if sessionId == \"\" {\n            sendUnauthorizedResponse(response, \"No session found\")\n            return\n        }\n\n        var session = getSession(sessionId)\n        if session == None or isSessionExpired(session) {\n            sendUnauthorizedResponse(response, \"Invalid or expired session\")\n            return\n        }\n\n        // Update session last accessed time\n        updateSessionAccess(sessionId)\n\n        // Add session and user to request context\n        request[\"session\"] = session\n        request[\"user\"] = session[\"user\"]\n        request[\"authenticated\"] = true\n\n        next(request, response)\n    }\n}\n\nfunction getSessionIdFromRequest(request map) {\n    var cookies = request[\"cookies\"]\n    if cookies != None {\n        var sessionId = cookies[\"session_id\"]\n        if sessionId != None {\n            return sessionId\n        }\n    }\n\n    // Fallback to header\n    var sessionHeader = request[\"headers\"][\"X-Session-ID\"]\n    if sessionHeader != None {\n        return sessionHeader\n    }\n\n    return \"\"\n}\n\n// Session management functions\nvar sessions = {}  // In-memory session store (use Redis/database in production)\n\nfunction createSession(user map) {\n    var sessionId = generateSessionId()\n    var session = {\n        \"id\": sessionId,\n        \"user\": user,\n        \"createdAt\": getCurrentTimestamp(),\n        \"lastAccessed\": getCurrentTimestamp(),\n        \"expiresAt\": getCurrentTimestamp() + 3600  // 1 hour\n    }\n\n    sessions[sessionId] = session\n    return session\n}\n\nfunction getSession(sessionId string) {\n    return sessions[sessionId]\n}\n\nfunction updateSessionAccess(sessionId string) {\n    var session = sessions[sessionId]\n    if session != None {\n        session[\"lastAccessed\"] = getCurrentTimestamp()\n        // Extend expiration\n        session[\"expiresAt\"] = getCurrentTimestamp() + 3600\n    }\n}\n\nfunction isSessionExpired(session map) {\n    var expiresAt = session[\"expiresAt\"]\n    var currentTime = getCurrentTimestamp()\n    return currentTime &gt; expiresAt\n}\n\nfunction destroySession(sessionId string) {\n    delete(sessions, sessionId)\n}\n\nfunction generateSessionId() {\n    // In a real implementation, use a cryptographically secure random generator\n    return \"session_\" + generateRandomString(32)\n}\n</code></pre></p>"},{"location":"stdlib/http/auth/#authorization-and-role-based-access-control","title":"Authorization and Role-Based Access Control","text":"<p>Authorization determines what authenticated users can access.</p> <p>Examples:</p> <p>Role-Based Authorization: <pre><code>import http\nimport json\nimport fmt\n\n// Role-based authorization middleware\nfunction requireRole(requiredRole string) {\n    return function(next function) {\n        return function(request map, response map) {\n            var user = request[\"user\"]\n            if user == None {\n                sendForbiddenResponse(response, \"Authentication required\")\n                return\n            }\n\n            var userRoles = user[\"roles\"]\n            if userRoles == None {\n                sendForbiddenResponse(response, \"No roles assigned\")\n                return\n            }\n\n            var hasRole = false\n            for role in userRoles {\n                if role == requiredRole {\n                    hasRole = true\n                    break\n                }\n            }\n\n            if !hasRole {\n                sendForbiddenResponse(response, \"Insufficient permissions\")\n                return\n            }\n\n            next(request, response)\n        }\n    }\n}\n\n// Permission-based authorization\nfunction requirePermission(requiredPermission string) {\n    return function(next function) {\n        return function(request map, response map) {\n            var user = request[\"user\"]\n            if user == None {\n                sendForbiddenResponse(response, \"Authentication required\")\n                return\n            }\n\n            var hasPermission = checkUserPermission(user, requiredPermission)\n            if !hasPermission {\n                sendForbiddenResponse(response, \"Permission denied\")\n                return\n            }\n\n            next(request, response)\n        }\n    }\n}\n\nfunction checkUserPermission(user map, permission string) {\n    var userRoles = user[\"roles\"]\n    if userRoles == None {\n        return false\n    }\n\n    // Check role-based permissions\n    var rolePermissions = {\n        \"admin\": [\"read\", \"write\", \"delete\", \"manage_users\"],\n        \"editor\": [\"read\", \"write\"],\n        \"user\": [\"read\"]\n    }\n\n    for role in userRoles {\n        var permissions = rolePermissions[role]\n        if permissions != None {\n            for perm in permissions {\n                if perm == permission {\n                    return true\n                }\n            }\n        }\n    }\n\n    return false\n}\n\nfunction sendForbiddenResponse(response map, message string) {\n    var errorResponse = {\n        \"error\": \"Forbidden\",\n        \"message\": message,\n        \"status\": 403\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 403, \"application/json\", jsonData)\n}\n\n// Usage examples\nfunction setupProtectedRoutes() {\n    var mux = http.NewMux()[0]\n\n    // Public routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/login\", loginHandler)\n\n    // Protected routes with different authorization levels\n    var userHandler = chainMiddleware([jwtAuthMiddleware, requireRole(\"user\")])(userProfileHandler)\n    var adminHandler = chainMiddleware([jwtAuthMiddleware, requireRole(\"admin\")])(adminDashboardHandler)\n    var editorHandler = chainMiddleware([jwtAuthMiddleware, requirePermission(\"write\")])(editContentHandler)\n\n    http.HandleFunc(mux, \"/profile\", userHandler)\n    http.HandleFunc(mux, \"/admin\", adminHandler)\n    http.HandleFunc(mux, \"/edit\", editorHandler)\n\n    return mux\n}\n</code></pre></p>"},{"location":"stdlib/http/auth/#token-management","title":"Token Management","text":""},{"location":"stdlib/http/auth/#jwt-token-generation-and-validation","title":"JWT Token Generation and Validation","text":"<pre><code>import http\nimport json\nimport fmt\n\n// JWT token generation (simplified)\nfunction generateJWTToken(user map) {\n    var header = {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    }\n\n    var payload = {\n        \"sub\": user[\"id\"],\n        \"username\": user[\"username\"],\n        \"email\": user[\"email\"],\n        \"roles\": user[\"roles\"],\n        \"iat\": getCurrentTimestamp(),\n        \"exp\": getCurrentTimestamp() + 3600  // 1 hour expiration\n    }\n\n    // In a real implementation, properly encode and sign the JWT\n    var headerEncoded = base64Encode(json.Marshal(header)[0])\n    var payloadEncoded = base64Encode(json.Marshal(payload)[0])\n    var signature = signJWT(headerEncoded + \".\" + payloadEncoded, \"secret-key\")\n\n    return headerEncoded + \".\" + payloadEncoded + \".\" + signature\n}\n\n// Token refresh endpoint\nfunction tokenRefreshHandler(request map, response map) {\n    var refreshToken = getRefreshTokenFromRequest(request)\n\n    if refreshToken == \"\" {\n        sendUnauthorizedResponse(response, \"Missing refresh token\")\n        return\n    }\n\n    var tokenInfo = validateRefreshToken(refreshToken)\n    if tokenInfo == None {\n        sendUnauthorizedResponse(response, \"Invalid refresh token\")\n        return\n    }\n\n    var user = getUserById(tokenInfo[\"userId\"])\n    if user == None {\n        sendUnauthorizedResponse(response, \"User not found\")\n        return\n    }\n\n    // Generate new access token\n    var newAccessToken = generateJWTToken(user)\n    var newRefreshToken = generateRefreshToken(user[\"id\"])\n\n    // Invalidate old refresh token\n    invalidateRefreshToken(refreshToken)\n\n    var tokenResponse = {\n        \"access_token\": newAccessToken,\n        \"refresh_token\": newRefreshToken,\n        \"token_type\": \"Bearer\",\n        \"expires_in\": 3600\n    }\n\n    var jsonData, _ = json.Marshal(tokenResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction generateRefreshToken(userId string) {\n    var refreshToken = \"refresh_\" + generateRandomString(64)\n\n    // Store refresh token (in database in real implementation)\n    var tokenInfo = {\n        \"token\": refreshToken,\n        \"userId\": userId,\n        \"createdAt\": getCurrentTimestamp(),\n        \"expiresAt\": getCurrentTimestamp() + 604800  // 7 days\n    }\n\n    storeRefreshToken(refreshToken, tokenInfo)\n    return refreshToken\n}\n</code></pre>"},{"location":"stdlib/http/auth/#login-and-logout-endpoints","title":"Login and Logout Endpoints","text":""},{"location":"stdlib/http/auth/#login-handler","title":"Login Handler","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Login endpoint\nfunction loginHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    if method != \"POST\" {\n        http.WriteResponse(response, 405, \"application/json\", \"{\\\"error\\\": \\\"Method not allowed\\\"}\")\n        return\n    }\n\n    var body = request[\"body\"]\n    var loginData, parseErr = json.Unmarshal(body)\n\n    if parseErr != None {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Invalid JSON\\\"}\")\n        return\n    }\n\n    var username = loginData[\"username\"]\n    var password = loginData[\"password\"]\n\n    if username == None or password == None {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Username and password required\\\"}\")\n        return\n    }\n\n    // Authenticate user\n    var user = authenticateUser(username, password)\n    if user == None {\n        // Add delay to prevent timing attacks\n        sleep(1000)  // 1 second delay\n        http.WriteResponse(response, 401, \"application/json\", \"{\\\"error\\\": \\\"Invalid credentials\\\"}\")\n        return\n    }\n\n    // Generate tokens\n    var accessToken = generateJWTToken(user)\n    var refreshToken = generateRefreshToken(user[\"id\"])\n\n    // Create session (if using session-based auth)\n    var session = createSession(user)\n\n    // Set session cookie\n    http.SetCookie(response, \"session_id\", session[\"id\"], {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"strict\",\n        \"maxAge\": 3600\n    })\n\n    var loginResponse = {\n        \"success\": true,\n        \"user\": {\n            \"id\": user[\"id\"],\n            \"username\": user[\"username\"],\n            \"email\": user[\"email\"],\n            \"roles\": user[\"roles\"]\n        },\n        \"tokens\": {\n            \"access_token\": accessToken,\n            \"refresh_token\": refreshToken,\n            \"token_type\": \"Bearer\",\n            \"expires_in\": 3600\n        }\n    }\n\n    var jsonData, _ = json.Marshal(loginResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// Logout endpoint\nfunction logoutHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    if method != \"POST\" {\n        http.WriteResponse(response, 405, \"application/json\", \"{\\\"error\\\": \\\"Method not allowed\\\"}\")\n        return\n    }\n\n    // Get session ID from cookie\n    var sessionId = getSessionIdFromRequest(request)\n    if sessionId != \"\" {\n        destroySession(sessionId)\n    }\n\n    // Get refresh token and invalidate it\n    var body = request[\"body\"]\n    if body != \"\" {\n        var logoutData, parseErr = json.Unmarshal(body)\n        if parseErr == None {\n            var refreshToken = logoutData[\"refresh_token\"]\n            if refreshToken != None {\n                invalidateRefreshToken(refreshToken)\n            }\n        }\n    }\n\n    // Clear session cookie\n    http.SetCookie(response, \"session_id\", \"\", {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"strict\",\n        \"maxAge\": -1  // Expire immediately\n    })\n\n    var logoutResponse = {\n        \"success\": true,\n        \"message\": \"Logged out successfully\"\n    }\n\n    var jsonData, _ = json.Marshal(logoutResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/auth/#security-best-practices","title":"Security Best Practices","text":""},{"location":"stdlib/http/auth/#password-security","title":"Password Security","text":"<pre><code>import http\nimport json\n\n// Secure password hashing (conceptual - use proper crypto library)\nfunction hashPassword(password string) {\n    // In a real implementation, use bcrypt, scrypt, or Argon2\n    return bcryptHash(password, 12)  // Cost factor 12\n}\n\nfunction verifyPassword(password string, hash string) {\n    return bcryptVerify(password, hash)\n}\n\n// Password strength validation\nfunction validatePasswordStrength(password string) {\n    var errors = []\n\n    if len(password) &lt; 8 {\n        errors = append(errors, \"Password must be at least 8 characters long\")\n    }\n\n    if !containsUppercase(password) {\n        errors = append(errors, \"Password must contain at least one uppercase letter\")\n    }\n\n    if !containsLowercase(password) {\n        errors = append(errors, \"Password must contain at least one lowercase letter\")\n    }\n\n    if !containsDigit(password) {\n        errors = append(errors, \"Password must contain at least one digit\")\n    }\n\n    if !containsSpecialChar(password) {\n        errors = append(errors, \"Password must contain at least one special character\")\n    }\n\n    return errors\n}\n</code></pre>"},{"location":"stdlib/http/auth/#rate-limiting-for-authentication","title":"Rate Limiting for Authentication","text":"<pre><code>import http\nimport fmt\n\n// Authentication rate limiting\nfunction authRateLimitMiddleware(maxAttempts int, windowMinutes int) {\n    var attempts = {}  // Track failed attempts by IP\n\n    return function(next function) {\n        return function(request map, response map) {\n            var clientIP = getClientIP(request)\n            var currentTime = getCurrentMinute()\n            var key = clientIP + \":\" + currentTime\n\n            var attemptCount = attempts[key]\n            if attemptCount == None {\n                attemptCount = 0\n            }\n\n            if attemptCount &gt;= maxAttempts {\n                var errorResponse = {\n                    \"error\": \"Too Many Attempts\",\n                    \"message\": \"Too many authentication attempts. Please try again later.\",\n                    \"retryAfter\": windowMinutes * 60\n                }\n\n                http.SetResponseHeader(response, \"Retry-After\", windowMinutes * 60)\n                var jsonData, _ = json.Marshal(errorResponse)\n                http.WriteResponse(response, 429, \"application/json\", jsonData)\n                return\n            }\n\n            // Track this attempt\n            attempts[key] = attemptCount + 1\n\n            next(request, response)\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/http/auth/#csrf-protection","title":"CSRF Protection","text":"<pre><code>import http\nimport json\n\n// CSRF protection middleware\nfunction csrfProtectionMiddleware(next function) {\n    return function(request map, response map) {\n        var method = request[\"method\"]\n\n        // Only check CSRF for state-changing methods\n        if method == \"POST\" or method == \"PUT\" or method == \"DELETE\" or method == \"PATCH\" {\n            var csrfToken = getCSRFTokenFromRequest(request)\n            var sessionToken = getCSRFTokenFromSession(request)\n\n            if csrfToken == \"\" or sessionToken == \"\" or csrfToken != sessionToken {\n                var errorResponse = {\n                    \"error\": \"CSRF Token Mismatch\",\n                    \"message\": \"Invalid or missing CSRF token\"\n                }\n\n                var jsonData, _ = json.Marshal(errorResponse)\n                http.WriteResponse(response, 403, \"application/json\", jsonData)\n                return\n            }\n        }\n\n        next(request, response)\n    }\n}\n\nfunction getCSRFTokenFromRequest(request map) {\n    var headers = request[\"headers\"]\n\n    // Check X-CSRF-Token header\n    var headerToken = headers[\"X-CSRF-Token\"]\n    if headerToken != None {\n        return headerToken\n    }\n\n    // Check form data (if parsing form data)\n    var formData = request[\"formData\"]\n    if formData != None {\n        var formToken = formData[\"csrf_token\"]\n        if formToken != None {\n            return formToken\n        }\n    }\n\n    return \"\"\n}\n</code></pre>"},{"location":"stdlib/http/auth/#complete-authentication-example","title":"Complete Authentication Example","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Complete authentication setup\nfunction setupAuthenticatedServer() {\n    var mux = http.NewMux()[0]\n\n    // Public routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/login\", loginHandler)\n    http.HandleFunc(mux, \"/register\", registerHandler)\n\n    // Token management\n    http.HandleFunc(mux, \"/refresh\", tokenRefreshHandler)\n\n    // Protected routes\n    var protectedMux = http.NewMux()[0]\n\n    // User routes (requires authentication)\n    var userRoutes = chainMiddleware([jwtAuthMiddleware])(userHandler)\n    http.HandleFunc(protectedMux, \"/profile\", userRoutes)\n    http.HandleFunc(protectedMux, \"/logout\", logoutHandler)\n\n    // Admin routes (requires admin role)\n    var adminRoutes = chainMiddleware([jwtAuthMiddleware, requireRole(\"admin\")])(adminHandler)\n    http.HandleFunc(protectedMux, \"/admin\", adminRoutes)\n\n    // API routes with rate limiting\n    var apiRoutes = chainMiddleware([\n        authRateLimitMiddleware(10, 1),  // 10 attempts per minute\n        apiKeyAuthMiddleware\n    ])(apiHandler)\n    http.HandleFunc(protectedMux, \"/api/\", apiRoutes)\n\n    // Mount protected routes\n    http.Handle(mux, \"/protected/\", http.StripPrefix(\"/protected\", protectedMux))\n\n    return mux\n}\n\n// Start authenticated server\nfunction startAuthServer() {\n    var mux = setupAuthenticatedServer()\n    var server = http.NewServer(\":8080\")[0]\n\n    // Add security middleware\n    var secureHandler = chainMiddleware([\n        loggingMiddleware,\n        corsMiddleware,\n        securityHeadersMiddleware,\n        csrfProtectionMiddleware\n    ])(mux)\n\n    http.SetHandler(server, secureHandler)\n\n    fmt.Println(\"\ud83d\udd10 Authenticated server starting on :8080\")\n    http.ListenAndServe(server)\n}\n</code></pre>"},{"location":"stdlib/http/auth/#next-steps","title":"Next Steps","text":"<ul> <li>Cookies &amp; Sessions - Deep dive into cookie and session management</li> <li>Middleware - Go back to middleware concepts</li> <li>Routing &amp; Mux - URL routing and request handling</li> <li>HTTP Server - Server fundamentals</li> </ul>"},{"location":"stdlib/http/client/","title":"HTTP Client","text":"<p>The HTTP client provides simple, high-level functions for making HTTP requests. These functions handle the most common HTTP operations with minimal setup required.</p>"},{"location":"stdlib/http/client/#basic-http-methods","title":"Basic HTTP Methods","text":""},{"location":"stdlib/http/client/#httpgeturl","title":"http.Get(url)","text":"<p>Performs an HTTP GET request to the specified URL.</p> <p>Syntax: <pre><code>http.Get(url) (response, error)\n</code></pre></p> <p>Parameters: - <code>url</code> (string) - The target URL</p> <p>Returns: - <code>response</code> (map) - Response object with status, headers, and body - <code>error</code> - None on success, error message on failure</p> <p>Examples:</p> <p>Basic GET Request: A basic GET request<pre><code>import http\nimport fmt\n\n// Simple GET request\nvar result = http.Get(\"https://api.github.com/users/octocat\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    fmt.Printf(\"Status: %d\\n\", response[\"status\"])\n    fmt.Printf(\"Status Text: %s\\n\", response[\"statusText\"])\n    fmt.Printf(\"Content-Type: %s\\n\", response[\"headers\"][\"Content-Type\"])\n    fmt.Printf(\"Body: %s\\n\", response[\"body\"])\n}\n</code></pre></p> <p>API Data Fetching: <pre><code>import http\nimport json\nimport fmt\n\n// Fetch user data from API\nvar result = http.Get(\"https://jsonplaceholder.typicode.com/users/1\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Network Error: %s\\n\", err)\n} else if response[\"status\"] != 200 {\n    fmt.Printf(\"HTTP Error: %d - %s\\n\", response[\"status\"], response[\"statusText\"])\n} else {\n    // Parse JSON response\n    var userData, parseErr = json.Unmarshal(response[\"body\"])\n    if parseErr != None {\n        fmt.Printf(\"JSON Parse Error: %s\\n\", parseErr)\n    } else {\n        fmt.Printf(\"User Name: %s\\n\", userData[\"name\"])\n        fmt.Printf(\"User Email: %s\\n\", userData[\"email\"])\n    }\n}\n</code></pre></p> <p>Health Check Example: <pre><code>import http\nimport fmt\n\nfunction checkHealth(url string) {\n    var result = http.Get(url + \"/health\")\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        fmt.Printf(\"\u274c %s is DOWN - %s\\n\", url, err)\n    } else if response[\"status\"] == 200 {\n        fmt.Printf(\"\u2705 %s is UP - Status: %d\\n\", url, response[\"status\"])\n    } else {\n        fmt.Printf(\"\u26a0\ufe0f  %s has issues - Status: %d\\n\", url, response[\"status\"])\n    }\n}\n\n// Check multiple services\ncheckHealth(\"https://api.service1.com\")\ncheckHealth(\"https://api.service2.com\")\n</code></pre></p>"},{"location":"stdlib/http/client/#httpposturl-contenttype-body","title":"http.Post(url, contentType, body)","text":"<p>Performs an HTTP POST request with the specified body and content type.</p> <p>Syntax: <pre><code>http.Post(url, contentType, body) (response, error)\n</code></pre></p> <p>Parameters: - <code>url</code> (string) - The target URL - <code>contentType</code> (string) - Content-Type header value (e.g., \"application/json\") - <code>body</code> (string) - Request body content</p> <p>Examples:</p> <p>JSON POST Request: <pre><code>import http\nimport json\nimport fmt\n\n// Create user via API\nvar userData = {\"name\": \"Alice\", \"email\": \"alice@example.com\", \"role\": \"admin\"}\nvar jsonResult, jsonErr = json.Marshal(userData)\n\nif jsonErr != None {\n    fmt.Printf(\"JSON Error: %s\\n\", jsonErr)\n} else {\n    var result = http.Post(\"https://jsonplaceholder.typicode.com/users\", \"application/json\", jsonResult)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        fmt.Printf(\"Network Error: %s\\n\", err)\n    } else if response[\"status\"] == 201 {\n        fmt.Printf(\"\u2705 User created successfully!\\n\")\n        fmt.Printf(\"Response: %s\\n\", response[\"body\"])\n    } else {\n        fmt.Printf(\"\u274c Failed to create user - Status: %d\\n\", response[\"status\"])\n    }\n}\n</code></pre></p> <p>Form Data POST: <pre><code>import http\nimport fmt\n\n// Submit form data\nvar formData = \"name=John+Doe&amp;email=john@example.com&amp;message=Hello+World\"\nvar result = http.Post(\"https://httpbin.org/post\", \"application/x-www-form-urlencoded\", formData)\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    fmt.Printf(\"Form submitted - Status: %d\\n\", response[\"status\"])\n    fmt.Printf(\"Server Response: %s\\n\", response[\"body\"])\n}\n</code></pre></p> <p>API Authentication Example: <pre><code>import http\nimport json\nimport fmt\n\n// Login request\nfunction login(username string, password string) {\n    var credentials = {\"username\": username, \"password\": password}\n    var jsonData, _ = json.Marshal(credentials)\n\n    var result = http.Post(\"https://api.example.com/auth/login\", \"application/json\", jsonData)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        return None, err\n    } else if response[\"status\"] == 200 {\n        var authData, _ = json.Unmarshal(response[\"body\"])\n        return authData[\"token\"], None\n    } else {\n        return None, \"Login failed: \" + response[\"statusText\"]\n    }\n}\n\n// Usage\nvar token, loginErr = login(\"alice\", \"password123\")\nif loginErr != None {\n    fmt.Printf(\"Login Error: %s\\n\", loginErr)\n} else {\n    fmt.Printf(\"Login successful! Token: %s\\n\", token)\n}\n</code></pre></p>"},{"location":"stdlib/http/client/#httpputurl-contenttype-body","title":"http.Put(url, contentType, body)","text":"<p>Performs an HTTP PUT request for updating resources.</p> <p>Syntax: <pre><code>http.Put(url, contentType, body) (response, error)\n</code></pre></p> <p>Examples:</p> <p>Update Resource: <pre><code>import http\nimport json\nimport fmt\n\n// Update user profile\nfunction updateUser(userId string, updates map) {\n    var jsonData, jsonErr = json.Marshal(updates)\n    if jsonErr != None {\n        return jsonErr\n    }\n\n    var url = \"https://jsonplaceholder.typicode.com/users/\" + userId\n    var result = http.Put(url, \"application/json\", jsonData)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        return err\n    } else if response[\"status\"] == 200 {\n        fmt.Printf(\"\u2705 User %s updated successfully\\n\", userId)\n        return None\n    } else {\n        return \"Update failed with status: \" + response[\"statusText\"]\n    }\n}\n\n// Usage\nvar userUpdates = {\"name\": \"Alice Johnson\", \"email\": \"alice.johnson@example.com\"}\nvar updateErr = updateUser(\"1\", userUpdates)\nif updateErr != None {\n    fmt.Printf(\"Update Error: %s\\n\", updateErr)\n}\n</code></pre></p>"},{"location":"stdlib/http/client/#httpdeleteurl","title":"http.Delete(url)","text":"<p>Performs an HTTP DELETE request for removing resources.</p> <p>Syntax: <pre><code>http.Delete(url) (response, error)\n</code></pre></p> <p>Examples:</p> <p>Delete Resource: <pre><code>import http\nimport fmt\n\n// Delete user account\nfunction deleteUser(userId string) {\n    var url = \"https://jsonplaceholder.typicode.com/users/\" + userId\n    var result = http.Delete(url)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        return \"Network error: \" + err\n    } else if response[\"status\"] == 200 or response[\"status\"] == 204 {\n        fmt.Printf(\"\u2705 User %s deleted successfully\\n\", userId)\n        return None\n    } else if response[\"status\"] == 404 {\n        return \"User not found\"\n    } else {\n        return \"Delete failed with status: \" + response[\"statusText\"]\n    }\n}\n\n// Usage\nvar deleteErr = deleteUser(\"123\")\nif deleteErr != None {\n    fmt.Printf(\"Delete Error: %s\\n\", deleteErr)\n}\n</code></pre></p>"},{"location":"stdlib/http/client/#httpheadurl","title":"http.Head(url)","text":"<p>Performs an HTTP HEAD request to get headers without the response body.</p> <p>Syntax: <pre><code>http.Head(url) (response, error)\n</code></pre></p> <p>Examples:</p> <p>Check Resource Metadata: <pre><code>import http\nimport fmt\n\n// Check if resource exists and get metadata\nfunction checkResource(url string) {\n    var result = http.Head(url)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        fmt.Printf(\"\u274c Cannot reach %s: %s\\n\", url, err)\n    } else if response[\"status\"] == 200 {\n        var headers = response[\"headers\"]\n        fmt.Printf(\"\u2705 Resource exists at %s\\n\", url)\n        fmt.Printf(\"   Content-Type: %s\\n\", headers[\"Content-Type\"])\n        fmt.Printf(\"   Content-Length: %s\\n\", headers[\"Content-Length\"])\n        fmt.Printf(\"   Last-Modified: %s\\n\", headers[\"Last-Modified\"])\n    } else if response[\"status\"] == 404 {\n        fmt.Printf(\"\u274c Resource not found: %s\\n\", url)\n    } else {\n        fmt.Printf(\"\u26a0\ufe0f  Resource status: %d - %s\\n\", response[\"status\"], response[\"statusText\"])\n    }\n}\n\n// Usage\ncheckResource(\"https://httpbin.org/json\")\ncheckResource(\"https://httpbin.org/image/png\")\n</code></pre></p>"},{"location":"stdlib/http/client/#client-configuration","title":"Client Configuration","text":"<p>The HTTP client comes with sensible defaults:</p> <ul> <li>Timeout: 30 seconds</li> <li>Connection Pooling: Automatic</li> <li>Keep-Alive: Enabled</li> <li>Redirects: Automatic following</li> <li>Compression: Automatic gzip handling</li> </ul>"},{"location":"stdlib/http/client/#error-handling","title":"Error Handling","text":"<p>All HTTP client functions follow the same error handling pattern:</p> <pre><code>var result = http.Get(\"https://example.com\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    // Network errors: timeouts, DNS failures, connection refused, etc.\n    fmt.Printf(\"Network Error: %s\\n\", err)\n} else {\n    // HTTP errors: check status codes\n    if response[\"status\"] &gt;= 400 {\n        fmt.Printf(\"HTTP Error %d: %s\\n\", response[\"status\"], response[\"statusText\"])\n    } else {\n        // Success: process response\n        fmt.Printf(\"Success: %s\\n\", response[\"body\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/http/client/#common-http-status-codes","title":"Common HTTP Status Codes","text":"<ul> <li>200 OK - Request successful</li> <li>201 Created - Resource created successfully</li> <li>204 No Content - Success with no response body</li> <li>400 Bad Request - Invalid request</li> <li>401 Unauthorized - Authentication required</li> <li>403 Forbidden - Access denied</li> <li>404 Not Found - Resource not found</li> <li>500 Internal Server Error - Server error</li> </ul>"},{"location":"stdlib/http/client/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/client/#1-always-check-errors","title":"1. Always Check Errors","text":"<pre><code>var result = http.Get(url)\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    // Handle network errors first\n    return err\n}\n\nif response[\"status\"] &gt;= 400 {\n    // Then handle HTTP errors\n    return \"HTTP Error: \" + response[\"statusText\"]\n}\n\n// Process successful response\n</code></pre>"},{"location":"stdlib/http/client/#2-use-appropriate-content-types","title":"2. Use Appropriate Content Types","text":"<pre><code>// JSON data\nhttp.Post(url, \"application/json\", jsonData)\n\n// Form data\nhttp.Post(url, \"application/x-www-form-urlencoded\", formData)\n\n// Plain text\nhttp.Post(url, \"text/plain\", textData)\n</code></pre>"},{"location":"stdlib/http/client/#3-handle-different-response-types","title":"3. Handle Different Response Types","text":"<pre><code>var contentType = response[\"headers\"][\"Content-Type\"]\nif contentType == \"application/json\" {\n    var data, _ = json.Unmarshal(response[\"body\"])\n    // Process JSON data\n} else {\n    // Process as plain text\n    fmt.Println(response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/client/#next-steps","title":"Next Steps","text":"<ul> <li>Request Building - Learn about custom requests and advanced header management</li> <li>Response Handling - Deep dive into response processing</li> <li>Examples &amp; Patterns - Real-world usage patterns and advanced techniques</li> </ul>"},{"location":"stdlib/http/cookies/","title":"Cookies &amp; Sessions","text":"<p>Cookies and sessions are essential for maintaining state in web applications. This section covers cookie management, session handling, and security best practices for stateful HTTP applications.</p>"},{"location":"stdlib/http/cookies/#cookie-management","title":"Cookie Management","text":""},{"location":"stdlib/http/cookies/#httpsetcookieresponse-name-value-options","title":"http.SetCookie(response, name, value, options)","text":"<p>Sets a cookie in the HTTP response.</p> <p>Syntax: <pre><code>http.SetCookie(response, name, value, options) (error)\n</code></pre></p> <p>Parameters: - <code>response</code> (map) - Response writer object - <code>name</code> (string) - Cookie name - <code>value</code> (string) - Cookie value - <code>options</code> (map) - Cookie options (domain, path, expires, etc.)</p> <p>Examples:</p> <p>Basic Cookie Setting: <pre><code>import http\nimport fmt\n\nfunction setCookieHandler(request map, response map) {\n    // Set a simple cookie\n    http.SetCookie(response, \"user_preference\", \"dark_theme\", {})\n\n    // Set a cookie with options\n    http.SetCookie(response, \"session_id\", \"abc123xyz\", {\n        \"httpOnly\": true,        // Prevent JavaScript access\n        \"secure\": true,          // HTTPS only\n        \"sameSite\": \"strict\",    // CSRF protection\n        \"maxAge\": 3600,          // 1 hour expiration\n        \"path\": \"/\",             // Available site-wide\n        \"domain\": \".example.com\" // Available on subdomains\n    })\n\n    // Set a persistent cookie (expires in 30 days)\n    var thirtyDaysFromNow = getCurrentTimestamp() + (30 * 24 * 3600)\n    http.SetCookie(response, \"remember_me\", \"true\", {\n        \"expires\": thirtyDaysFromNow,\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"lax\"\n    })\n\n    http.WriteResponse(response, 200, \"text/plain\", \"Cookies set successfully\")\n}\n</code></pre></p> <p>Cookie Configuration Options: <pre><code>import http\n\n// Comprehensive cookie configuration\nfunction setSecureCookie(response map, name string, value string) {\n    var cookieOptions = {\n        \"httpOnly\": true,           // Prevent XSS attacks\n        \"secure\": true,             // HTTPS only\n        \"sameSite\": \"strict\",       // CSRF protection\n        \"maxAge\": 3600,             // 1 hour\n        \"path\": \"/\",                // Available site-wide\n        \"domain\": \"\",               // Current domain only\n    }\n\n    http.SetCookie(response, name, value, cookieOptions)\n}\n\n// Session cookie (expires when browser closes)\nfunction setSessionCookie(response map, name string, value string) {\n    var sessionOptions = {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"strict\",\n        \"path\": \"/\"\n        // No maxAge or expires = session cookie\n    }\n\n    http.SetCookie(response, name, value, sessionOptions)\n}\n\n// Persistent cookie (long-term storage)\nfunction setPersistentCookie(response map, name string, value string, days int) {\n    var expirationTime = getCurrentTimestamp() + (days * 24 * 3600)\n\n    var persistentOptions = {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"lax\",\n        \"expires\": expirationTime,\n        \"path\": \"/\"\n    }\n\n    http.SetCookie(response, name, value, persistentOptions)\n}\n</code></pre></p>"},{"location":"stdlib/http/cookies/#httpgetcookierequest-name","title":"http.GetCookie(request, name)","text":"<p>Gets a cookie value from the HTTP request.</p> <p>Syntax: <pre><code>http.GetCookie(request, name) (value, error)\n</code></pre></p> <p>Parameters: - <code>request</code> (map) - Request object - <code>name</code> (string) - Cookie name</p> <p>Examples:</p> <p>Reading Cookies: <pre><code>import http\nimport json\nimport fmt\n\nfunction getCookieHandler(request map, response map) {\n    // Get a specific cookie\n    var sessionResult = http.GetCookie(request, \"session_id\")\n    var sessionId = sessionResult[0]\n    var sessionErr = sessionResult[1]\n\n    if sessionErr != None {\n        fmt.Printf(\"No session cookie found: %s\\n\", sessionErr)\n    } else {\n        fmt.Printf(\"Session ID: %s\\n\", sessionId)\n    }\n\n    // Get user preferences\n    var themeResult = http.GetCookie(request, \"user_preference\")\n    var theme = themeResult[0]\n    var themeErr = themeResult[1]\n\n    var responseData = {\n        \"sessionId\": sessionId,\n        \"theme\": theme,\n        \"hasSession\": sessionErr == None,\n        \"hasTheme\": themeErr == None\n    }\n\n    var jsonData, _ = json.Marshal(responseData)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// Get all cookies from request\nfunction getAllCookies(request map) {\n    var cookies = request[\"cookies\"]\n    if cookies == None {\n        return {}\n    }\n    return cookies\n}\n\nfunction listCookiesHandler(request map, response map) {\n    var allCookies = getAllCookies(request)\n\n    var cookieList = []\n    for name, value in allCookies {\n        cookieList = append(cookieList, {\n            \"name\": name,\n            \"value\": value\n        })\n    }\n\n    var responseData = {\n        \"cookies\": cookieList,\n        \"count\": len(cookieList)\n    }\n\n    var jsonData, _ = json.Marshal(responseData)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre></p>"},{"location":"stdlib/http/cookies/#cookie-deletion","title":"Cookie Deletion","text":"<pre><code>import http\n\n// Delete a cookie by setting it to expire immediately\nfunction deleteCookie(response map, name string) {\n    http.SetCookie(response, name, \"\", {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"strict\",\n        \"maxAge\": -1,    // Expire immediately\n        \"path\": \"/\"\n    })\n}\n\nfunction deleteCookieHandler(request map, response map) {\n    var query = request[\"query\"]\n    var cookieName = query[\"name\"]\n\n    if cookieName == None or cookieName == \"\" {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Cookie name required\\\"}\")\n        return\n    }\n\n    deleteCookie(response, cookieName)\n\n    var responseData = {\n        \"message\": \"Cookie deleted\",\n        \"cookieName\": cookieName\n    }\n\n    var jsonData, _ = json.Marshal(responseData)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#session-management","title":"Session Management","text":""},{"location":"stdlib/http/cookies/#session-store-implementation","title":"Session Store Implementation","text":"<pre><code>import http\nimport json\nimport fmt\n\n// In-memory session store (use Redis/database in production)\nvar sessionStore = {}\n\n// Session structure\ntype Session struct {\n    id string\n    userId string\n    data map\n    createdAt int\n    lastAccessed int\n    expiresAt int\n}\n\n// Create a new session\nfunction createSession(userId string, sessionData map) {\n    var sessionId = generateSessionId()\n    var currentTime = getCurrentTimestamp()\n\n    var session = {\n        \"id\": sessionId,\n        \"userId\": userId,\n        \"data\": sessionData,\n        \"createdAt\": currentTime,\n        \"lastAccessed\": currentTime,\n        \"expiresAt\": currentTime + 3600  // 1 hour default\n    }\n\n    sessionStore[sessionId] = session\n    return session\n}\n\n// Get session by ID\nfunction getSession(sessionId string) {\n    var session = sessionStore[sessionId]\n\n    if session == None {\n        return None\n    }\n\n    // Check if session is expired\n    if isSessionExpired(session) {\n        delete(sessionStore, sessionId)\n        return None\n    }\n\n    // Update last accessed time\n    session[\"lastAccessed\"] = getCurrentTimestamp()\n    return session\n}\n\n// Update session data\nfunction updateSession(sessionId string, data map) {\n    var session = sessionStore[sessionId]\n    if session != None {\n        session[\"data\"] = data\n        session[\"lastAccessed\"] = getCurrentTimestamp()\n        return true\n    }\n    return false\n}\n\n// Destroy session\nfunction destroySession(sessionId string) {\n    delete(sessionStore, sessionId)\n}\n\n// Check if session is expired\nfunction isSessionExpired(session map) {\n    var expiresAt = session[\"expiresAt\"]\n    var currentTime = getCurrentTimestamp()\n    return currentTime &gt; expiresAt\n}\n\n// Generate secure session ID\nfunction generateSessionId() {\n    // In a real implementation, use cryptographically secure random generator\n    return \"sess_\" + generateRandomString(64)\n}\n\n// Clean up expired sessions (run periodically)\nfunction cleanupExpiredSessions() {\n    var currentTime = getCurrentTimestamp()\n    var expiredSessions = []\n\n    for sessionId, session in sessionStore {\n        if currentTime &gt; session[\"expiresAt\"] {\n            expiredSessions = append(expiredSessions, sessionId)\n        }\n    }\n\n    for sessionId in expiredSessions {\n        delete(sessionStore, sessionId)\n    }\n\n    fmt.Printf(\"Cleaned up %d expired sessions\\n\", len(expiredSessions))\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#session-middleware","title":"Session Middleware","text":"<pre><code>import http\nimport fmt\n\n// Session middleware that loads session data into request\nfunction sessionMiddleware(next function) {\n    return function(request map, response map) {\n        var sessionId = getSessionIdFromCookie(request)\n\n        if sessionId != \"\" {\n            var session = getSession(sessionId)\n            if session != None {\n                // Add session to request context\n                request[\"session\"] = session\n                request[\"sessionId\"] = sessionId\n                request[\"userId\"] = session[\"userId\"]\n                request[\"sessionData\"] = session[\"data\"]\n            }\n        }\n\n        next(request, response)\n    }\n}\n\nfunction getSessionIdFromCookie(request map) {\n    var cookieResult = http.GetCookie(request, \"session_id\")\n    var sessionId = cookieResult[0]\n    var err = cookieResult[1]\n\n    if err != None {\n        return \"\"\n    }\n\n    return sessionId\n}\n\n// Session-aware handler example\nfunction sessionAwareHandler(request map, response map) {\n    var session = request[\"session\"]\n    var sessionData = request[\"sessionData\"]\n\n    if session == None {\n        // No session - show login prompt\n        var responseData = {\n            \"authenticated\": false,\n            \"message\": \"Please log in\"\n        }\n        var jsonData, _ = json.Marshal(responseData)\n        http.WriteResponse(response, 401, \"application/json\", jsonData)\n        return\n    }\n\n    // Session exists - show user data\n    var responseData = {\n        \"authenticated\": true,\n        \"userId\": session[\"userId\"],\n        \"sessionData\": sessionData,\n        \"lastAccessed\": session[\"lastAccessed\"]\n    }\n\n    var jsonData, _ = json.Marshal(responseData)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#login-with-session-creation","title":"Login with Session Creation","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction loginWithSessionHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    if method != \"POST\" {\n        http.WriteResponse(response, 405, \"application/json\", \"{\\\"error\\\": \\\"Method not allowed\\\"}\")\n        return\n    }\n\n    var body = request[\"body\"]\n    var loginData, parseErr = json.Unmarshal(body)\n\n    if parseErr != None {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Invalid JSON\\\"}\")\n        return\n    }\n\n    var username = loginData[\"username\"]\n    var password = loginData[\"password\"]\n    var rememberMe = loginData[\"rememberMe\"]\n\n    // Authenticate user\n    var user = authenticateUser(username, password)\n    if user == None {\n        http.WriteResponse(response, 401, \"application/json\", \"{\\\"error\\\": \\\"Invalid credentials\\\"}\")\n        return\n    }\n\n    // Create session with user data\n    var sessionData = {\n        \"username\": user[\"username\"],\n        \"email\": user[\"email\"],\n        \"roles\": user[\"roles\"],\n        \"loginTime\": getCurrentTimestamp()\n    }\n\n    var session = createSession(user[\"id\"], sessionData)\n\n    // Set session cookie\n    var cookieOptions = {\n        \"httpOnly\": true,\n        \"secure\": true,\n        \"sameSite\": \"strict\",\n        \"path\": \"/\"\n    }\n\n    // Set expiration based on \"remember me\"\n    if rememberMe == true {\n        cookieOptions[\"maxAge\"] = 30 * 24 * 3600  // 30 days\n        session[\"expiresAt\"] = getCurrentTimestamp() + (30 * 24 * 3600)\n    } else {\n        // Session cookie (expires when browser closes)\n        session[\"expiresAt\"] = getCurrentTimestamp() + 3600  // 1 hour\n    }\n\n    http.SetCookie(response, \"session_id\", session[\"id\"], cookieOptions)\n\n    var loginResponse = {\n        \"success\": true,\n        \"user\": {\n            \"id\": user[\"id\"],\n            \"username\": user[\"username\"],\n            \"email\": user[\"email\"]\n        },\n        \"sessionId\": session[\"id\"]\n    }\n\n    var jsonData, _ = json.Marshal(loginResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction logoutWithSessionHandler(request map, response map) {\n    var sessionId = getSessionIdFromCookie(request)\n\n    if sessionId != \"\" {\n        destroySession(sessionId)\n    }\n\n    // Clear session cookie\n    deleteCookie(response, \"session_id\")\n\n    var logoutResponse = {\n        \"success\": true,\n        \"message\": \"Logged out successfully\"\n    }\n\n    var jsonData, _ = json.Marshal(logoutResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#shopping-cart-example","title":"Shopping Cart Example","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Shopping cart using sessions\nfunction addToCartHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    if method != \"POST\" {\n        http.WriteResponse(response, 405, \"application/json\", \"{\\\"error\\\": \\\"Method not allowed\\\"}\")\n        return\n    }\n\n    var body = request[\"body\"]\n    var cartData, parseErr = json.Unmarshal(body)\n\n    if parseErr != None {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Invalid JSON\\\"}\")\n        return\n    }\n\n    var productId = cartData[\"productId\"]\n    var quantity = cartData[\"quantity\"]\n\n    if productId == None or quantity == None {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Product ID and quantity required\\\"}\")\n        return\n    }\n\n    // Get or create session\n    var sessionId = getSessionIdFromCookie(request)\n    var session = None\n\n    if sessionId != \"\" {\n        session = getSession(sessionId)\n    }\n\n    if session == None {\n        // Create new session for anonymous user\n        session = createSession(\"anonymous\", {\"cart\": {}})\n\n        http.SetCookie(response, \"session_id\", session[\"id\"], {\n            \"httpOnly\": true,\n            \"secure\": true,\n            \"sameSite\": \"strict\",\n            \"maxAge\": 3600,  // 1 hour\n            \"path\": \"/\"\n        })\n    }\n\n    // Get current cart\n    var sessionData = session[\"data\"]\n    var cart = sessionData[\"cart\"]\n    if cart == None {\n        cart = {}\n    }\n\n    // Add item to cart\n    var currentQuantity = cart[productId]\n    if currentQuantity == None {\n        currentQuantity = 0\n    }\n    cart[productId] = currentQuantity + quantity\n\n    // Update session\n    sessionData[\"cart\"] = cart\n    updateSession(session[\"id\"], sessionData)\n\n    var cartResponse = {\n        \"success\": true,\n        \"cart\": cart,\n        \"itemCount\": getCartItemCount(cart)\n    }\n\n    var jsonData, _ = json.Marshal(cartResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction getCartHandler(request map, response map) {\n    var sessionId = getSessionIdFromCookie(request)\n    var cart = {}\n\n    if sessionId != \"\" {\n        var session = getSession(sessionId)\n        if session != None {\n            var sessionData = session[\"data\"]\n            cart = sessionData[\"cart\"]\n            if cart == None {\n                cart = {}\n            }\n        }\n    }\n\n    var cartResponse = {\n        \"cart\": cart,\n        \"itemCount\": getCartItemCount(cart),\n        \"total\": calculateCartTotal(cart)\n    }\n\n    var jsonData, _ = json.Marshal(cartResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction getCartItemCount(cart map) {\n    var count = 0\n    for productId, quantity in cart {\n        count = count + quantity\n    }\n    return count\n}\n\nfunction calculateCartTotal(cart map) {\n    // In a real implementation, look up product prices\n    var total = 0.0\n    for productId, quantity in cart {\n        var price = getProductPrice(productId)  // Mock function\n        total = total + (price * quantity)\n    }\n    return total\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#security-best-practices","title":"Security Best Practices","text":""},{"location":"stdlib/http/cookies/#secure-cookie-configuration","title":"Secure Cookie Configuration","text":"<pre><code>import http\n\n// Production-ready secure cookie settings\nfunction setSecureSessionCookie(response map, sessionId string) {\n    var secureOptions = {\n        \"httpOnly\": true,        // Prevent XSS attacks\n        \"secure\": true,          // HTTPS only\n        \"sameSite\": \"strict\",    // CSRF protection\n        \"maxAge\": 3600,          // 1 hour expiration\n        \"path\": \"/\",             // Available site-wide\n        \"domain\": \"\",            // Current domain only (no subdomains)\n    }\n\n    http.SetCookie(response, \"session_id\", sessionId, secureOptions)\n}\n\n// Development cookie settings (less restrictive)\nfunction setDevelopmentCookie(response map, name string, value string) {\n    var devOptions = {\n        \"httpOnly\": true,\n        \"secure\": false,         // Allow HTTP in development\n        \"sameSite\": \"lax\",       // Less restrictive for development\n        \"maxAge\": 3600,\n        \"path\": \"/\"\n    }\n\n    http.SetCookie(response, name, value, devOptions)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#session-security","title":"Session Security","text":"<pre><code>import http\nimport fmt\n\n// Session security middleware\nfunction sessionSecurityMiddleware(next function) {\n    return function(request map, response map) {\n        var sessionId = getSessionIdFromCookie(request)\n\n        if sessionId != \"\" {\n            var session = getSession(sessionId)\n\n            if session != None {\n                // Check for session hijacking\n                if detectSessionHijacking(request, session) {\n                    fmt.Printf(\"Potential session hijacking detected for session: %s\\n\", sessionId)\n                    destroySession(sessionId)\n                    deleteCookie(response, \"session_id\")\n\n                    http.WriteResponse(response, 401, \"application/json\", \"{\\\"error\\\": \\\"Session security violation\\\"}\")\n                    return\n                }\n\n                // Regenerate session ID periodically\n                if shouldRegenerateSessionId(session) {\n                    var newSessionId = regenerateSessionId(session)\n                    http.SetCookie(response, \"session_id\", newSessionId, {\n                        \"httpOnly\": true,\n                        \"secure\": true,\n                        \"sameSite\": \"strict\",\n                        \"maxAge\": 3600,\n                        \"path\": \"/\"\n                    })\n                }\n            }\n        }\n\n        next(request, response)\n    }\n}\n\nfunction detectSessionHijacking(request map, session map) {\n    // Check IP address consistency\n    var currentIP = getClientIP(request)\n    var sessionIP = session[\"data\"][\"ipAddress\"]\n\n    if sessionIP != None and sessionIP != currentIP {\n        return true\n    }\n\n    // Check User-Agent consistency\n    var currentUA = request[\"headers\"][\"User-Agent\"]\n    var sessionUA = session[\"data\"][\"userAgent\"]\n\n    if sessionUA != None and sessionUA != currentUA {\n        return true\n    }\n\n    return false\n}\n\nfunction shouldRegenerateSessionId(session map) {\n    var lastRegeneration = session[\"data\"][\"lastRegeneration\"]\n    var currentTime = getCurrentTimestamp()\n\n    // Regenerate every 30 minutes\n    return lastRegeneration == None or (currentTime - lastRegeneration) &gt; 1800\n}\n\nfunction regenerateSessionId(oldSession map) {\n    var newSessionId = generateSessionId()\n    var oldSessionId = oldSession[\"id\"]\n\n    // Copy session data to new ID\n    oldSession[\"id\"] = newSessionId\n    oldSession[\"data\"][\"lastRegeneration\"] = getCurrentTimestamp()\n\n    sessionStore[newSessionId] = oldSession\n    delete(sessionStore, oldSessionId)\n\n    return newSessionId\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#csrf-protection-with-sessions","title":"CSRF Protection with Sessions","text":"<pre><code>import http\nimport json\n\n// Generate CSRF token for session\nfunction generateCSRFToken(sessionId string) {\n    var token = generateRandomString(32)\n    var session = getSession(sessionId)\n\n    if session != None {\n        session[\"data\"][\"csrfToken\"] = token\n        updateSession(sessionId, session[\"data\"])\n    }\n\n    return token\n}\n\n// CSRF protection middleware using sessions\nfunction sessionCSRFMiddleware(next function) {\n    return function(request map, response map) {\n        var method = request[\"method\"]\n\n        // Only check CSRF for state-changing methods\n        if method == \"POST\" or method == \"PUT\" or method == \"DELETE\" or method == \"PATCH\" {\n            var sessionId = getSessionIdFromCookie(request)\n            var session = getSession(sessionId)\n\n            if session == None {\n                http.WriteResponse(response, 401, \"application/json\", \"{\\\"error\\\": \\\"No session found\\\"}\")\n                return\n            }\n\n            var sessionCSRFToken = session[\"data\"][\"csrfToken\"]\n            var requestCSRFToken = request[\"headers\"][\"X-CSRF-Token\"]\n\n            if sessionCSRFToken == None or requestCSRFToken == None or sessionCSRFToken != requestCSRFToken {\n                http.WriteResponse(response, 403, \"application/json\", \"{\\\"error\\\": \\\"CSRF token mismatch\\\"}\")\n                return\n            }\n        }\n\n        next(request, response)\n    }\n}\n\n// Endpoint to get CSRF token\nfunction getCSRFTokenHandler(request map, response map) {\n    var sessionId = getSessionIdFromCookie(request)\n\n    if sessionId == \"\" {\n        http.WriteResponse(response, 401, \"application/json\", \"{\\\"error\\\": \\\"No session found\\\"}\")\n        return\n    }\n\n    var csrfToken = generateCSRFToken(sessionId)\n\n    var tokenResponse = {\n        \"csrfToken\": csrfToken\n    }\n\n    var jsonData, _ = json.Marshal(tokenResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#complete-session-based-application","title":"Complete Session-Based Application","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Complete session-based web application setup\nfunction setupSessionBasedApp() {\n    var mux = http.NewMux()[0]\n\n    // Public routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/login\", loginWithSessionHandler)\n    http.HandleFunc(mux, \"/register\", registerHandler)\n\n    // Session-protected routes\n    var sessionMux = http.NewMux()[0]\n\n    // Apply session middleware to all protected routes\n    var sessionHandler = sessionMiddleware(sessionMux)\n\n    // Protected endpoints\n    http.HandleFunc(sessionMux, \"/profile\", profileHandler)\n    http.HandleFunc(sessionMux, \"/logout\", logoutWithSessionHandler)\n    http.HandleFunc(sessionMux, \"/cart\", getCartHandler)\n    http.HandleFunc(sessionMux, \"/cart/add\", addToCartHandler)\n    http.HandleFunc(sessionMux, \"/csrf-token\", getCSRFTokenHandler)\n\n    // Mount session-protected routes\n    http.Handle(mux, \"/app/\", http.StripPrefix(\"/app\", sessionHandler))\n\n    return mux\n}\n\nfunction startSessionServer() {\n    var mux = setupSessionBasedApp()\n    var server = http.NewServer(\":8080\")[0]\n\n    // Add security middleware\n    var secureHandler = chainMiddleware([\n        loggingMiddleware,\n        corsMiddleware,\n        securityHeadersMiddleware,\n        sessionSecurityMiddleware,\n        sessionCSRFMiddleware\n    ])(mux)\n\n    http.SetHandler(server, secureHandler)\n\n    // Start session cleanup routine\n    go cleanupExpiredSessions()  // Run in background\n\n    fmt.Println(\"\ud83c\udf6a Session-based server starting on :8080\")\n    http.ListenAndServe(server)\n}\n</code></pre>"},{"location":"stdlib/http/cookies/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"stdlib/http/cookies/#1-cookie-security","title":"1. Cookie Security","text":"<ul> <li>Always use <code>httpOnly</code> for session cookies</li> <li>Use <code>secure</code> flag for HTTPS</li> <li>Set appropriate <code>sameSite</code> values</li> <li>Use reasonable expiration times</li> </ul>"},{"location":"stdlib/http/cookies/#2-session-management","title":"2. Session Management","text":"<ul> <li>Generate cryptographically secure session IDs</li> <li>Store minimal data in sessions</li> <li>Implement session expiration and cleanup</li> <li>Regenerate session IDs periodically</li> </ul>"},{"location":"stdlib/http/cookies/#3-security-measures","title":"3. Security Measures","text":"<ul> <li>Implement CSRF protection</li> <li>Detect and prevent session hijacking</li> <li>Use secure cookie configurations</li> <li>Validate session integrity</li> </ul>"},{"location":"stdlib/http/cookies/#4-performance","title":"4. Performance","text":"<ul> <li>Clean up expired sessions regularly</li> <li>Use external session stores (Redis) for scalability</li> <li>Implement session data compression if needed</li> <li>Monitor session storage usage</li> </ul>"},{"location":"stdlib/http/cookies/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication - Go back to authentication concepts</li> <li>Middleware - Learn about middleware patterns</li> <li>Routing &amp; Mux - URL routing and request handling</li> <li>Examples &amp; Patterns - See real-world implementation examples</li> </ul>"},{"location":"stdlib/http/examples/","title":"Examples &amp; Patterns","text":"<p>This section provides real-world examples and common patterns for using the HTTP module effectively in production applications.</p>"},{"location":"stdlib/http/examples/#complete-api-client-example","title":"Complete API Client Example","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Complete API client for a REST service\ntype APIClient struct {\n    baseUrl string\n    token string\n    userAgent string\n}\n\nfunction newAPIClient(baseUrl string, token string) {\n    return {\n        \"baseUrl\": baseUrl,\n        \"token\": token,\n        \"userAgent\": \"HarneetApp/1.0\"\n    }\n}\n\nfunction apiRequest(client map, method string, endpoint string, data map) {\n    var url = client[\"baseUrl\"] + endpoint\n\n    var body = \"\"\n    if data != None {\n        var jsonData, _ = json.Marshal(data)\n        body = jsonData\n    }\n\n    var request = http.NewRequest(method, url, body)[0]\n\n    // Standard headers\n    request = http.SetHeader(request, \"Content-Type\", \"application/json\")[0]\n    request = http.SetHeader(request, \"Accept\", \"application/json\")[0]\n    request = http.SetHeader(request, \"User-Agent\", client[\"userAgent\"])[0]\n\n    // Authentication\n    if client[\"token\"] != \"\" {\n        request = http.SetHeader(request, \"Authorization\", \"Bearer \" + client[\"token\"])[0]\n    }\n\n    var result = http.Do(request)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        return None, \"Network error: \" + err\n    }\n\n    if response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300 {\n        var responseData, parseErr = json.Unmarshal(response[\"body\"])\n        if parseErr != None {\n            return None, \"JSON parse error: \" + parseErr\n        }\n        return responseData, None\n    } else {\n        return None, \"HTTP error \" + response[\"status\"] + \": \" + response[\"statusText\"]\n    }\n}\n\n// Usage example\nvar client = newAPIClient(\"https://api.example.com\", \"your-token-here\")\n\n// Get users\nvar users, getUsersErr = apiRequest(client, \"GET\", \"/users\", None)\nif getUsersErr != None {\n    fmt.Printf(\"Get users failed: %s\\n\", getUsersErr)\n} else {\n    fmt.Printf(\"Found %d users\\n\", len(users))\n}\n\n// Create user\nvar newUserData = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\nvar createdUser, createErr = apiRequest(client, \"POST\", \"/users\", newUserData)\nif createErr != None {\n    fmt.Printf(\"Create user failed: %s\\n\", createErr)\n} else {\n    fmt.Printf(\"Created user: %s\\n\", createdUser[\"name\"])\n}\n</code></pre>"},{"location":"stdlib/http/examples/#retry-logic-with-exponential-backoff","title":"Retry Logic with Exponential Backoff","text":"<pre><code>import http\nimport fmt\n\nfunction requestWithRetry(request map, maxRetries int) {\n    var attempt = 0\n    var delay = 1  // Start with 1 second delay\n\n    for attempt &lt; maxRetries {\n        attempt = attempt + 1\n\n        var result = http.Do(request)\n        var response = result[0]\n        var err = result[1]\n\n        if err != None {\n            fmt.Printf(\"Attempt %d failed: %s\\n\", attempt, err)\n            if attempt &lt; maxRetries {\n                fmt.Printf(\"Retrying in %d seconds...\\n\", delay)\n                // In real implementation, add sleep here\n                delay = delay * 2  // Exponential backoff\n            }\n        } else if response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300 {\n            fmt.Printf(\"\u2705 Request succeeded on attempt %d\\n\", attempt)\n            return response, None\n        } else if response[\"status\"] &gt;= 500 {\n            fmt.Printf(\"Server error (attempt %d): %d - %s\\n\", attempt, response[\"status\"], response[\"statusText\"])\n            if attempt &lt; maxRetries {\n                fmt.Printf(\"Retrying server error in %d seconds...\\n\", delay)\n                delay = delay * 2\n            }\n        } else {\n            fmt.Printf(\"\u274c Client error: %d - %s\\n\", response[\"status\"], response[\"statusText\"])\n            return response, \"Client error - not retrying\"\n        }\n    }\n\n    return None, \"All retry attempts failed\"\n}\n\n// Usage\nvar request = http.NewRequest(\"GET\", \"https://unreliable-api.example.com/data\", \"\")[0]\nvar authRequest = http.SetHeader(request, \"Authorization\", \"Bearer token123\")[0]\nvar response, retryErr = requestWithRetry(authRequest, 3)\n\nif retryErr != None {\n    fmt.Printf(\"Final Error: %s\\n\", retryErr)\n} else {\n    fmt.Printf(\"Success: %s\\n\", response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/examples/#parallel-api-requests","title":"Parallel API Requests","text":"<pre><code>import http\nimport fmt\n\n// Make multiple API calls in sequence (simulated parallel)\nfunction parallelAPIRequests() {\n    var endpoints = [\n        {\"path\": \"/users\", \"name\": \"Users\"},\n        {\"path\": \"/posts\", \"name\": \"Posts\"},\n        {\"path\": \"/comments\", \"name\": \"Comments\"}\n    ]\n    var baseUrl = \"https://jsonplaceholder.typicode.com\"\n\n    var results = []\n\n    fmt.Println(\"Making parallel API requests...\")\n\n    for endpoint in endpoints {\n        var url = baseUrl + endpoint[\"path\"]\n        var request = http.NewRequest(\"GET\", url, \"\")[0]\n        var userAgentRequest = http.SetHeader(request, \"User-Agent\", \"HarneetApp/1.0\")[0]\n\n        var result = http.Do(userAgentRequest)\n        var response = result[0]\n        var err = result[1]\n\n        var requestResult = {\n            \"endpoint\": endpoint[\"name\"],\n            \"success\": false,\n            \"status\": 0,\n            \"error\": None\n        }\n\n        if err != None {\n            requestResult[\"error\"] = err\n            fmt.Printf(\"\u274c %s failed: %s\\n\", endpoint[\"name\"], err)\n        } else {\n            requestResult[\"success\"] = response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300\n            requestResult[\"status\"] = response[\"status\"]\n\n            if requestResult[\"success\"] {\n                fmt.Printf(\"\u2705 %s: Status %d\\n\", endpoint[\"name\"], response[\"status\"])\n            } else {\n                fmt.Printf(\"\u274c %s: Status %d\\n\", endpoint[\"name\"], response[\"status\"])\n            }\n        }\n\n        results = append(results, requestResult)\n    }\n\n    // Summary\n    var successCount = 0\n    for result in results {\n        if result[\"success\"] {\n            successCount = successCount + 1\n        }\n    }\n\n    fmt.Printf(\"\\nSummary: %d/%d requests successful\\n\", successCount, len(results))\n    return results\n}\n\n// Execute parallel requests\nvar results = parallelAPIRequests()\n</code></pre>"},{"location":"stdlib/http/examples/#requestresponse-logging","title":"Request/Response Logging","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Detailed logging for debugging\nfunction loggedAPICall(method string, url string, body string, headers map) {\n    fmt.Printf(\"\ud83d\udd04 Making %s request to %s\\n\", method, url)\n\n    // Create request\n    var request = http.NewRequest(method, url, body)[0]\n\n    // Add headers\n    for key, value in headers {\n        request = http.SetHeader(request, key, value)[0]\n    }\n\n    // Log request details\n    fmt.Printf(\"\ud83d\udce4 Request Details:\\n\")\n    fmt.Printf(\"   Method: %s\\n\", method)\n    fmt.Printf(\"   URL: %s\\n\", url)\n    fmt.Printf(\"   Body: %s\\n\", body)\n    fmt.Printf(\"   Headers:\\n\")\n    var requestHeaders = request[\"headers\"]\n    for key, value in requestHeaders {\n        fmt.Printf(\"     %s: %s\\n\", key, value)\n    }\n\n    // Execute request\n    var result = http.Do(request)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        fmt.Printf(\"\u274c Request failed: %s\\n\", err)\n        return None\n    }\n\n    // Log response details\n    fmt.Printf(\"\ud83d\udce5 Response Details:\\n\")\n    fmt.Printf(\"   Status: %d - %s\\n\", response[\"status\"], response[\"statusText\"])\n    fmt.Printf(\"   Headers:\\n\")\n    var responseHeaders = response[\"headers\"]\n    for key, value in responseHeaders {\n        fmt.Printf(\"     %s: %s\\n\", key, value)\n    }\n    fmt.Printf(\"   Body: %s\\n\", response[\"body\"])\n\n    return response\n}\n\n// Usage\nvar headers = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"Bearer token123\",\n    \"X-API-Version\": \"v1\"\n}\n\nvar requestBody = \"{\\\"action\\\": \\\"test\\\"}\"\nvar response = loggedAPICall(\"POST\", \"https://httpbin.org/post\", requestBody, headers)\n</code></pre>"},{"location":"stdlib/http/examples/#file-upload-simulation","title":"File Upload Simulation","text":"<pre><code>import http\nimport fmt\n\n// Simulate file upload with multipart form data\nfunction uploadFile(url string, filename string, content string, token string) {\n    // Create multipart form data (simplified)\n    var boundary = \"----HarneetFormBoundary7MA4YWxkTrZu0gW\"\n    var formData = \"--\" + boundary + \"\\r\\n\"\n    formData = formData + \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"\" + filename + \"\\\"\\r\\n\"\n    formData = formData + \"Content-Type: text/plain\\r\\n\\r\\n\"\n    formData = formData + content + \"\\r\\n\"\n    formData = formData + \"--\" + boundary + \"--\\r\\n\"\n\n    var request = http.NewRequest(\"POST\", url, formData)[0]\n\n    // Set multipart content type\n    var contentType = \"multipart/form-data; boundary=\" + boundary\n    request = http.SetHeader(request, \"Content-Type\", contentType)[0]\n\n    // Add authentication\n    if token != \"\" {\n        request = http.SetHeader(request, \"Authorization\", \"Bearer \" + token)[0]\n    }\n\n    var result = http.Do(request)\n    var response = result[0]\n    var err = result[1]\n\n    if err != None {\n        return \"Upload failed: \" + err\n    } else if response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300 {\n        fmt.Printf(\"\u2705 File uploaded successfully: %s\\n\", filename)\n        return None\n    } else {\n        return \"Upload failed with status: \" + response[\"statusText\"]\n    }\n}\n\n// Usage\nvar uploadErr = uploadFile(\n    \"https://httpbin.org/post\",\n    \"test.txt\",\n    \"This is the file content\",\n    \"token123\"\n)\n\nif uploadErr != None {\n    fmt.Printf(\"Upload Error: %s\\n\", uploadErr)\n}\n</code></pre>"},{"location":"stdlib/http/examples/#api-rate-limiting-handler","title":"API Rate Limiting Handler","text":"<pre><code>import http\nimport fmt\n\n// Handle API rate limiting with automatic retry\nfunction rateLimitedRequest(request map) {\n    var maxRetries = 5\n    var attempt = 0\n\n    for attempt &lt; maxRetries {\n        attempt = attempt + 1\n\n        var result = http.Do(request)\n        var response = result[0]\n        var err = result[1]\n\n        if err != None {\n            fmt.Printf(\"Network error: %s\\n\", err)\n            return None, err\n        }\n\n        var status = response[\"status\"]\n\n        if status == 429 {\n            // Rate limited\n            var retryAfter = response[\"headers\"][\"Retry-After\"]\n            if retryAfter != None {\n                fmt.Printf(\"Rate limited. Retry after: %s seconds\\n\", retryAfter)\n            } else {\n                fmt.Printf(\"Rate limited. Waiting before retry...\\n\")\n            }\n\n            if attempt &lt; maxRetries {\n                // In real implementation, wait for the specified time\n                fmt.Printf(\"Retrying in attempt %d...\\n\", attempt + 1)\n            }\n        } else if status &gt;= 200 and status &lt; 300 {\n            fmt.Printf(\"\u2705 Request successful after %d attempts\\n\", attempt)\n            return response, None\n        } else {\n            fmt.Printf(\"\u274c Request failed with status: %d\\n\", status)\n            return response, \"HTTP error: \" + response[\"statusText\"]\n        }\n    }\n\n    return None, \"Rate limit retries exhausted\"\n}\n\n// Usage\nvar request = http.NewRequest(\"GET\", \"https://api.example.com/data\", \"\")[0]\nvar authRequest = http.SetHeader(request, \"Authorization\", \"Bearer token123\")[0]\nvar response, rateLimitErr = rateLimitedRequest(authRequest)\n\nif rateLimitErr != None {\n    fmt.Printf(\"Rate Limit Error: %s\\n\", rateLimitErr)\n} else {\n    fmt.Printf(\"Success: %s\\n\", response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/examples/#configuration-driven-api-client","title":"Configuration-Driven API Client","text":"<pre><code>import http\nimport json\nimport fmt\n\n// API client with configuration\ntype APIConfig struct {\n    baseUrl string\n    timeout int\n    retries int\n    headers map\n}\n\nfunction createAPIConfig(baseUrl string) {\n    return {\n        \"baseUrl\": baseUrl,\n        \"timeout\": 30,\n        \"retries\": 3,\n        \"headers\": {\n            \"User-Agent\": \"HarneetApp/1.0\",\n            \"Accept\": \"application/json\"\n        }\n    }\n}\n\nfunction configuredRequest(config map, method string, endpoint string, data map, authToken string) {\n    var url = config[\"baseUrl\"] + endpoint\n\n    var body = \"\"\n    if data != None {\n        var jsonData, _ = json.Marshal(data)\n        body = jsonData\n    }\n\n    var request = http.NewRequest(method, url, body)[0]\n\n    // Apply default headers from config\n    var defaultHeaders = config[\"headers\"]\n    for key, value in defaultHeaders {\n        request = http.SetHeader(request, key, value)[0]\n    }\n\n    // Add content type for POST/PUT\n    if method == \"POST\" or method == \"PUT\" or method == \"PATCH\" {\n        request = http.SetHeader(request, \"Content-Type\", \"application/json\")[0]\n    }\n\n    // Add authentication\n    if authToken != \"\" {\n        request = http.SetHeader(request, \"Authorization\", \"Bearer \" + authToken)[0]\n    }\n\n    // Execute with retry logic\n    var maxRetries = config[\"retries\"]\n    var attempt = 0\n\n    for attempt &lt; maxRetries {\n        attempt = attempt + 1\n\n        var result = http.Do(request)\n        var response = result[0]\n        var err = result[1]\n\n        if err != None {\n            if attempt &lt; maxRetries {\n                fmt.Printf(\"Attempt %d failed, retrying...\\n\", attempt)\n                continue\n            }\n            return None, \"Network error after \" + attempt + \" attempts: \" + err\n        }\n\n        if response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300 {\n            var responseData, parseErr = json.Unmarshal(response[\"body\"])\n            if parseErr != None {\n                return None, \"JSON parse error: \" + parseErr\n            }\n            return responseData, None\n        } else if response[\"status\"] &gt;= 500 and attempt &lt; maxRetries {\n            fmt.Printf(\"Server error (attempt %d), retrying...\\n\", attempt)\n            continue\n        } else {\n            return None, \"HTTP error \" + response[\"status\"] + \": \" + response[\"statusText\"]\n        }\n    }\n\n    return None, \"All retry attempts failed\"\n}\n\n// Usage\nvar config = createAPIConfig(\"https://api.example.com\")\nvar token = \"your-auth-token\"\n\n// Get data\nvar userData, getUserErr = configuredRequest(config, \"GET\", \"/users/123\", None, token)\nif getUserErr != None {\n    fmt.Printf(\"Get user failed: %s\\n\", getUserErr)\n} else {\n    fmt.Printf(\"User: %s\\n\", userData[\"name\"])\n}\n\n// Create data\nvar newUser = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\nvar createdUser, createErr = configuredRequest(config, \"POST\", \"/users\", newUser, token)\nif createErr != None {\n    fmt.Printf(\"Create user failed: %s\\n\", createErr)\n} else {\n    fmt.Printf(\"Created user ID: %s\\n\", createdUser[\"id\"])\n}\n</code></pre>"},{"location":"stdlib/http/examples/#health-check-and-service-discovery","title":"Health Check and Service Discovery","text":"<pre><code>import http\nimport fmt\n\n// Service health checker\nfunction checkServiceHealth(services array) {\n    var healthResults = []\n\n    for service in services {\n        var serviceName = service[\"name\"]\n        var healthUrl = service[\"url\"] + \"/health\"\n\n        fmt.Printf(\"Checking %s...\\n\", serviceName)\n\n        var result = http.Get(healthUrl)\n        var response = result[0]\n        var err = result[1]\n\n        var healthStatus = {\n            \"service\": serviceName,\n            \"url\": healthUrl,\n            \"healthy\": false,\n            \"status\": 0,\n            \"responseTime\": 0,\n            \"error\": None\n        }\n\n        if err != None {\n            healthStatus[\"error\"] = err\n            fmt.Printf(\"\u274c %s: %s\\n\", serviceName, err)\n        } else {\n            healthStatus[\"status\"] = response[\"status\"]\n            healthStatus[\"healthy\"] = response[\"status\"] == 200\n\n            if healthStatus[\"healthy\"] {\n                fmt.Printf(\"\u2705 %s: Healthy (Status: %d)\\n\", serviceName, response[\"status\"])\n            } else {\n                fmt.Printf(\"\u26a0\ufe0f  %s: Unhealthy (Status: %d)\\n\", serviceName, response[\"status\"])\n            }\n        }\n\n        healthResults = append(healthResults, healthStatus)\n    }\n\n    return healthResults\n}\n\n// Usage\nvar services = [\n    {\"name\": \"User Service\", \"url\": \"https://user-api.example.com\"},\n    {\"name\": \"Order Service\", \"url\": \"https://order-api.example.com\"},\n    {\"name\": \"Payment Service\", \"url\": \"https://payment-api.example.com\"}\n]\n\nvar healthResults = checkServiceHealth(services)\n\n// Summary\nvar healthyCount = 0\nfor result in healthResults {\n    if result[\"healthy\"] {\n        healthyCount = healthyCount + 1\n    }\n}\n\nfmt.Printf(\"\\nHealth Check Summary: %d/%d services healthy\\n\", healthyCount, len(healthResults))\n</code></pre>"},{"location":"stdlib/http/examples/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"stdlib/http/examples/#1-error-handling","title":"1. Error Handling","text":"<ul> <li>Always check for network errors first</li> <li>Handle different HTTP status code ranges appropriately</li> <li>Use retry logic for transient failures</li> <li>Don't retry client errors (4xx)</li> </ul>"},{"location":"stdlib/http/examples/#2-authentication","title":"2. Authentication","text":"<ul> <li>Use Bearer tokens when possible</li> <li>Store tokens securely</li> <li>Handle token expiration gracefully</li> <li>Use appropriate authentication headers</li> </ul>"},{"location":"stdlib/http/examples/#3-request-building","title":"3. Request Building","text":"<ul> <li>Set appropriate Content-Type headers</li> <li>Include User-Agent for identification</li> <li>Use request IDs for tracing</li> <li>Set reasonable timeouts</li> </ul>"},{"location":"stdlib/http/examples/#4-response-processing","title":"4. Response Processing","text":"<ul> <li>Validate content types</li> <li>Parse JSON safely with error handling</li> <li>Check response sizes for large responses</li> <li>Log responses for debugging</li> </ul>"},{"location":"stdlib/http/examples/#5-performance","title":"5. Performance","text":"<ul> <li>Reuse connections when possible</li> <li>Implement proper retry logic</li> <li>Use appropriate timeouts</li> <li>Consider rate limiting</li> </ul>"},{"location":"stdlib/http/examples/#6-monitoring","title":"6. Monitoring","text":"<ul> <li>Log request/response details</li> <li>Track success/failure rates</li> <li>Monitor response times</li> <li>Implement health checks</li> </ul> <p>These patterns provide a solid foundation for building robust HTTP clients in Harneet applications.</p>"},{"location":"stdlib/http/middleware/","title":"Middleware","text":"<p>Middleware provides a way to execute code before and after your main request handlers. This is essential for cross-cutting concerns like logging, authentication, CORS, rate limiting, and error handling.</p>"},{"location":"stdlib/http/middleware/#middleware-concepts","title":"Middleware Concepts","text":"<p>Middleware functions wrap around your handlers, allowing you to: - Log requests and responses - Authenticate and authorize users - Handle CORS (Cross-Origin Resource Sharing) - Rate limit requests - Compress responses - Handle errors gracefully - Add security headers - Parse request bodies</p>"},{"location":"stdlib/http/middleware/#basic-middleware-pattern","title":"Basic Middleware Pattern","text":""},{"location":"stdlib/http/middleware/#httpmiddlewaremiddlewarefunc","title":"http.Middleware(middlewareFunc)","text":"<p>Creates a middleware wrapper for handlers.</p> <p>Syntax: <pre><code>http.Middleware(middlewareFunc) (middleware, error)\n</code></pre></p> <p>Parameters: - <code>middlewareFunc</code> (function) - Middleware function that wraps handlers</p> <p>Examples:</p> <p>Basic Middleware Structure: <pre><code>import http\nimport fmt\n\n// Basic middleware function\nfunction loggingMiddleware(next function) {\n    return function(request map, response map) {\n        var method = request[\"method\"]\n        var path = request[\"path\"]\n        var userAgent = request[\"headers\"][\"User-Agent\"]\n\n        fmt.Printf(\"\ud83d\udcdd %s %s from %s\\n\", method, path, userAgent)\n\n        // Call the next handler\n        next(request, response)\n\n        fmt.Printf(\"\u2705 %s %s completed\\n\", method, path)\n    }\n}\n\n// Apply middleware to a handler\nfunction createLoggedHandler(handler function) {\n    return loggingMiddleware(handler)\n}\n\n// Usage\nfunction homeHandler(request map, response map) {\n    http.WriteResponse(response, 200, \"text/html\", \"&lt;h1&gt;Home Page&lt;/h1&gt;\")\n}\n\nvar loggedHomeHandler = createLoggedHandler(homeHandler)\n\n// Register with mux\nvar mux = http.NewMux()[0]\nhttp.HandleFunc(mux, \"/\", loggedHomeHandler)\n</code></pre></p>"},{"location":"stdlib/http/middleware/#common-middleware-patterns","title":"Common Middleware Patterns","text":""},{"location":"stdlib/http/middleware/#logging-middleware","title":"Logging Middleware","text":"<pre><code>import http\nimport fmt\nimport log\n\n// Comprehensive logging middleware\nfunction requestLoggingMiddleware(next function) {\n    return function(request map, response map) {\n        var startTime = getCurrentTime()  // Simplified time function\n        var method = request[\"method\"]\n        var path = request[\"path\"]\n        var userAgent = request[\"headers\"][\"User-Agent\"]\n        var remoteAddr = request[\"remoteAddr\"]\n\n        // Log request start\n        log.Printf(\"\u2192 %s %s from %s (%s)\", method, path, remoteAddr, userAgent)\n\n        // Call next handler\n        next(request, response)\n\n        // Log request completion\n        var endTime = getCurrentTime()\n        var duration = endTime - startTime\n        log.Printf(\"\u2190 %s %s completed in %dms\", method, path, duration)\n    }\n}\n\n// Structured logging middleware\nfunction structuredLoggingMiddleware(next function) {\n    return function(request map, response map) {\n        var logData = {\n            \"timestamp\": getCurrentTimestamp(),\n            \"method\": request[\"method\"],\n            \"path\": request[\"path\"],\n            \"userAgent\": request[\"headers\"][\"User-Agent\"],\n            \"remoteAddr\": request[\"remoteAddr\"],\n            \"referer\": request[\"headers\"][\"Referer\"]\n        }\n\n        var jsonLog, _ = json.Marshal(logData)\n        log.Println(jsonLog)\n\n        next(request, response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#authentication-middleware","title":"Authentication Middleware","text":"<pre><code>import http\nimport json\nimport strings\nimport fmt\n\n// JWT authentication middleware\nfunction jwtAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var authHeader = request[\"headers\"][\"Authorization\"]\n\n        if authHeader == None or authHeader == \"\" {\n            unauthorizedResponse(response, \"Missing Authorization header\")\n            return\n        }\n\n        if !strings.HasPrefix(authHeader, \"Bearer \") {\n            unauthorizedResponse(response, \"Invalid Authorization header format\")\n            return\n        }\n\n        var token = strings.TrimPrefix(authHeader, \"Bearer \")\n        var user = validateJWTToken(token)\n\n        if user == None {\n            unauthorizedResponse(response, \"Invalid or expired token\")\n            return\n        }\n\n        // Add user to request context\n        request[\"user\"] = user\n\n        // Call next handler\n        next(request, response)\n    }\n}\n\n// API key authentication middleware\nfunction apiKeyAuthMiddleware(next function) {\n    return function(request map, response map) {\n        var apiKey = request[\"headers\"][\"X-API-Key\"]\n\n        if apiKey == None or apiKey == \"\" {\n            unauthorizedResponse(response, \"Missing API key\")\n            return\n        }\n\n        if !isValidAPIKey(apiKey) {\n            unauthorizedResponse(response, \"Invalid API key\")\n            return\n        }\n\n        // Add API key info to request\n        request[\"apiKey\"] = apiKey\n        request[\"authenticated\"] = true\n\n        next(request, response)\n    }\n}\n\n// Helper functions\nfunction unauthorizedResponse(response map, message string) {\n    var errorResponse = {\n        \"error\": \"Unauthorized\",\n        \"message\": message,\n        \"status\": 401\n    }\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 401, \"application/json\", jsonData)\n}\n\nfunction validateJWTToken(token string) {\n    // Simplified JWT validation\n    if token == \"valid-jwt-token\" {\n        return {\"id\": 1, \"username\": \"alice\", \"role\": \"admin\"}\n    }\n    return None\n}\n\nfunction isValidAPIKey(apiKey string) {\n    var validKeys = [\"key123\", \"key456\", \"key789\"]\n    for key in validKeys {\n        if key == apiKey {\n            return true\n        }\n    }\n    return false\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#cors-middleware","title":"CORS Middleware","text":"<pre><code>import http\nimport strings\n\n// CORS middleware for cross-origin requests\nfunction corsMiddleware(next function) {\n    return function(request map, response map) {\n        var origin = request[\"headers\"][\"Origin\"]\n        var method = request[\"method\"]\n\n        // Set CORS headers\n        if origin != None {\n            http.SetResponseHeader(response, \"Access-Control-Allow-Origin\", origin)\n        } else {\n            http.SetResponseHeader(response, \"Access-Control-Allow-Origin\", \"*\")\n        }\n\n        http.SetResponseHeader(response, \"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")\n        http.SetResponseHeader(response, \"Access-Control-Allow-Headers\", \"Content-Type, Authorization, X-API-Key\")\n        http.SetResponseHeader(response, \"Access-Control-Allow-Credentials\", \"true\")\n        http.SetResponseHeader(response, \"Access-Control-Max-Age\", \"86400\")\n\n        // Handle preflight OPTIONS request\n        if method == \"OPTIONS\" {\n            http.WriteResponse(response, 200, \"\", \"\")\n            return\n        }\n\n        // Call next handler\n        next(request, response)\n    }\n}\n\n// Configurable CORS middleware\nfunction configurableCORSMiddleware(config map) {\n    return function(next function) {\n        return function(request map, response map) {\n            var origin = request[\"headers\"][\"Origin\"]\n            var method = request[\"method\"]\n\n            // Check allowed origins\n            var allowedOrigins = config[\"allowedOrigins\"]\n            var originAllowed = false\n\n            if allowedOrigins == None {\n                originAllowed = true\n                http.SetResponseHeader(response, \"Access-Control-Allow-Origin\", \"*\")\n            } else {\n                for allowedOrigin in allowedOrigins {\n                    if origin == allowedOrigin {\n                        originAllowed = true\n                        http.SetResponseHeader(response, \"Access-Control-Allow-Origin\", origin)\n                        break\n                    }\n                }\n            }\n\n            if !originAllowed {\n                http.WriteResponse(response, 403, \"application/json\", \"{\\\"error\\\": \\\"Origin not allowed\\\"}\")\n                return\n            }\n\n            // Set other CORS headers\n            var allowedMethods = config[\"allowedMethods\"]\n            if allowedMethods != None {\n                var methodsStr = strings.Join(allowedMethods, \", \")\n                http.SetResponseHeader(response, \"Access-Control-Allow-Methods\", methodsStr)\n            }\n\n            var allowedHeaders = config[\"allowedHeaders\"]\n            if allowedHeaders != None {\n                var headersStr = strings.Join(allowedHeaders, \", \")\n                http.SetResponseHeader(response, \"Access-Control-Allow-Headers\", headersStr)\n            }\n\n            // Handle preflight\n            if method == \"OPTIONS\" {\n                http.WriteResponse(response, 200, \"\", \"\")\n                return\n            }\n\n            next(request, response)\n        }\n    }\n}\n\n// Usage\nvar corsConfig = {\n    \"allowedOrigins\": [\"https://example.com\", \"https://app.example.com\"],\n    \"allowedMethods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    \"allowedHeaders\": [\"Content-Type\", \"Authorization\"]\n}\n\nvar corsHandler = configurableCORSMiddleware(corsConfig)\n</code></pre>"},{"location":"stdlib/http/middleware/#rate-limiting-middleware","title":"Rate Limiting Middleware","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Simple rate limiting middleware\nfunction rateLimitMiddleware(requestsPerMinute int) {\n    // In a real implementation, this would use a proper rate limiter\n    var requestCounts = {}  // Map to track request counts per IP\n\n    return function(next function) {\n        return function(request map, response map) {\n            var clientIP = getClientIP(request)\n            var currentTime = getCurrentMinute()  // Simplified time function\n            var key = clientIP + \":\" + currentTime\n\n            // Get current request count for this IP/minute\n            var count = requestCounts[key]\n            if count == None {\n                count = 0\n            }\n\n            if count &gt;= requestsPerMinute {\n                rateLimitExceeded(response, requestsPerMinute)\n                return\n            }\n\n            // Increment request count\n            requestCounts[key] = count + 1\n\n            // Add rate limit headers\n            http.SetResponseHeader(response, \"X-RateLimit-Limit\", requestsPerMinute)\n            http.SetResponseHeader(response, \"X-RateLimit-Remaining\", requestsPerMinute - count - 1)\n\n            next(request, response)\n        }\n    }\n}\n\n// Advanced rate limiting with different limits\nfunction tieredRateLimitMiddleware(limits map) {\n    return function(next function) {\n        return function(request map, response map) {\n            var clientIP = getClientIP(request)\n            var userType = getUserType(request)  // e.g., \"free\", \"premium\", \"admin\"\n\n            var limit = limits[userType]\n            if limit == None {\n                limit = limits[\"default\"]\n            }\n\n            if !checkRateLimit(clientIP, limit) {\n                rateLimitExceeded(response, limit)\n                return\n            }\n\n            next(request, response)\n        }\n    }\n}\n\nfunction rateLimitExceeded(response map, limit int) {\n    var errorResponse = {\n        \"error\": \"Rate limit exceeded\",\n        \"message\": \"Too many requests\",\n        \"limit\": limit,\n        \"retryAfter\": 60\n    }\n\n    http.SetResponseHeader(response, \"Retry-After\", \"60\")\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 429, \"application/json\", jsonData)\n}\n\nfunction getClientIP(request map) {\n    // Check X-Forwarded-For header first\n    var forwardedFor = request[\"headers\"][\"X-Forwarded-For\"]\n    if forwardedFor != None and forwardedFor != \"\" {\n        var ips = strings.Split(forwardedFor, \",\")\n        return strings.TrimSpace(ips[0])\n    }\n\n    // Fall back to remote address\n    var remoteAddr = request[\"remoteAddr\"]\n    var parts = strings.Split(remoteAddr, \":\")\n    return parts[0]\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#security-headers-middleware","title":"Security Headers Middleware","text":"<pre><code>import http\n\n// Security headers middleware\nfunction securityHeadersMiddleware(next function) {\n    return function(request map, response map) {\n        // Content Security Policy\n        http.SetResponseHeader(response, \"Content-Security-Policy\", \n            \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'\")\n\n        // Prevent MIME type sniffing\n        http.SetResponseHeader(response, \"X-Content-Type-Options\", \"nosniff\")\n\n        // Prevent clickjacking\n        http.SetResponseHeader(response, \"X-Frame-Options\", \"DENY\")\n\n        // XSS protection\n        http.SetResponseHeader(response, \"X-XSS-Protection\", \"1; mode=block\")\n\n        // HTTPS enforcement (if using HTTPS)\n        if isHTTPS(request) {\n            http.SetResponseHeader(response, \"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\")\n        }\n\n        // Referrer policy\n        http.SetResponseHeader(response, \"Referrer-Policy\", \"strict-origin-when-cross-origin\")\n\n        // Permissions policy\n        http.SetResponseHeader(response, \"Permissions-Policy\", \"geolocation=(), microphone=(), camera=()\")\n\n        next(request, response)\n    }\n}\n\nfunction isHTTPS(request map) {\n    // Check if request is HTTPS\n    var proto = request[\"headers\"][\"X-Forwarded-Proto\"]\n    return proto == \"https\" or strings.HasPrefix(request[\"url\"], \"https://\")\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#error-handling-middleware","title":"Error Handling Middleware","text":"<pre><code>import http\nimport json\nimport fmt\nimport log\n\n// Error recovery middleware\nfunction errorRecoveryMiddleware(next function) {\n    return function(request map, response map) {\n        // In a real implementation, this would use proper error recovery\n        var success = callHandlerSafely(next, request, response)\n\n        if !success {\n            handlePanic(request, response)\n        }\n    }\n}\n\nfunction callHandlerSafely(handler function, request map, response map) {\n    // Simplified error recovery - in real implementation would use proper panic recovery\n    var success = true\n\n    // Try to call the handler\n    handler(request, response)\n\n    return success\n}\n\nfunction handlePanic(request map, response map) {\n    var method = request[\"method\"]\n    var path = request[\"path\"]\n\n    log.Printf(\"PANIC: %s %s - Internal server error\", method, path)\n\n    var errorResponse = {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An unexpected error occurred\",\n        \"timestamp\": getCurrentTimestamp()\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 500, \"application/json\", jsonData)\n}\n\n// Structured error handling middleware\nfunction errorHandlingMiddleware(next function) {\n    return function(request map, response map) {\n        // Add error handling context to request\n        request[\"errorHandler\"] = handleRequestError\n\n        next(request, response)\n    }\n}\n\nfunction handleRequestError(error string, request map, response map) {\n    var errorType = classifyError(error)\n    var statusCode = getStatusCodeForError(errorType)\n\n    var errorResponse = {\n        \"error\": errorType,\n        \"message\": error,\n        \"path\": request[\"path\"],\n        \"method\": request[\"method\"],\n        \"timestamp\": getCurrentTimestamp()\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, statusCode, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#middleware-composition","title":"Middleware Composition","text":""},{"location":"stdlib/http/middleware/#chaining-multiple-middleware","title":"Chaining Multiple Middleware","text":"<pre><code>import http\n\n// Middleware chain helper\nfunction chainMiddleware(middlewares array) {\n    return function(handler function) {\n        var result = handler\n\n        // Apply middleware in reverse order\n        for i in range(len(middlewares) - 1, -1, -1) {\n            var middleware = middlewares[i]\n            result = middleware(result)\n        }\n\n        return result\n    }\n}\n\n// Usage\nfunction setupMiddlewareChain() {\n    var middlewares = [\n        loggingMiddleware,\n        corsMiddleware,\n        securityHeadersMiddleware,\n        rateLimitMiddleware(100),  // 100 requests per minute\n        jwtAuthMiddleware\n    ]\n\n    var chain = chainMiddleware(middlewares)\n\n    // Apply to handlers\n    var protectedHandler = chain(apiHandler)\n    var publicHandler = chainMiddleware([loggingMiddleware, corsMiddleware])(homeHandler)\n\n    var mux = http.NewMux()[0]\n    http.HandleFunc(mux, \"/api/protected\", protectedHandler)\n    http.HandleFunc(mux, \"/\", publicHandler)\n\n    return mux\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#conditional-middleware","title":"Conditional Middleware","text":"<pre><code>import http\nimport strings\n\n// Conditional middleware application\nfunction conditionalMiddleware(condition function, middleware function) {\n    return function(next function) {\n        return function(request map, response map) {\n            if condition(request) {\n                var wrappedHandler = middleware(next)\n                wrappedHandler(request, response)\n            } else {\n                next(request, response)\n            }\n        }\n    }\n}\n\n// Usage examples\nfunction isAPIRequest(request map) {\n    return strings.HasPrefix(request[\"path\"], \"/api/\")\n}\n\nfunction isAdminRequest(request map) {\n    return strings.HasPrefix(request[\"path\"], \"/admin/\")\n}\n\nfunction setupConditionalMiddleware() {\n    var mux = http.NewMux()[0]\n\n    // Apply auth middleware only to API requests\n    var apiAuthMiddleware = conditionalMiddleware(isAPIRequest, jwtAuthMiddleware)\n\n    // Apply admin middleware only to admin requests\n    var adminAuthMiddleware = conditionalMiddleware(isAdminRequest, adminAuthMiddleware)\n\n    var handler = chainMiddleware([\n        loggingMiddleware,\n        corsMiddleware,\n        apiAuthMiddleware,\n        adminAuthMiddleware\n    ])(baseHandler)\n\n    http.HandleFunc(mux, \"/\", handler)\n\n    return mux\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#advanced-middleware-patterns","title":"Advanced Middleware Patterns","text":""},{"location":"stdlib/http/middleware/#requestresponse-transformation","title":"Request/Response Transformation","text":"<pre><code>import http\nimport json\nimport strings\n\n// JSON request parsing middleware\nfunction jsonParsingMiddleware(next function) {\n    return function(request map, response map) {\n        var contentType = request[\"headers\"][\"Content-Type\"]\n\n        if contentType == \"application/json\" and request[\"body\"] != \"\" {\n            var parsedBody, parseErr = json.Unmarshal(request[\"body\"])\n            if parseErr != None {\n                var errorResponse = {\"error\": \"Invalid JSON\", \"message\": parseErr}\n                var jsonError, _ = json.Marshal(errorResponse)\n                http.WriteResponse(response, 400, \"application/json\", jsonError)\n                return\n            }\n\n            request[\"jsonBody\"] = parsedBody\n        }\n\n        next(request, response)\n    }\n}\n\n// Response compression middleware\nfunction compressionMiddleware(next function) {\n    return function(request map, response map) {\n        var acceptEncoding = request[\"headers\"][\"Accept-Encoding\"]\n        var supportsGzip = strings.Contains(acceptEncoding, \"gzip\")\n\n        if supportsGzip {\n            http.SetResponseHeader(response, \"Content-Encoding\", \"gzip\")\n            // In real implementation, would wrap response writer with gzip\n        }\n\n        next(request, response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#caching-middleware","title":"Caching Middleware","text":"<pre><code>import http\nimport json\nimport fmt\n\n// Simple response caching middleware\nfunction cachingMiddleware(ttlSeconds int) {\n    var cache = {}  // Simple in-memory cache\n\n    return function(next function) {\n        return function(request map, response map) {\n            var method = request[\"method\"]\n            var path = request[\"path\"]\n\n            // Only cache GET requests\n            if method != \"GET\" {\n                next(request, response)\n                return\n            }\n\n            var cacheKey = method + \":\" + path\n            var cachedResponse = cache[cacheKey]\n\n            if cachedResponse != None and !isCacheExpired(cachedResponse, ttlSeconds) {\n                // Serve from cache\n                http.SetResponseHeader(response, \"X-Cache\", \"HIT\")\n                var cached = cachedResponse[\"response\"]\n                http.WriteResponse(response, cached[\"status\"], cached[\"contentType\"], cached[\"body\"])\n                return\n            }\n\n            // Capture response for caching\n            var capturedResponse = captureResponse(next, request, response)\n\n            // Cache the response\n            cache[cacheKey] = {\n                \"response\": capturedResponse,\n                \"timestamp\": getCurrentTimestamp()\n            }\n\n            http.SetResponseHeader(response, \"X-Cache\", \"MISS\")\n        }\n    }\n}\n\nfunction isCacheExpired(cachedItem map, ttlSeconds int) {\n    var timestamp = cachedItem[\"timestamp\"]\n    var currentTime = getCurrentTimestamp()\n    return (currentTime - timestamp) &gt; ttlSeconds\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/middleware/#1-order-middleware-correctly","title":"1. Order Middleware Correctly","text":"<pre><code>// Correct order: logging -&gt; CORS -&gt; auth -&gt; business logic\nvar middlewares = [\n    loggingMiddleware,          // First - log everything\n    corsMiddleware,             // Early - handle CORS\n    securityHeadersMiddleware,  // Security headers\n    rateLimitMiddleware(100),   // Rate limiting\n    jwtAuthMiddleware,          // Authentication\n    jsonParsingMiddleware       // Last - parse request body\n]\n</code></pre>"},{"location":"stdlib/http/middleware/#2-keep-middleware-focused","title":"2. Keep Middleware Focused","text":"<pre><code>// Good - single responsibility\nfunction loggingMiddleware(next function) { /* ... */ }\nfunction authMiddleware(next function) { /* ... */ }\nfunction corsMiddleware(next function) { /* ... */ }\n\n// Bad - multiple responsibilities\nfunction megaMiddleware(next function) {\n    // Don't do logging, auth, CORS all in one middleware\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#3-make-middleware-configurable","title":"3. Make Middleware Configurable","text":"<pre><code>// Good - configurable\nfunction rateLimitMiddleware(requestsPerMinute int) { /* ... */ }\nfunction corsMiddleware(allowedOrigins array) { /* ... */ }\n\n// Bad - hardcoded values\nfunction rateLimitMiddleware() {\n    var limit = 100  // Hardcoded\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#4-handle-errors-gracefully","title":"4. Handle Errors Gracefully","text":"<pre><code>function safeMiddleware(next function) {\n    return function(request map, response map) {\n        var success = performMiddlewareOperation()\n\n        if !success {\n            // Log error but don't break the chain\n            log.Printf(\"Middleware error, continuing...\")\n        }\n\n        next(request, response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#5-use-context-for-request-data","title":"5. Use Context for Request Data","text":"<pre><code>function authMiddleware(next function) {\n    return function(request map, response map) {\n        var user = authenticateUser(request)\n\n        if user != None {\n            // Add user to request context\n            request[\"user\"] = user\n            request[\"authenticated\"] = true\n        }\n\n        next(request, response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/middleware/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication - Deep dive into authentication and authorization</li> <li>Cookies &amp; Sessions - Handle user sessions and cookies</li> <li>Routing &amp; Mux - Go back to routing concepts</li> <li>HTTP Server - Server fundamentals</li> </ul>"},{"location":"stdlib/http/overview/","title":"HTTP Module Overview","text":"<p>The HTTP module provides comprehensive HTTP client functionality by wrapping Go's powerful <code>net/http</code> package. This gives Harneet programs access to full-featured HTTP capabilities without reimplementing the complex networking code.</p>"},{"location":"stdlib/http/overview/#quick-start","title":"Quick Start","text":"<pre><code>import http\nimport fmt\n\n// Simple GET request\nvar result = http.Get(\"https://api.example.com/data\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    fmt.Printf(\"Status: %d\\n\", response[\"status\"])\n    fmt.Printf(\"Body: %s\\n\", response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/overview/#module-import","title":"Module Import","text":"<pre><code>import http\n</code></pre>"},{"location":"stdlib/http/overview/#architecture","title":"Architecture","text":"<p>The HTTP module follows the facade pattern, exposing all the essential features of Go's <code>net/http</code> while maintaining Harneet's simple and consistent API design. All functions return <code>(result, error)</code> tuples following Harneet's error handling conventions.</p>"},{"location":"stdlib/http/overview/#core-features","title":"Core Features","text":""},{"location":"stdlib/http/overview/#http-client-methods","title":"\u2705 HTTP Client Methods","text":"<ul> <li>GET requests - <code>http.Get(url)</code></li> <li>POST requests - <code>http.Post(url, contentType, body)</code></li> <li>PUT requests - <code>http.Put(url, contentType, body)</code></li> <li>DELETE requests - <code>http.Delete(url)</code></li> <li>HEAD requests - <code>http.Head(url)</code></li> </ul>"},{"location":"stdlib/http/overview/#advanced-request-building","title":"\u2705 Advanced Request Building","text":"<ul> <li>Custom requests - <code>http.NewRequest(method, url, body)</code></li> <li>Header management - <code>http.SetHeader(request, key, value)</code></li> <li>Request execution - <code>http.Do(request)</code></li> </ul>"},{"location":"stdlib/http/overview/#response-handling","title":"\u2705 Response Handling","text":"<ul> <li>Status codes - <code>response[\"status\"]</code></li> <li>Headers - <code>response[\"headers\"]</code></li> <li>Body content - <code>response[\"body\"]</code></li> <li>Status text - <code>response[\"statusText\"]</code></li> </ul>"},{"location":"stdlib/http/overview/#built-in-features","title":"\u2705 Built-in Features","text":"<ul> <li>Connection pooling - Automatic via Go's http.Client</li> <li>Timeout handling - 30-second default timeout</li> <li>Keep-alive connections - Managed automatically</li> <li>Compression support - Automatic gzip handling</li> <li>Error handling - Comprehensive error reporting</li> </ul>"},{"location":"stdlib/http/overview/#response-object-structure","title":"Response Object Structure","text":"<p>All HTTP functions return a response object (map) with this structure:</p> <pre><code>{\n    \"status\": 200,                    // HTTP status code (integer)\n    \"statusText\": \"200 OK\",           // Full status text (string)\n    \"body\": \"response content...\",    // Response body (string)\n    \"headers\": {                      // Headers map\n        \"Content-Type\": \"application/json\",\n        \"Content-Length\": \"1234\",\n        // ... other headers\n    }\n}\n</code></pre>"},{"location":"stdlib/http/overview/#error-handling-pattern","title":"Error Handling Pattern","text":"<p>The HTTP module follows Harneet's standard error handling pattern:</p> <pre><code>var result = http.Get(\"https://example.com\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    // Handle network errors, timeouts, etc.\n    fmt.Printf(\"Network Error: %s\\n\", err)\n} else if response[\"status\"] &gt;= 400 {\n    // Handle HTTP errors\n    fmt.Printf(\"HTTP Error %d: %s\\n\", response[\"status\"], response[\"statusText\"])\n} else {\n    // Success - process response\n    fmt.Printf(\"Success: %s\\n\", response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/overview/#integration-with-other-modules","title":"Integration with Other Modules","text":"<p>The HTTP module works seamlessly with other Harneet standard library modules:</p> <ul> <li>json - For encoding/decoding JSON request and response bodies</li> <li>cast - For type conversions of response data</li> <li>fmt - For formatting and displaying HTTP responses</li> <li>log - For logging HTTP requests and responses</li> <li>errors - For comprehensive error handling</li> </ul>"},{"location":"stdlib/http/overview/#common-use-cases","title":"Common Use Cases","text":""},{"location":"stdlib/http/overview/#api-client-development","title":"API Client Development","text":"<pre><code>// RESTful API interactions\nvar users = http.Get(\"https://api.example.com/users\")[0]\nvar newUser = http.Post(\"https://api.example.com/users\", \"application/json\", userData)[0]\nvar updatedUser = http.Put(\"https://api.example.com/users/123\", \"application/json\", updates)[0]\nvar deleted = http.Delete(\"https://api.example.com/users/123\")[0]\n</code></pre>"},{"location":"stdlib/http/overview/#authentication-headers","title":"Authentication &amp; Headers","text":"<pre><code>// Authenticated requests\nvar request = http.NewRequest(\"GET\", \"https://api.example.com/secure\", \"\")[0]\nvar authRequest = http.SetHeader(request, \"Authorization\", \"Bearer token123\")[0]\nvar response = http.Do(authRequest)[0]\n</code></pre>"},{"location":"stdlib/http/overview/#json-api-integration","title":"JSON API Integration","text":"<pre><code>// JSON request/response handling\nvar data = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\nvar jsonData, _ = json.Marshal(data)\nvar response = http.Post(\"https://api.example.com/users\", \"application/json\", jsonData)[0]\nvar createdUser, _ = json.Unmarshal(response[\"body\"])\n</code></pre>"},{"location":"stdlib/http/overview/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Connection Reuse - Automatic HTTP keep-alive connections</li> <li>Connection Pooling - Built-in connection pool management</li> <li>Timeout Control - 30-second default with customization options</li> <li>Memory Efficient - Streaming response handling</li> <li>Thread Safe - Safe for concurrent use</li> </ul>"},{"location":"stdlib/http/overview/#security-features","title":"Security Features","text":"<ul> <li>TLS/HTTPS Support - Automatic HTTPS handling</li> <li>Certificate Validation - Built-in certificate verification</li> <li>Header Security - Full control over request headers</li> <li>Authentication Support - Bearer tokens, Basic auth, custom schemes</li> </ul>"},{"location":"stdlib/http/overview/#next-steps","title":"Next Steps","text":"<ul> <li>HTTP Client - Learn about basic HTTP methods (GET, POST, PUT, DELETE, HEAD)</li> <li>Request Building - Advanced request customization and header management</li> <li>Response Handling - Processing responses, status codes, and error handling</li> <li>Examples &amp; Patterns - Real-world examples and common patterns</li> </ul>"},{"location":"stdlib/http/overview/#future-enhancements","title":"Future Enhancements","text":"<p>The HTTP module is designed to be easily extensible. Future enhancements may include:</p> <ul> <li>HTTP Server - Server-side HTTP handling</li> <li>WebSocket Support - WebSocket protocol upgrade</li> <li>File Upload - Multipart form data handling</li> <li>Streaming - Request/response streaming</li> <li>Middleware - Request/response middleware chain</li> <li>Connection Hijacking - Custom protocol support</li> </ul> <p>The foundation is solid and ready for these advanced features when needed!</p>"},{"location":"stdlib/http/requests/","title":"Request Building","text":"<p>For advanced HTTP operations, you can build custom requests with full control over methods, headers, and other request properties. This is essential for complex API integrations and custom protocols.</p>"},{"location":"stdlib/http/requests/#custom-request-creation","title":"Custom Request Creation","text":""},{"location":"stdlib/http/requests/#httpnewrequestmethod-url-body","title":"http.NewRequest(method, url, body)","text":"<p>Creates a new HTTP request object for customization before execution.</p> <p>Syntax: <pre><code>http.NewRequest(method, url, body) (request, error)\n</code></pre></p> <p>Parameters: - <code>method</code> (string) - HTTP method (GET, POST, PUT, DELETE, PATCH, etc.) - <code>url</code> (string) - Target URL - <code>body</code> (string) - Request body (use empty string for no body)</p> <p>Returns: - <code>request</code> (map) - Request object for further customization - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Custom HTTP Method: <pre><code>import http\nimport json\nimport fmt\n\n// PATCH request for partial updates\nfunction patchUser(userId string, updates map) {\n    var jsonData, jsonErr = json.Marshal(updates)\n    if jsonErr != None {\n        return jsonErr\n    }\n\n    var url = \"https://api.example.com/users/\" + userId\n    var result = http.NewRequest(\"PATCH\", url, jsonData)\n    var request = result[0]\n    var err = result[1]\n\n    if err != None {\n        return \"Failed to create request: \" + err\n    }\n\n    // Set headers for PATCH request\n    var contentRequest = http.SetHeader(request, \"Content-Type\", \"application/json\")[0]\n    var authRequest = http.SetHeader(contentRequest, \"Authorization\", \"Bearer token123\")[0]\n\n    // Execute the request\n    var response = http.Do(authRequest)[0]\n\n    if response[\"status\"] == 200 {\n        fmt.Printf(\"\u2705 User %s patched successfully\\n\", userId)\n        return None\n    } else {\n        return \"Patch failed: \" + response[\"statusText\"]\n    }\n}\n\n// Usage\nvar updates = {\"email\": \"newemail@example.com\"}\nvar patchErr = patchUser(\"123\", updates)\nif patchErr != None {\n    fmt.Printf(\"Patch Error: %s\\n\", patchErr)\n}\n</code></pre></p> <p>Request with Authentication: <pre><code>import http\nimport json\nimport fmt\n\n// Authenticated API request builder\nfunction authenticatedRequest(method string, endpoint string, token string, body string) {\n    var fullUrl = \"https://secure-api.example.com\" + endpoint\n    var result = http.NewRequest(method, fullUrl, body)\n    var request = result[0]\n    var err = result[1]\n\n    if err != None {\n        return None, \"Request creation failed: \" + err\n    }\n\n    // Add authentication and standard headers\n    var authRequest = http.SetHeader(request, \"Authorization\", \"Bearer \" + token)[0]\n    var contentRequest = http.SetHeader(authRequest, \"Content-Type\", \"application/json\")[0]\n    var acceptRequest = http.SetHeader(contentRequest, \"Accept\", \"application/json\")[0]\n    var userAgentRequest = http.SetHeader(acceptRequest, \"User-Agent\", \"HarneetApp/1.0\")[0]\n\n    return userAgentRequest, None\n}\n\n// Usage\nvar token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\nvar userData = {\"name\": \"Alice\", \"role\": \"admin\"}\nvar jsonData, _ = json.Marshal(userData)\n\nvar request, reqErr = authenticatedRequest(\"POST\", \"/api/users\", token, jsonData)\nif reqErr != None {\n    fmt.Printf(\"Request Error: %s\\n\", reqErr)\n} else {\n    var response = http.Do(request)[0]\n    fmt.Printf(\"Response Status: %d\\n\", response[\"status\"])\n}\n</code></pre></p>"},{"location":"stdlib/http/requests/#header-management","title":"Header Management","text":""},{"location":"stdlib/http/requests/#httpsetheaderrequest-key-value","title":"http.SetHeader(request, key, value)","text":"<p>Sets a header on a request object.</p> <p>Syntax: <pre><code>http.SetHeader(request, key, value) (request, error)\n</code></pre></p> <p>Parameters: - <code>request</code> (map) - Request object from NewRequest - <code>key</code> (string) - Header name - <code>value</code> (string) - Header value</p> <p>Returns: - <code>request</code> (map) - Updated request object - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Multiple Header Management: <pre><code>import http\nimport fmt\n\n// Build request with multiple headers\nfunction buildAPIRequest(url string, token string) {\n    var result = http.NewRequest(\"GET\", url, \"\")\n    var request = result[0]\n    var err = result[1]\n\n    if err != None {\n        return None, err\n    }\n\n    // Chain multiple headers\n    var authRequest = http.SetHeader(request, \"Authorization\", \"Bearer \" + token)[0]\n    var userAgentRequest = http.SetHeader(authRequest, \"User-Agent\", \"HarneetApp/1.0\")[0]\n    var acceptRequest = http.SetHeader(userAgentRequest, \"Accept\", \"application/json\")[0]\n    var cacheRequest = http.SetHeader(acceptRequest, \"Cache-Control\", \"no-cache\")[0]\n    var langRequest = http.SetHeader(cacheRequest, \"Accept-Language\", \"en-US,en;q=0.9\")[0]\n\n    return langRequest, None\n}\n\n// Usage\nvar request, reqErr = buildAPIRequest(\"https://api.example.com/data\", \"token123\")\nif reqErr != None {\n    fmt.Printf(\"Request building failed: %s\\n\", reqErr)\n} else {\n    var response = http.Do(request)[0]\n    fmt.Printf(\"API Response Status: %d\\n\", response[\"status\"])\n}\n</code></pre></p> <p>Cookie Management via Headers: <pre><code>import http\nimport fmt\n\n// Set multiple cookies in a request\nfunction setRequestCookies(request map, cookies map) {\n    var cookieString = \"\"\n    var first = true\n\n    // Build cookie string from map (simplified)\n    for key, value in cookies {\n        if !first {\n            cookieString = cookieString + \"; \"\n        }\n        cookieString = cookieString + key + \"=\" + value\n        first = false\n    }\n\n    var cookieRequest = http.SetHeader(request, \"Cookie\", cookieString)[0]\n    return cookieRequest\n}\n\n// Usage\nvar request = http.NewRequest(\"GET\", \"https://api.example.com/profile\", \"\")[0]\nvar cookies = {\n    \"session_id\": \"abc123xyz\",\n    \"user_pref\": \"dark_theme\",\n    \"lang\": \"en\"\n}\n\nvar cookieRequest = setRequestCookies(request, cookies)\nvar response = http.Do(cookieRequest)[0]\nfmt.Printf(\"Profile request with cookies - Status: %d\\n\", response[\"status\"])\n</code></pre></p> <p>Content Negotiation Headers: <pre><code>import http\nimport fmt\n\n// Set content negotiation headers\nfunction requestWithContentNegotiation(url string, acceptType string, acceptEncoding string) {\n    var request = http.NewRequest(\"GET\", url, \"\")[0]\n\n    // Content negotiation headers\n    var acceptRequest = http.SetHeader(request, \"Accept\", acceptType)[0]\n    var encodingRequest = http.SetHeader(acceptRequest, \"Accept-Encoding\", acceptEncoding)[0]\n    var charsetRequest = http.SetHeader(encodingRequest, \"Accept-Charset\", \"utf-8\")[0]\n\n    return charsetRequest\n}\n\n// Usage examples\nvar jsonRequest = requestWithContentNegotiation(\n    \"https://api.example.com/data\", \n    \"application/json\", \n    \"gzip, deflate\"\n)\n\nvar xmlRequest = requestWithContentNegotiation(\n    \"https://api.example.com/data\", \n    \"application/xml\", \n    \"gzip\"\n)\n\nvar jsonResponse = http.Do(jsonRequest)[0]\nvar xmlResponse = http.Do(xmlRequest)[0]\n\nfmt.Printf(\"JSON Response: %d\\n\", jsonResponse[\"status\"])\nfmt.Printf(\"XML Response: %d\\n\", xmlResponse[\"status\"])\n</code></pre></p>"},{"location":"stdlib/http/requests/#request-execution","title":"Request Execution","text":""},{"location":"stdlib/http/requests/#httpdorequest","title":"http.Do(request)","text":"<p>Executes a custom HTTP request.</p> <p>Syntax: <pre><code>http.Do(request) (response, error)\n</code></pre></p> <p>Parameters: - <code>request</code> (map) - Request object created with NewRequest</p> <p>Returns: - <code>response</code> (map) - Response object - <code>error</code> - None on success, error on failure</p>"},{"location":"stdlib/http/requests/#request-object-structure","title":"Request Object Structure","text":"<p>Request objects created with <code>http.NewRequest()</code> have the following structure:</p> <pre><code>{\n    \"method\": \"GET\",                  // HTTP method\n    \"url\": \"https://example.com\",     // Target URL\n    \"headers\": {                      // Headers map\n        \"User-Agent\": \"Harneet/1.0\",\n        \"Authorization\": \"Bearer token\",\n        \"Content-Type\": \"application/json\",\n        // ... other headers\n    }\n}\n</code></pre>"},{"location":"stdlib/http/requests/#common-header-types","title":"Common Header Types","text":""},{"location":"stdlib/http/requests/#authentication-headers","title":"Authentication Headers","text":"<pre><code>// Bearer token authentication\nhttp.SetHeader(request, \"Authorization\", \"Bearer \" + token)\n\n// Basic authentication (base64 encoded username:password)\nhttp.SetHeader(request, \"Authorization\", \"Basic \" + encodedCredentials)\n\n// API key authentication\nhttp.SetHeader(request, \"X-API-Key\", apiKey)\n</code></pre>"},{"location":"stdlib/http/requests/#content-headers","title":"Content Headers","text":"<pre><code>// JSON content\nhttp.SetHeader(request, \"Content-Type\", \"application/json\")\n\n// Form data\nhttp.SetHeader(request, \"Content-Type\", \"application/x-www-form-urlencoded\")\n\n// File upload\nhttp.SetHeader(request, \"Content-Type\", \"multipart/form-data\")\n\n// Plain text\nhttp.SetHeader(request, \"Content-Type\", \"text/plain\")\n</code></pre>"},{"location":"stdlib/http/requests/#accept-headers","title":"Accept Headers","text":"<pre><code>// Accept JSON responses\nhttp.SetHeader(request, \"Accept\", \"application/json\")\n\n// Accept multiple formats\nhttp.SetHeader(request, \"Accept\", \"application/json, application/xml, text/plain\")\n\n// Accept with quality values\nhttp.SetHeader(request, \"Accept\", \"application/json;q=0.9, text/plain;q=0.8\")\n</code></pre>"},{"location":"stdlib/http/requests/#caching-headers","title":"Caching Headers","text":"<pre><code>// Disable caching\nhttp.SetHeader(request, \"Cache-Control\", \"no-cache\")\n\n// Force fresh response\nhttp.SetHeader(request, \"Cache-Control\", \"no-store\")\n\n// Conditional requests\nhttp.SetHeader(request, \"If-Modified-Since\", \"Wed, 21 Oct 2015 07:28:00 GMT\")\nhttp.SetHeader(request, \"If-None-Match\", \"\\\"33a64df551425fcc55e4d42a148795d9f25f89d4\\\"\")\n</code></pre>"},{"location":"stdlib/http/requests/#custom-headers","title":"Custom Headers","text":"<pre><code>// API versioning\nhttp.SetHeader(request, \"X-API-Version\", \"v2\")\n\n// Request ID for tracing\nhttp.SetHeader(request, \"X-Request-ID\", \"req-123456\")\n\n// Client information\nhttp.SetHeader(request, \"User-Agent\", \"MyApp/1.0 (Platform/Version)\")\n\n// Language preferences\nhttp.SetHeader(request, \"Accept-Language\", \"en-US,en;q=0.9,es;q=0.8\")\n</code></pre>"},{"location":"stdlib/http/requests/#advanced-request-patterns","title":"Advanced Request Patterns","text":""},{"location":"stdlib/http/requests/#request-builder-pattern","title":"Request Builder Pattern","text":"<pre><code>import http\n\n// Request builder function\nfunction buildRequest(method string, url string) {\n    return http.NewRequest(method, url, \"\")[0]\n}\n\nfunction withAuth(request map, token string) {\n    return http.SetHeader(request, \"Authorization\", \"Bearer \" + token)[0]\n}\n\nfunction withJSON(request map) {\n    var contentRequest = http.SetHeader(request, \"Content-Type\", \"application/json\")[0]\n    return http.SetHeader(contentRequest, \"Accept\", \"application/json\")[0]\n}\n\nfunction withUserAgent(request map, userAgent string) {\n    return http.SetHeader(request, \"User-Agent\", userAgent)[0]\n}\n\n// Usage\nvar request = buildRequest(\"GET\", \"https://api.example.com/data\")\nrequest = withAuth(request, \"token123\")\nrequest = withJSON(request)\nrequest = withUserAgent(request, \"MyApp/1.0\")\n\nvar response = http.Do(request)[0]\n</code></pre>"},{"location":"stdlib/http/requests/#request-template-function","title":"Request Template Function","text":"<pre><code>import http\nimport json\n\n// Generic API request template\nfunction apiRequest(method string, endpoint string, data map, token string) {\n    var baseUrl = \"https://api.example.com\"\n    var fullUrl = baseUrl + endpoint\n\n    var body = \"\"\n    if data != None {\n        var jsonData, _ = json.Marshal(data)\n        body = jsonData\n    }\n\n    var request = http.NewRequest(method, fullUrl, body)[0]\n\n    // Standard headers\n    request = http.SetHeader(request, \"Content-Type\", \"application/json\")[0]\n    request = http.SetHeader(request, \"Accept\", \"application/json\")[0]\n    request = http.SetHeader(request, \"User-Agent\", \"HarneetApp/1.0\")[0]\n\n    // Authentication\n    if token != \"\" {\n        request = http.SetHeader(request, \"Authorization\", \"Bearer \" + token)[0]\n    }\n\n    return http.Do(request)\n}\n\n// Usage examples\nvar users = apiRequest(\"GET\", \"/users\", None, \"token123\")\nvar newUser = apiRequest(\"POST\", \"/users\", {\"name\": \"Alice\"}, \"token123\")\nvar updatedUser = apiRequest(\"PUT\", \"/users/123\", {\"name\": \"Alice Updated\"}, \"token123\")\nvar deleted = apiRequest(\"DELETE\", \"/users/123\", None, \"token123\")\n</code></pre>"},{"location":"stdlib/http/requests/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/requests/#1-always-set-user-agent","title":"1. Always Set User-Agent","text":"<pre><code>http.SetHeader(request, \"User-Agent\", \"MyApp/1.0 (contact@example.com)\")\n</code></pre>"},{"location":"stdlib/http/requests/#2-use-appropriate-content-type","title":"2. Use Appropriate Content-Type","text":"<pre><code>// For JSON data\nhttp.SetHeader(request, \"Content-Type\", \"application/json\")\n\n// For form data\nhttp.SetHeader(request, \"Content-Type\", \"application/x-www-form-urlencoded\")\n</code></pre>"},{"location":"stdlib/http/requests/#3-handle-authentication-properly","title":"3. Handle Authentication Properly","text":"<pre><code>// Use Bearer tokens when possible\nhttp.SetHeader(request, \"Authorization\", \"Bearer \" + token)\n\n// Store sensitive tokens securely (not in code)\n</code></pre>"},{"location":"stdlib/http/requests/#4-set-accept-headers","title":"4. Set Accept Headers","text":"<pre><code>// Be explicit about what you expect\nhttp.SetHeader(request, \"Accept\", \"application/json\")\n</code></pre>"},{"location":"stdlib/http/requests/#5-use-request-ids-for-tracing","title":"5. Use Request IDs for Tracing","text":"<pre><code>http.SetHeader(request, \"X-Request-ID\", generateRequestId())\n</code></pre>"},{"location":"stdlib/http/requests/#next-steps","title":"Next Steps","text":"<ul> <li>Response Handling - Learn about processing responses and handling different content types</li> <li>Examples &amp; Patterns - See real-world examples and advanced patterns</li> <li>HTTP Client - Go back to basic HTTP methods</li> </ul>"},{"location":"stdlib/http/responses/","title":"Response Handling","text":"<p>Understanding how to properly handle HTTP responses is crucial for building robust applications. This section covers response structure, status codes, headers, and error handling patterns.</p>"},{"location":"stdlib/http/responses/#response-object-structure","title":"Response Object Structure","text":"<p>All HTTP functions return a response object (map) with the following structure:</p> <pre><code>{\n    \"status\": 200,                    // HTTP status code (integer)\n    \"statusText\": \"200 OK\",           // Full status text (string)\n    \"body\": \"response content...\",    // Response body (string)\n    \"headers\": {                      // Headers map\n        \"Content-Type\": \"application/json\",\n        \"Content-Length\": \"1234\",\n        \"Cache-Control\": \"no-cache\",\n        \"Set-Cookie\": \"session=abc123\",\n        // ... other headers\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#accessing-response-data","title":"Accessing Response Data","text":""},{"location":"stdlib/http/responses/#status-information","title":"Status Information","text":"<pre><code>import http\nimport fmt\n\nvar result = http.Get(\"https://api.example.com/data\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Network Error: %s\\n\", err)\n} else {\n    // Access status code\n    var statusCode = response[\"status\"]\n    var statusText = response[\"statusText\"]\n\n    fmt.Printf(\"Status: %d - %s\\n\", statusCode, statusText)\n\n    // Check if request was successful\n    if statusCode &gt;= 200 and statusCode &lt; 300 {\n        fmt.Println(\"\u2705 Request successful!\")\n    } else if statusCode &gt;= 400 and statusCode &lt; 500 {\n        fmt.Println(\"\u274c Client error\")\n    } else if statusCode &gt;= 500 {\n        fmt.Println(\"\ud83d\udca5 Server error\")\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#response-body","title":"Response Body","text":"<pre><code>import http\nimport json\nimport fmt\n\nvar result = http.Get(\"https://api.example.com/users/1\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else if response[\"status\"] == 200 {\n    // Access response body\n    var body = response[\"body\"]\n\n    // Parse JSON if content type is JSON\n    var contentType = response[\"headers\"][\"Content-Type\"]\n    if contentType == \"application/json\" {\n        var userData, parseErr = json.Unmarshal(body)\n        if parseErr != None {\n            fmt.Printf(\"JSON Parse Error: %s\\n\", parseErr)\n        } else {\n            fmt.Printf(\"User: %s\\n\", userData[\"name\"])\n        }\n    } else {\n        // Handle as plain text\n        fmt.Printf(\"Response: %s\\n\", body)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#response-headers","title":"Response Headers","text":"<pre><code>import http\nimport fmt\n\nvar result = http.Get(\"https://api.example.com/data\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    var headers = response[\"headers\"]\n\n    // Access specific headers\n    var contentType = headers[\"Content-Type\"]\n    var contentLength = headers[\"Content-Length\"]\n    var cacheControl = headers[\"Cache-Control\"]\n    var lastModified = headers[\"Last-Modified\"]\n\n    fmt.Printf(\"Content-Type: %s\\n\", contentType)\n    fmt.Printf(\"Content-Length: %s\\n\", contentLength)\n    fmt.Printf(\"Cache-Control: %s\\n\", cacheControl)\n    fmt.Printf(\"Last-Modified: %s\\n\", lastModified)\n\n    // Check for cookies\n    var setCookie = headers[\"Set-Cookie\"]\n    if setCookie != None {\n        fmt.Printf(\"Server set cookie: %s\\n\", setCookie)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#http-status-codes","title":"HTTP Status Codes","text":""},{"location":"stdlib/http/responses/#success-codes-2xx","title":"Success Codes (2xx)","text":"<pre><code>import http\nimport fmt\n\nfunction handleSuccessResponse(response map) {\n    var status = response[\"status\"]\n\n    match status {\n        200 =&gt; fmt.Println(\"\u2705 OK - Request successful\"),\n        201 =&gt; fmt.Println(\"\u2705 Created - Resource created successfully\"),\n        202 =&gt; fmt.Println(\"\u2705 Accepted - Request accepted for processing\"),\n        204 =&gt; fmt.Println(\"\u2705 No Content - Success with no response body\"),\n        _ =&gt; fmt.Printf(\"\u2705 Success - Status: %d\\n\", status)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#client-error-codes-4xx","title":"Client Error Codes (4xx)","text":"<pre><code>import http\nimport fmt\n\nfunction handleClientError(response map) {\n    var status = response[\"status\"]\n    var body = response[\"body\"]\n\n    match status {\n        400 =&gt; fmt.Printf(\"\u274c Bad Request: %s\\n\", body),\n        401 =&gt; fmt.Println(\"\ud83d\udd10 Unauthorized - Authentication required\"),\n        403 =&gt; fmt.Println(\"\ud83d\udeab Forbidden - Access denied\"),\n        404 =&gt; fmt.Println(\"\ud83d\udd0d Not Found - Resource doesn't exist\"),\n        409 =&gt; fmt.Printf(\"\u26a0\ufe0f  Conflict: %s\\n\", body),\n        422 =&gt; fmt.Printf(\"\ud83d\udcdd Unprocessable Entity: %s\\n\", body),\n        429 =&gt; fmt.Println(\"\u23f1\ufe0f  Too Many Requests - Rate limited\"),\n        _ =&gt; fmt.Printf(\"\u274c Client Error %d: %s\\n\", status, body)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#server-error-codes-5xx","title":"Server Error Codes (5xx)","text":"<pre><code>import http\nimport fmt\n\nfunction handleServerError(response map) {\n    var status = response[\"status\"]\n    var body = response[\"body\"]\n\n    match status {\n        500 =&gt; fmt.Printf(\"\ud83d\udca5 Internal Server Error: %s\\n\", body),\n        502 =&gt; fmt.Println(\"\ud83c\udf10 Bad Gateway - Upstream server error\"),\n        503 =&gt; fmt.Println(\"\ud83d\udea7 Service Unavailable - Server temporarily down\"),\n        504 =&gt; fmt.Println(\"\u23f0 Gateway Timeout - Upstream server timeout\"),\n        _ =&gt; fmt.Printf(\"\ud83d\udca5 Server Error %d: %s\\n\", status, body)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#content-type-handling","title":"Content Type Handling","text":""},{"location":"stdlib/http/responses/#json-responses","title":"JSON Responses","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction handleJSONResponse(response map) {\n    var contentType = response[\"headers\"][\"Content-Type\"]\n\n    // Check if response is JSON\n    if contentType == \"application/json\" or contentType == \"application/json; charset=utf-8\" {\n        var data, parseErr = json.Unmarshal(response[\"body\"])\n        if parseErr != None {\n            fmt.Printf(\"JSON Parse Error: %s\\n\", parseErr)\n            return None\n        }\n        return data\n    } else {\n        fmt.Printf(\"Expected JSON, got: %s\\n\", contentType)\n        return None\n    }\n}\n\n// Usage\nvar result = http.Get(\"https://api.example.com/users\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else if response[\"status\"] == 200 {\n    var users = handleJSONResponse(response)\n    if users != None {\n        fmt.Printf(\"Found %d users\\n\", len(users))\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#text-responses","title":"Text Responses","text":"<pre><code>import http\nimport fmt\n\nfunction handleTextResponse(response map) {\n    var contentType = response[\"headers\"][\"Content-Type\"]\n\n    // Handle different text types\n    match contentType {\n        \"text/plain\" =&gt; {\n            fmt.Println(\"Plain text response:\")\n            fmt.Println(response[\"body\"])\n        },\n        \"text/html\" =&gt; {\n            fmt.Println(\"HTML response received\")\n            // Could parse HTML here\n        },\n        \"text/csv\" =&gt; {\n            fmt.Println(\"CSV data received:\")\n            // Could parse CSV here\n        },\n        _ =&gt; {\n            fmt.Printf(\"Text response (%s):\\n\", contentType)\n            fmt.Println(response[\"body\"])\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#binary-responses","title":"Binary Responses","text":"<pre><code>import http\nimport fmt\n\nfunction handleBinaryResponse(response map) {\n    var contentType = response[\"headers\"][\"Content-Type\"]\n    var contentLength = response[\"headers\"][\"Content-Length\"]\n\n    match contentType {\n        \"image/jpeg\", \"image/png\", \"image/gif\" =&gt; {\n            fmt.Printf(\"Image received: %s bytes\\n\", contentLength)\n            // Could save image data here\n        },\n        \"application/pdf\" =&gt; {\n            fmt.Printf(\"PDF received: %s bytes\\n\", contentLength)\n            // Could save PDF data here\n        },\n        \"application/zip\" =&gt; {\n            fmt.Printf(\"ZIP file received: %s bytes\\n\", contentLength)\n            // Could save ZIP data here\n        },\n        _ =&gt; {\n            fmt.Printf(\"Binary data received (%s): %s bytes\\n\", contentType, contentLength)\n        }\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"stdlib/http/responses/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction robustAPICall(url string) {\n    var result = http.Get(url)\n    var response = result[0]\n    var err = result[1]\n\n    // Handle network errors\n    if err != None {\n        fmt.Printf(\"\u274c Network Error: %s\\n\", err)\n        return None, \"network_error\"\n    }\n\n    var status = response[\"status\"]\n\n    // Handle different status code ranges\n    if status &gt;= 200 and status &lt; 300 {\n        // Success - process response\n        return response, \"success\"\n    } else if status &gt;= 300 and status &lt; 400 {\n        // Redirection - could handle automatically\n        fmt.Printf(\"\ud83d\udd04 Redirect: %s\\n\", response[\"statusText\"])\n        return response, \"redirect\"\n    } else if status &gt;= 400 and status &lt; 500 {\n        // Client error - usually don't retry\n        fmt.Printf(\"\u274c Client Error %d: %s\\n\", status, response[\"body\"])\n        return response, \"client_error\"\n    } else if status &gt;= 500 {\n        // Server error - might retry\n        fmt.Printf(\"\ud83d\udca5 Server Error %d: %s\\n\", status, response[\"body\"])\n        return response, \"server_error\"\n    } else {\n        // Unknown status\n        fmt.Printf(\"\u2753 Unknown Status %d: %s\\n\", status, response[\"statusText\"])\n        return response, \"unknown_error\"\n    }\n}\n\n// Usage with error handling\nvar response, errorType = robustAPICall(\"https://api.example.com/data\")\nmatch errorType {\n    \"success\" =&gt; fmt.Println(\"\u2705 API call successful\"),\n    \"network_error\" =&gt; fmt.Println(\"\ud83c\udf10 Check network connection\"),\n    \"client_error\" =&gt; fmt.Println(\"\ud83d\udcdd Fix request parameters\"),\n    \"server_error\" =&gt; fmt.Println(\"\u23f3 Retry later\"),\n    _ =&gt; fmt.Println(\"\u2753 Unknown issue occurred\")\n}\n</code></pre>"},{"location":"stdlib/http/responses/#retry-logic-with-exponential-backoff","title":"Retry Logic with Exponential Backoff","text":"<pre><code>import http\nimport fmt\n\nfunction apiCallWithRetry(url string, maxRetries int) {\n    var attempt = 0\n\n    for attempt &lt; maxRetries {\n        attempt = attempt + 1\n\n        var result = http.Get(url)\n        var response = result[0]\n        var err = result[1]\n\n        // Network error - retry\n        if err != None {\n            fmt.Printf(\"Attempt %d failed: %s\\n\", attempt, err)\n            if attempt &lt; maxRetries {\n                fmt.Printf(\"Retrying in %d seconds...\\n\", attempt * 2)\n                // In real implementation, add delay here\n            }\n            continue\n        }\n\n        var status = response[\"status\"]\n\n        // Success - return response\n        if status &gt;= 200 and status &lt; 300 {\n            fmt.Printf(\"\u2705 Success on attempt %d\\n\", attempt)\n            return response, None\n        }\n\n        // Server error - retry\n        if status &gt;= 500 {\n            fmt.Printf(\"Server error (attempt %d): %d\\n\", attempt, status)\n            if attempt &lt; maxRetries {\n                fmt.Printf(\"Retrying server error...\\n\")\n            }\n            continue\n        }\n\n        // Client error - don't retry\n        if status &gt;= 400 and status &lt; 500 {\n            fmt.Printf(\"\u274c Client error: %d - %s\\n\", status, response[\"statusText\"])\n            return response, \"Client error - not retrying\"\n        }\n    }\n\n    return None, \"All retry attempts failed\"\n}\n\n// Usage\nvar response, retryErr = apiCallWithRetry(\"https://unreliable-api.example.com\", 3)\nif retryErr != None {\n    fmt.Printf(\"Final Error: %s\\n\", retryErr)\n} else {\n    fmt.Printf(\"Success: %s\\n\", response[\"body\"])\n}\n</code></pre>"},{"location":"stdlib/http/responses/#response-validation","title":"Response Validation","text":""},{"location":"stdlib/http/responses/#content-validation","title":"Content Validation","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction validateAPIResponse(response map) {\n    var status = response[\"status\"]\n    var headers = response[\"headers\"]\n    var body = response[\"body\"]\n\n    // Check status code\n    if status != 200 {\n        return \"Invalid status code: \" + status\n    }\n\n    // Check content type\n    var contentType = headers[\"Content-Type\"]\n    if contentType != \"application/json\" {\n        return \"Expected JSON, got: \" + contentType\n    }\n\n    // Check if body is valid JSON\n    var data, parseErr = json.Unmarshal(body)\n    if parseErr != None {\n        return \"Invalid JSON: \" + parseErr\n    }\n\n    // Check required fields (example)\n    if data[\"id\"] == None {\n        return \"Missing required field: id\"\n    }\n\n    if data[\"name\"] == None {\n        return \"Missing required field: name\"\n    }\n\n    return None  // Valid response\n}\n\n// Usage\nvar result = http.Get(\"https://api.example.com/user/123\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Network Error: %s\\n\", err)\n} else {\n    var validationErr = validateAPIResponse(response)\n    if validationErr != None {\n        fmt.Printf(\"Validation Error: %s\\n\", validationErr)\n    } else {\n        fmt.Println(\"\u2705 Response is valid\")\n        var userData, _ = json.Unmarshal(response[\"body\"])\n        fmt.Printf(\"User: %s (ID: %s)\\n\", userData[\"name\"], userData[\"id\"])\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#response-size-limits","title":"Response Size Limits","text":"<pre><code>import http\nimport fmt\n\nfunction checkResponseSize(response map, maxSize int) {\n    var contentLength = response[\"headers\"][\"Content-Length\"]\n\n    if contentLength != None {\n        // Convert string to int (simplified)\n        // In real implementation, use cast.ToInt()\n        fmt.Printf(\"Response size: %s bytes\\n\", contentLength)\n\n        // Check if response is too large\n        // This is a simplified check\n        if len(response[\"body\"]) &gt; maxSize {\n            return \"Response too large\"\n        }\n    }\n\n    return None\n}\n\n// Usage\nvar result = http.Get(\"https://api.example.com/large-data\")\nvar response = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Error: %s\\n\", err)\n} else {\n    var sizeErr = checkResponseSize(response, 1000000)  // 1MB limit\n    if sizeErr != None {\n        fmt.Printf(\"Size Error: %s\\n\", sizeErr)\n    } else {\n        fmt.Println(\"\u2705 Response size acceptable\")\n    }\n}\n</code></pre>"},{"location":"stdlib/http/responses/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/responses/#1-always-check-status-codes","title":"1. Always Check Status Codes","text":"<pre><code>if response[\"status\"] &gt;= 200 and response[\"status\"] &lt; 300 {\n    // Success - process response\n} else {\n    // Error - handle appropriately\n}\n</code></pre>"},{"location":"stdlib/http/responses/#2-validate-content-type","title":"2. Validate Content Type","text":"<pre><code>var expectedType = \"application/json\"\nvar actualType = response[\"headers\"][\"Content-Type\"]\nif actualType != expectedType {\n    fmt.Printf(\"Expected %s, got %s\\n\", expectedType, actualType)\n}\n</code></pre>"},{"location":"stdlib/http/responses/#3-handle-empty-responses","title":"3. Handle Empty Responses","text":"<pre><code>var body = response[\"body\"]\nif body == \"\" or body == None {\n    fmt.Println(\"Empty response body\")\n} else {\n    // Process body\n}\n</code></pre>"},{"location":"stdlib/http/responses/#4-log-response-details-for-debugging","title":"4. Log Response Details for Debugging","text":"<pre><code>fmt.Printf(\"Status: %d\\n\", response[\"status\"])\nfmt.Printf(\"Headers: %s\\n\", response[\"headers\"])\nfmt.Printf(\"Body length: %d\\n\", len(response[\"body\"]))\n</code></pre>"},{"location":"stdlib/http/responses/#5-use-pattern-matching-for-status-handling","title":"5. Use Pattern Matching for Status Handling","text":"<pre><code>var status = response[\"status\"]\nmatch status {\n    200 =&gt; handleSuccess(response),\n    404 =&gt; handleNotFound(response),\n    500 =&gt; handleServerError(response),\n    _ =&gt; handleOtherStatus(response, status)\n}\n</code></pre>"},{"location":"stdlib/http/responses/#next-steps","title":"Next Steps","text":"<ul> <li>Examples &amp; Patterns - See real-world examples and advanced patterns</li> <li>HTTP Client - Learn about basic HTTP methods</li> <li>Request Building - Advanced request customization</li> </ul>"},{"location":"stdlib/http/routing/","title":"Routing &amp; Mux","text":"<p>HTTP routing allows you to direct different URLs to different handler functions. Harneet's HTTP module provides a powerful multiplexer (mux) system based on Go's <code>http.ServeMux</code> for pattern-based URL routing.</p>"},{"location":"stdlib/http/routing/#servemux-basics","title":"ServeMux Basics","text":""},{"location":"stdlib/http/routing/#httpnewmux","title":"http.NewMux()","text":"<p>Creates a new HTTP request multiplexer for routing requests.</p> <p>Syntax: <pre><code>http.NewMux() (mux, error)\n</code></pre></p> <p>Returns: - <code>mux</code> (map) - ServeMux object for routing - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Basic Mux Creation: <pre><code>import http\nimport fmt\n\n// Create a new mux\nvar result = http.NewMux()\nvar mux = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Failed to create mux: %s\\n\", err)\n} else {\n    fmt.Println(\"\u2705 Mux created successfully\")\n}\n</code></pre></p>"},{"location":"stdlib/http/routing/#route-registration","title":"Route Registration","text":""},{"location":"stdlib/http/routing/#httphandlefuncmux-pattern-handler","title":"http.HandleFunc(mux, pattern, handler)","text":"<p>Registers a handler function for a URL pattern.</p> <p>Syntax: <pre><code>http.HandleFunc(mux, pattern, handler) (error)\n</code></pre></p> <p>Parameters: - <code>mux</code> (map) - ServeMux object - <code>pattern</code> (string) - URL pattern (e.g., '/api/users', '/static/') - <code>handler</code> (function) - Handler function with signature <code>(request, response)</code></p> <p>Returns: - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Basic Route Registration: <pre><code>import http\nimport json\nimport fmt\n\n// Create mux and register routes\nfunction setupRoutes() {\n    var mux = http.NewMux()[0]\n\n    // Register different routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/about\", aboutHandler)\n    http.HandleFunc(mux, \"/api/users\", usersHandler)\n    http.HandleFunc(mux, \"/api/posts\", postsHandler)\n    http.HandleFunc(mux, \"/health\", healthHandler)\n\n    return mux\n}\n\n// Handler functions\nfunction homeHandler(request map, response map) {\n    var html = \"&lt;h1&gt;Welcome to Harneet Web Server!&lt;/h1&gt;\"\n    html = html + \"&lt;p&gt;&lt;a href='/about'&gt;About&lt;/a&gt; | &lt;a href='/api/users'&gt;Users API&lt;/a&gt;&lt;/p&gt;\"\n    http.WriteResponse(response, 200, \"text/html\", html)\n}\n\nfunction aboutHandler(request map, response map) {\n    var html = \"&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;This is a Harneet web application.&lt;/p&gt;\"\n    http.WriteResponse(response, 200, \"text/html\", html)\n}\n\nfunction usersHandler(request map, response map) {\n    var users = [\n        {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n    ]\n    var jsonData, _ = json.Marshal(users)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction postsHandler(request map, response map) {\n    var posts = [\n        {\"id\": 1, \"title\": \"First Post\", \"author\": \"Alice\"},\n        {\"id\": 2, \"title\": \"Second Post\", \"author\": \"Bob\"}\n    ]\n    var jsonData, _ = json.Marshal(posts)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction healthHandler(request map, response map) {\n    var health = {\"status\": \"healthy\", \"timestamp\": \"2024-01-01T12:00:00Z\"}\n    var jsonData, _ = json.Marshal(health)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// Usage\nvar mux = setupRoutes()\nvar server = http.NewServer(\":8080\")[0]\nhttp.SetHandler(server, mux)\nhttp.ListenAndServe(server)\n</code></pre></p>"},{"location":"stdlib/http/routing/#url-patterns","title":"URL Patterns","text":""},{"location":"stdlib/http/routing/#exact-match-patterns","title":"Exact Match Patterns","text":"<pre><code>// Exact path matching\nhttp.HandleFunc(mux, \"/\", homeHandler)           // Only matches \"/\"\nhttp.HandleFunc(mux, \"/about\", aboutHandler)     // Only matches \"/about\"\nhttp.HandleFunc(mux, \"/contact\", contactHandler) // Only matches \"/contact\"\n</code></pre>"},{"location":"stdlib/http/routing/#subtree-patterns","title":"Subtree Patterns","text":"<pre><code>// Subtree matching (ends with /)\nhttp.HandleFunc(mux, \"/api/\", apiHandler)        // Matches \"/api/*\"\nhttp.HandleFunc(mux, \"/static/\", staticHandler)  // Matches \"/static/*\"\nhttp.HandleFunc(mux, \"/admin/\", adminHandler)    // Matches \"/admin/*\"\n</code></pre>"},{"location":"stdlib/http/routing/#pattern-priority","title":"Pattern Priority","text":"<pre><code>import http\n\nfunction setupPriorityRoutes() {\n    var mux = http.NewMux()[0]\n\n    // More specific patterns take priority\n    http.HandleFunc(mux, \"/api/users/profile\", userProfileHandler)  // Higher priority\n    http.HandleFunc(mux, \"/api/users/\", usersSubtreeHandler)        // Lower priority\n    http.HandleFunc(mux, \"/api/\", apiSubtreeHandler)                // Lowest priority\n\n    return mux\n}\n\nfunction userProfileHandler(request map, response map) {\n    http.WriteResponse(response, 200, \"text/plain\", \"User Profile - Specific Handler\")\n}\n\nfunction usersSubtreeHandler(request map, response map) {\n    var path = request[\"path\"]\n    http.WriteResponse(response, 200, \"text/plain\", \"Users Subtree: \" + path)\n}\n\nfunction apiSubtreeHandler(request map, response map) {\n    var path = request[\"path\"]\n    http.WriteResponse(response, 200, \"text/plain\", \"API Subtree: \" + path)\n}\n</code></pre>"},{"location":"stdlib/http/routing/#restful-api-routing","title":"RESTful API Routing","text":""},{"location":"stdlib/http/routing/#method-based-routing","title":"Method-Based Routing","text":"<pre><code>import http\nimport json\nimport fmt\n\n// RESTful API with method-based routing\nfunction setupRESTAPI() {\n    var mux = http.NewMux()[0]\n\n    // User resource endpoints\n    http.HandleFunc(mux, \"/api/users\", usersRESTHandler)\n    http.HandleFunc(mux, \"/api/users/\", userRESTHandler)\n\n    // Post resource endpoints  \n    http.HandleFunc(mux, \"/api/posts\", postsRESTHandler)\n    http.HandleFunc(mux, \"/api/posts/\", postRESTHandler)\n\n    return mux\n}\n\n// Users collection handler\nfunction usersRESTHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    match method {\n        \"GET\" =&gt; getUsersList(request, response),\n        \"POST\" =&gt; createUser(request, response),\n        _ =&gt; methodNotAllowed(response, [\"GET\", \"POST\"])\n    }\n}\n\n// Individual user handler\nfunction userRESTHandler(request map, response map) {\n    var method = request[\"method\"]\n    var path = request[\"path\"]\n\n    // Extract user ID from path (simplified)\n    var userId = extractUserIdFromPath(path)\n\n    match method {\n        \"GET\" =&gt; getUser(userId, request, response),\n        \"PUT\" =&gt; updateUser(userId, request, response),\n        \"DELETE\" =&gt; deleteUser(userId, request, response),\n        _ =&gt; methodNotAllowed(response, [\"GET\", \"PUT\", \"DELETE\"])\n    }\n}\n\n// Implementation functions\nfunction getUsersList(request map, response map) {\n    var query = request[\"query\"]\n    var page = query[\"page\"]\n    var limit = query[\"limit\"]\n\n    // Simulate user list with pagination\n    var users = [\n        {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"}\n    ]\n\n    var result = {\n        \"users\": users,\n        \"page\": page,\n        \"limit\": limit,\n        \"total\": len(users)\n    }\n\n    var jsonData, _ = json.Marshal(result)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction createUser(request map, response map) {\n    var body = request[\"body\"]\n    var userData, parseErr = json.Unmarshal(body)\n\n    if parseErr != None {\n        var errorResponse = {\"error\": \"Invalid JSON\"}\n        var jsonError, _ = json.Marshal(errorResponse)\n        http.WriteResponse(response, 400, \"application/json\", jsonError)\n        return\n    }\n\n    // Simulate user creation\n    userData[\"id\"] = 123\n    userData[\"created_at\"] = \"2024-01-01T12:00:00Z\"\n\n    var jsonData, _ = json.Marshal(userData)\n    http.WriteResponse(response, 201, \"application/json\", jsonData)\n}\n\nfunction getUser(userId string, request map, response map) {\n    // Simulate user lookup\n    var user = {\"id\": userId, \"name\": \"Alice\", \"email\": \"alice@example.com\"}\n    var jsonData, _ = json.Marshal(user)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction updateUser(userId string, request map, response map) {\n    var body = request[\"body\"]\n    var updates, parseErr = json.Unmarshal(body)\n\n    if parseErr != None {\n        var errorResponse = {\"error\": \"Invalid JSON\"}\n        var jsonError, _ = json.Marshal(errorResponse)\n        http.WriteResponse(response, 400, \"application/json\", jsonError)\n        return\n    }\n\n    // Simulate user update\n    updates[\"id\"] = userId\n    updates[\"updated_at\"] = \"2024-01-01T12:00:00Z\"\n\n    var jsonData, _ = json.Marshal(updates)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction deleteUser(userId string, request map, response map) {\n    // Simulate user deletion\n    var result = {\"message\": \"User deleted\", \"id\": userId}\n    var jsonData, _ = json.Marshal(result)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction methodNotAllowed(response map, allowedMethods array) {\n    var allowedStr = strings.Join(allowedMethods, \", \")\n    http.SetResponseHeader(response, \"Allow\", allowedStr)\n\n    var errorResponse = {\"error\": \"Method not allowed\", \"allowed\": allowedMethods}\n    var jsonError, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 405, \"application/json\", jsonError)\n}\n\nfunction extractUserIdFromPath(path string) {\n    // Extract user ID from path like \"/api/users/123\"\n    var parts = strings.Split(path, \"/\")\n    if len(parts) &gt;= 4 {\n        return parts[3]\n    }\n    return \"\"\n}\n</code></pre>"},{"location":"stdlib/http/routing/#static-file-serving","title":"Static File Serving","text":""},{"location":"stdlib/http/routing/#httpfileserverroot","title":"http.FileServer(root)","text":"<p>Creates a file server handler for serving static files.</p> <p>Syntax: <pre><code>http.FileServer(root) (handler, error)\n</code></pre></p> <p>Parameters: - <code>root</code> (string) - Root directory path for static files</p> <p>Examples:</p> <p>Static File Server: <pre><code>import http\nimport fmt\n\nfunction setupStaticServer() {\n    var mux = http.NewMux()[0]\n\n    // Serve static files from ./public directory\n    var fileServer = http.FileServer(\"./public\")[0]\n    http.Handle(mux, \"/static/\", http.StripPrefix(\"/static/\", fileServer))\n\n    // Serve favicon\n    http.HandleFunc(mux, \"/favicon.ico\", faviconHandler)\n\n    // API routes\n    http.HandleFunc(mux, \"/api/\", apiHandler)\n\n    // Default route\n    http.HandleFunc(mux, \"/\", indexHandler)\n\n    return mux\n}\n\nfunction faviconHandler(request map, response map) {\n    // Serve favicon from static files\n    var faviconPath = \"./public/favicon.ico\"\n    var content = readFile(faviconPath)  // Simplified file reading\n    http.WriteResponse(response, 200, \"image/x-icon\", content)\n}\n\nfunction indexHandler(request map, response map) {\n    var html = `\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Harneet Web App&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"/static/css/style.css\"&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Welcome to Harneet!&lt;/h1&gt;\n        &lt;script src=\"/static/js/app.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    `\n    http.WriteResponse(response, 200, \"text/html\", html)\n}\n</code></pre></p>"},{"location":"stdlib/http/routing/#route-groups-and-subrouters","title":"Route Groups and Subrouters","text":""},{"location":"stdlib/http/routing/#creating-route-groups","title":"Creating Route Groups","text":"<pre><code>import http\n\nfunction setupRouteGroups() {\n    var mainMux = http.NewMux()[0]\n\n    // API v1 routes\n    var apiV1Mux = http.NewMux()[0]\n    setupAPIv1Routes(apiV1Mux)\n    http.Handle(mainMux, \"/api/v1/\", http.StripPrefix(\"/api/v1\", apiV1Mux))\n\n    // API v2 routes\n    var apiV2Mux = http.NewMux()[0]\n    setupAPIv2Routes(apiV2Mux)\n    http.Handle(mainMux, \"/api/v2/\", http.StripPrefix(\"/api/v2\", apiV2Mux))\n\n    // Admin routes\n    var adminMux = http.NewMux()[0]\n    setupAdminRoutes(adminMux)\n    http.Handle(mainMux, \"/admin/\", http.StripPrefix(\"/admin\", adminMux))\n\n    return mainMux\n}\n\nfunction setupAPIv1Routes(mux map) {\n    http.HandleFunc(mux, \"/users\", v1UsersHandler)\n    http.HandleFunc(mux, \"/posts\", v1PostsHandler)\n}\n\nfunction setupAPIv2Routes(mux map) {\n    http.HandleFunc(mux, \"/users\", v2UsersHandler)\n    http.HandleFunc(mux, \"/posts\", v2PostsHandler)\n    http.HandleFunc(mux, \"/comments\", v2CommentsHandler)  // New in v2\n}\n\nfunction setupAdminRoutes(mux map) {\n    http.HandleFunc(mux, \"/dashboard\", adminDashboardHandler)\n    http.HandleFunc(mux, \"/users\", adminUsersHandler)\n    http.HandleFunc(mux, \"/settings\", adminSettingsHandler)\n}\n</code></pre>"},{"location":"stdlib/http/routing/#path-parameters-and-query-strings","title":"Path Parameters and Query Strings","text":""},{"location":"stdlib/http/routing/#extracting-path-parameters","title":"Extracting Path Parameters","text":"<pre><code>import http\nimport strings\nimport fmt\n\nfunction setupParameterizedRoutes() {\n    var mux = http.NewMux()[0]\n\n    // Routes with path parameters\n    http.HandleFunc(mux, \"/users/\", userHandler)           // /users/{id}\n    http.HandleFunc(mux, \"/posts/\", postHandler)           // /posts/{id}\n    http.HandleFunc(mux, \"/categories/\", categoryHandler)  // /categories/{slug}\n\n    return mux\n}\n\nfunction userHandler(request map, response map) {\n    var path = request[\"path\"]\n    var userId = extractPathParameter(path, \"/users/\")\n\n    if userId == \"\" {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"User ID required\\\"}\")\n        return\n    }\n\n    var user = {\"id\": userId, \"name\": \"User \" + userId}\n    var jsonData, _ = json.Marshal(user)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction postHandler(request map, response map) {\n    var path = request[\"path\"]\n    var postId = extractPathParameter(path, \"/posts/\")\n    var query = request[\"query\"]\n\n    // Handle query parameters\n    var includeComments = query[\"comments\"] == \"true\"\n    var format = query[\"format\"]\n\n    var post = {\n        \"id\": postId,\n        \"title\": \"Post \" + postId,\n        \"content\": \"This is post content...\",\n        \"includeComments\": includeComments\n    }\n\n    if format == \"xml\" {\n        var xmlData = convertToXML(post)  // Simplified\n        http.WriteResponse(response, 200, \"application/xml\", xmlData)\n    } else {\n        var jsonData, _ = json.Marshal(post)\n        http.WriteResponse(response, 200, \"application/json\", jsonData)\n    }\n}\n\nfunction extractPathParameter(path string, prefix string) {\n    if strings.HasPrefix(path, prefix) {\n        var param = strings.TrimPrefix(path, prefix)\n        var parts = strings.Split(param, \"/\")\n        if len(parts) &gt; 0 and parts[0] != \"\" {\n            return parts[0]\n        }\n    }\n    return \"\"\n}\n</code></pre>"},{"location":"stdlib/http/routing/#query-string-processing","title":"Query String Processing","text":"<pre><code>import http\nimport strings\nimport fmt\n\nfunction searchHandler(request map, response map) {\n    var query = request[\"query\"]\n\n    // Extract search parameters\n    var searchTerm = query[\"q\"]\n    var category = query[\"category\"]\n    var page = query[\"page\"]\n    var limit = query[\"limit\"]\n    var sortBy = query[\"sort\"]\n    var order = query[\"order\"]\n\n    // Set defaults\n    if page == None { page = \"1\" }\n    if limit == None { limit = \"10\" }\n    if sortBy == None { sortBy = \"created_at\" }\n    if order == None { order = \"desc\" }\n\n    // Validate parameters\n    if searchTerm == None or searchTerm == \"\" {\n        var errorResponse = {\"error\": \"Search term 'q' is required\"}\n        var jsonError, _ = json.Marshal(errorResponse)\n        http.WriteResponse(response, 400, \"application/json\", jsonError)\n        return\n    }\n\n    // Simulate search results\n    var results = [\n        {\"id\": 1, \"title\": \"Result 1\", \"category\": category},\n        {\"id\": 2, \"title\": \"Result 2\", \"category\": category}\n    ]\n\n    var searchResponse = {\n        \"query\": searchTerm,\n        \"category\": category,\n        \"page\": page,\n        \"limit\": limit,\n        \"sort\": sortBy,\n        \"order\": order,\n        \"results\": results,\n        \"total\": len(results)\n    }\n\n    var jsonData, _ = json.Marshal(searchResponse)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/routing/#error-handling-in-routes","title":"Error Handling in Routes","text":""},{"location":"stdlib/http/routing/#404-not-found-handler","title":"404 Not Found Handler","text":"<pre><code>import http\nimport json\n\nfunction setup404Handler() {\n    var mux = http.NewMux()[0]\n\n    // Register specific routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/api/users\", usersHandler)\n\n    // Catch-all for 404s (this would be handled by middleware)\n    http.HandleFunc(mux, \"/\", notFoundHandler)\n\n    return mux\n}\n\nfunction notFoundHandler(request map, response map) {\n    var path = request[\"path\"]\n    var method = request[\"method\"]\n\n    var errorResponse = {\n        \"error\": \"Not Found\",\n        \"message\": \"The requested resource was not found\",\n        \"path\": path,\n        \"method\": method,\n        \"status\": 404\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 404, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/routing/#route-specific-error-handling","title":"Route-Specific Error Handling","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction safeRouteHandler(request map, response map) {\n    // Wrap handler logic in error handling\n    var result = processRequest(request)\n    var data = result[0]\n    var err = result[1]\n\n    if err != None {\n        handleRouteError(err, response)\n        return\n    }\n\n    var jsonData, jsonErr = json.Marshal(data)\n    if jsonErr != None {\n        handleRouteError(\"JSON encoding failed: \" + jsonErr, response)\n        return\n    }\n\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\nfunction handleRouteError(error string, response map) {\n    fmt.Printf(\"Route error: %s\\n\", error)\n\n    var errorResponse = {\n        \"error\": \"Internal Server Error\",\n        \"message\": \"An error occurred processing your request\",\n        \"timestamp\": \"2024-01-01T12:00:00Z\"\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 500, \"application/json\", jsonData)\n}\n\nfunction processRequest(request map) {\n    // Simulate request processing that might fail\n    var success = true  // This would be actual processing logic\n\n    if success {\n        var data = {\"message\": \"Request processed successfully\"}\n        return data, None\n    } else {\n        return None, \"Processing failed\"\n    }\n}\n</code></pre>"},{"location":"stdlib/http/routing/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/routing/#1-use-clear-url-patterns","title":"1. Use Clear URL Patterns","text":"<pre><code>// Good - Clear and RESTful\nhttp.HandleFunc(mux, \"/api/users\", usersHandler)\nhttp.HandleFunc(mux, \"/api/users/\", userHandler)\nhttp.HandleFunc(mux, \"/api/posts\", postsHandler)\n\n// Bad - Unclear patterns\nhttp.HandleFunc(mux, \"/u\", usersHandler)\nhttp.HandleFunc(mux, \"/data\", dataHandler)\n</code></pre>"},{"location":"stdlib/http/routing/#2-group-related-routes","title":"2. Group Related Routes","text":"<pre><code>// API routes\nhttp.HandleFunc(mux, \"/api/users\", usersAPIHandler)\nhttp.HandleFunc(mux, \"/api/posts\", postsAPIHandler)\n\n// Admin routes  \nhttp.HandleFunc(mux, \"/admin/users\", adminUsersHandler)\nhttp.HandleFunc(mux, \"/admin/settings\", adminSettingsHandler)\n\n// Public routes\nhttp.HandleFunc(mux, \"/\", homeHandler)\nhttp.HandleFunc(mux, \"/about\", aboutHandler)\n</code></pre>"},{"location":"stdlib/http/routing/#3-handle-different-http-methods","title":"3. Handle Different HTTP Methods","text":"<pre><code>function resourceHandler(request map, response map) {\n    var method = request[\"method\"]\n\n    match method {\n        \"GET\" =&gt; handleGet(request, response),\n        \"POST\" =&gt; handlePost(request, response),\n        \"PUT\" =&gt; handlePut(request, response),\n        \"DELETE\" =&gt; handleDelete(request, response),\n        _ =&gt; methodNotAllowed(response)\n    }\n}\n</code></pre>"},{"location":"stdlib/http/routing/#4-validate-path-parameters","title":"4. Validate Path Parameters","text":"<pre><code>function userHandler(request map, response map) {\n    var userId = extractPathParameter(request[\"path\"], \"/users/\")\n\n    if userId == \"\" {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"User ID required\\\"}\")\n        return\n    }\n\n    // Validate user ID format (e.g., numeric)\n    if !isValidUserId(userId) {\n        http.WriteResponse(response, 400, \"application/json\", \"{\\\"error\\\": \\\"Invalid user ID format\\\"}\")\n        return\n    }\n\n    // Process valid request\n    processUserRequest(userId, request, response)\n}\n</code></pre>"},{"location":"stdlib/http/routing/#5-use-consistent-response-formats","title":"5. Use Consistent Response Formats","text":"<pre><code>// Success response format\n{\n    \"data\": {...},\n    \"status\": \"success\",\n    \"timestamp\": \"2024-01-01T12:00:00Z\"\n}\n\n// Error response format\n{\n    \"error\": \"Error message\",\n    \"code\": \"ERROR_CODE\",\n    \"status\": \"error\",\n    \"timestamp\": \"2024-01-01T12:00:00Z\"\n}\n</code></pre>"},{"location":"stdlib/http/routing/#next-steps","title":"Next Steps","text":"<ul> <li>Middleware - Learn about middleware for cross-cutting concerns</li> <li>Authentication - Implement authentication and authorization</li> <li>HTTP Server - Go back to server basics</li> <li>Cookies &amp; Sessions - Handle user sessions and cookies</li> </ul>"},{"location":"stdlib/http/server/","title":"HTTP Server","text":"<p>The HTTP server functionality provides comprehensive server-side HTTP capabilities, allowing you to build web servers, APIs, and web applications in Harneet. This wraps Go's powerful <code>net/http</code> server with Harneet's simple and consistent API.</p>"},{"location":"stdlib/http/server/#quick-start","title":"Quick Start","text":"<pre><code>import http\nimport fmt\n\n// Create a simple HTTP server\nvar server = http.NewServer(\":8080\")[0]\nvar mux = http.NewMux()[0]\n\n// Define a simple handler\nfunction helloHandler(request map, response map) {\n    http.WriteResponse(response, 200, \"text/plain\", \"Hello, World!\")\n}\n\n// Register the handler\nhttp.HandleFunc(mux, \"/hello\", helloHandler)\n\n// Set the mux as the server handler\nhttp.SetHandler(server, mux)\n\n// Start the server\nfmt.Println(\"Server starting on :8080\")\nhttp.ListenAndServe(server)\n</code></pre>"},{"location":"stdlib/http/server/#server-creation","title":"Server Creation","text":""},{"location":"stdlib/http/server/#httpnewserveraddr","title":"http.NewServer(addr)","text":"<p>Creates a new HTTP server instance.</p> <p>Syntax: <pre><code>http.NewServer(addr) (server, error)\n</code></pre></p> <p>Parameters: - <code>addr</code> (string) - Server address (e.g., \":8080\", \"localhost:3000\")</p> <p>Returns: - <code>server</code> (map) - Server object - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Basic Server Creation: <pre><code>import http\nimport fmt\n\n// Create server on port 8080\nvar result = http.NewServer(\":8080\")\nvar server = result[0]\nvar err = result[1]\n\nif err != None {\n    fmt.Printf(\"Failed to create server: %s\\n\", err)\n} else {\n    fmt.Println(\"\u2705 Server created successfully\")\n    fmt.Printf(\"Server address: %s\\n\", server[\"addr\"])\n    fmt.Printf(\"Read timeout: %d seconds\\n\", server[\"readTimeout\"])\n    fmt.Printf(\"Write timeout: %d seconds\\n\", server[\"writeTimeout\"])\n}\n</code></pre></p> <p>Server with Custom Configuration: <pre><code>import http\nimport fmt\n\n// Create and configure server\nfunction createConfiguredServer(port string) {\n    var server = http.NewServer(\":\" + port)[0]\n\n    // Configure timeouts (if supported)\n    server = http.SetServerTimeout(server, \"read\", 60)[0]\n    server = http.SetServerTimeout(server, \"write\", 60)[0]\n    server = http.SetServerTimeout(server, \"idle\", 300)[0]\n\n    return server\n}\n\n// Usage\nvar server = createConfiguredServer(\"8080\")\nfmt.Printf(\"Configured server: %s\\n\", server[\"addr\"])\n</code></pre></p>"},{"location":"stdlib/http/server/#server-object-structure","title":"Server Object Structure","text":"<p>Server objects have the following structure:</p> <pre><code>{\n    \"addr\": \":8080\",              // Server address\n    \"readTimeout\": 30,            // Read timeout in seconds\n    \"writeTimeout\": 30,           // Write timeout in seconds\n    \"idleTimeout\": 120,           // Idle timeout in seconds\n    \"handler\": muxObject,         // Request handler (mux or function)\n    \"tls\": {                      // TLS configuration (if enabled)\n        \"certFile\": \"cert.pem\",\n        \"keyFile\": \"key.pem\"\n    }\n}\n</code></pre>"},{"location":"stdlib/http/server/#server-lifecycle","title":"Server Lifecycle","text":""},{"location":"stdlib/http/server/#httplistenandserveserver","title":"http.ListenAndServe(server)","text":"<p>Starts the HTTP server and begins listening for requests.</p> <p>Syntax: <pre><code>http.ListenAndServe(server) (error)\n</code></pre></p> <p>Parameters: - <code>server</code> (map) - Server object from NewServer</p> <p>Returns: - <code>error</code> - None on success, error on failure</p> <p>Examples:</p> <p>Basic Server Start: <pre><code>import http\nimport fmt\n\nfunction startServer() {\n    var server = http.NewServer(\":8080\")[0]\n    var mux = http.NewMux()[0]\n\n    // Add some routes\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/api/health\", healthHandler)\n\n    // Set handler\n    http.SetHandler(server, mux)\n\n    fmt.Println(\"\ud83d\ude80 Starting server on :8080\")\n    fmt.Println(\"Visit: http://localhost:8080\")\n\n    // This blocks until server stops\n    var err = http.ListenAndServe(server)[1]\n    if err != None {\n        fmt.Printf(\"\u274c Server error: %s\\n\", err)\n    }\n}\n\n// Handler functions\nfunction homeHandler(request map, response map) {\n    var html = \"&lt;h1&gt;Welcome to Harneet Server!&lt;/h1&gt;&lt;p&gt;Server is running.&lt;/p&gt;\"\n    http.WriteResponse(response, 200, \"text/html\", html)\n}\n\nfunction healthHandler(request map, response map) {\n    var healthData = {\"status\": \"healthy\", \"timestamp\": \"2024-01-01T12:00:00Z\"}\n    var jsonData, _ = json.Marshal(healthData)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// Start the server\nstartServer()\n</code></pre></p>"},{"location":"stdlib/http/server/#httplistenandservetlsserver-certfile-keyfile","title":"http.ListenAndServeTLS(server, certFile, keyFile)","text":"<p>Starts an HTTPS server with TLS encryption.</p> <p>Syntax: <pre><code>http.ListenAndServeTLS(server, certFile, keyFile) (error)\n</code></pre></p> <p>Parameters: - <code>server</code> (map) - Server object - <code>certFile</code> (string) - Path to certificate file - <code>keyFile</code> (string) - Path to private key file</p> <p>Examples:</p> <p>HTTPS Server: <pre><code>import http\nimport fmt\n\nfunction startHTTPSServer() {\n    var server = http.NewServer(\":8443\")[0]\n    var mux = http.NewMux()[0]\n\n    // Add secure routes\n    http.HandleFunc(mux, \"/secure\", secureHandler)\n    http.SetHandler(server, mux)\n\n    fmt.Println(\"\ud83d\udd12 Starting HTTPS server on :8443\")\n\n    var err = http.ListenAndServeTLS(server, \"cert.pem\", \"key.pem\")[1]\n    if err != None {\n        fmt.Printf(\"\u274c HTTPS Server error: %s\\n\", err)\n    }\n}\n\nfunction secureHandler(request map, response map) {\n    var data = {\"message\": \"This is a secure endpoint\", \"encrypted\": true}\n    var jsonData, _ = json.Marshal(data)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre></p>"},{"location":"stdlib/http/server/#httpshutdownserver","title":"http.Shutdown(server)","text":"<p>Gracefully shuts down the server.</p> <p>Syntax: <pre><code>http.Shutdown(server) (error)\n</code></pre></p> <p>Examples:</p> <p>Graceful Shutdown: <pre><code>import http\nimport fmt\n\nvar globalServer = None\n\nfunction startServerWithShutdown() {\n    globalServer = http.NewServer(\":8080\")[0]\n    var mux = http.NewMux()[0]\n\n    http.HandleFunc(mux, \"/\", homeHandler)\n    http.HandleFunc(mux, \"/shutdown\", shutdownHandler)\n    http.SetHandler(globalServer, mux)\n\n    fmt.Println(\"Server starting with shutdown endpoint\")\n    http.ListenAndServe(globalServer)\n}\n\nfunction shutdownHandler(request map, response map) {\n    http.WriteResponse(response, 200, \"text/plain\", \"Server shutting down...\")\n\n    // Shutdown in background (simplified)\n    fmt.Println(\"Initiating graceful shutdown...\")\n    var err = http.Shutdown(globalServer)[1]\n    if err != None {\n        fmt.Printf(\"Shutdown error: %s\\n\", err)\n    }\n}\n</code></pre></p>"},{"location":"stdlib/http/server/#handler-management","title":"Handler Management","text":""},{"location":"stdlib/http/server/#httpsethandlerserver-handler","title":"http.SetHandler(server, handler)","text":"<p>Sets the main handler for the server.</p> <p>Syntax: <pre><code>http.SetHandler(server, handler) (error)\n</code></pre></p> <p>Parameters: - <code>server</code> (map) - Server object - <code>handler</code> (map) - Handler object (usually a mux)</p> <p>Examples:</p> <p>Setting Server Handler: <pre><code>import http\n\nfunction setupServer() {\n    var server = http.NewServer(\":8080\")[0]\n    var mux = http.NewMux()[0]\n\n    // Configure routes\n    http.HandleFunc(mux, \"/api/users\", usersHandler)\n    http.HandleFunc(mux, \"/api/posts\", postsHandler)\n\n    // Set the mux as the server's handler\n    var err = http.SetHandler(server, mux)[1]\n    if err != None {\n        fmt.Printf(\"Failed to set handler: %s\\n\", err)\n        return None\n    }\n\n    return server\n}\n</code></pre></p>"},{"location":"stdlib/http/server/#response-writing","title":"Response Writing","text":""},{"location":"stdlib/http/server/#httpwriteresponseresponse-status-contenttype-body","title":"http.WriteResponse(response, status, contentType, body)","text":"<p>Writes an HTTP response.</p> <p>Syntax: <pre><code>http.WriteResponse(response, status, contentType, body) (error)\n</code></pre></p> <p>Parameters: - <code>response</code> (map) - Response writer object - <code>status</code> (int) - HTTP status code - <code>contentType</code> (string) - Content-Type header - <code>body</code> (string) - Response body</p> <p>Examples:</p> <p>Different Response Types: <pre><code>import http\nimport json\nimport fmt\n\n// JSON response\nfunction jsonResponse(response map, data map) {\n    var jsonData, err = json.Marshal(data)\n    if err != None {\n        http.WriteResponse(response, 500, \"text/plain\", \"JSON encoding error\")\n        return\n    }\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n\n// HTML response\nfunction htmlResponse(response map, html string) {\n    http.WriteResponse(response, 200, \"text/html\", html)\n}\n\n// Error response\nfunction errorResponse(response map, status int, message string) {\n    var errorData = {\"error\": message, \"status\": status}\n    var jsonData, _ = json.Marshal(errorData)\n    http.WriteResponse(response, status, \"application/json\", jsonData)\n}\n\n// File response\nfunction fileResponse(response map, filename string, content string) {\n    var contentType = \"application/octet-stream\"\n\n    // Set content type based on file extension\n    match filename {\n        f if strings.HasSuffix(f, \".html\") =&gt; contentType = \"text/html\",\n        f if strings.HasSuffix(f, \".css\") =&gt; contentType = \"text/css\",\n        f if strings.HasSuffix(f, \".js\") =&gt; contentType = \"application/javascript\",\n        f if strings.HasSuffix(f, \".json\") =&gt; contentType = \"application/json\",\n        _ =&gt; contentType = \"application/octet-stream\"\n    }\n\n    http.SetHeader(response, \"Content-Disposition\", \"attachment; filename=\" + filename)\n    http.WriteResponse(response, 200, contentType, content)\n}\n\n// Usage in handlers\nfunction apiHandler(request map, response map) {\n    var data = {\"message\": \"Hello from API\", \"timestamp\": \"2024-01-01T12:00:00Z\"}\n    jsonResponse(response, data)\n}\n\nfunction pageHandler(request map, response map) {\n    var html = \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n    htmlResponse(response, html)\n}\n\nfunction notFoundHandler(request map, response map) {\n    errorResponse(response, 404, \"Resource not found\")\n}\n</code></pre></p>"},{"location":"stdlib/http/server/#httpsetresponseheaderresponse-key-value","title":"http.SetResponseHeader(response, key, value)","text":"<p>Sets a response header.</p> <p>Syntax: <pre><code>http.SetResponseHeader(response, key, value) (error)\n</code></pre></p> <p>Examples:</p> <p>Custom Response Headers: <pre><code>import http\n\nfunction corsHandler(request map, response map) {\n    // Set CORS headers\n    http.SetResponseHeader(response, \"Access-Control-Allow-Origin\", \"*\")\n    http.SetResponseHeader(response, \"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE\")\n    http.SetResponseHeader(response, \"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n\n    // Set caching headers\n    http.SetResponseHeader(response, \"Cache-Control\", \"no-cache, no-store, must-revalidate\")\n    http.SetResponseHeader(response, \"Pragma\", \"no-cache\")\n    http.SetResponseHeader(response, \"Expires\", \"0\")\n\n    // Set security headers\n    http.SetResponseHeader(response, \"X-Content-Type-Options\", \"nosniff\")\n    http.SetResponseHeader(response, \"X-Frame-Options\", \"DENY\")\n    http.SetResponseHeader(response, \"X-XSS-Protection\", \"1; mode=block\")\n\n    var data = {\"message\": \"CORS enabled endpoint\"}\n    var jsonData, _ = json.Marshal(data)\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre></p>"},{"location":"stdlib/http/server/#request-processing","title":"Request Processing","text":""},{"location":"stdlib/http/server/#request-object-structure","title":"Request Object Structure","text":"<p>Request objects passed to handlers have this structure:</p> <pre><code>{\n    \"method\": \"GET\",              // HTTP method\n    \"url\": \"/api/users\",          // Request URL path\n    \"path\": \"/api/users\",         // URL path\n    \"query\": {                    // Query parameters\n        \"page\": \"1\",\n        \"limit\": \"10\"\n    },\n    \"headers\": {                  // Request headers\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": \"Bearer token123\",\n        \"User-Agent\": \"Mozilla/5.0...\"\n    },\n    \"body\": \"request body...\",    // Request body\n    \"cookies\": {                  // Request cookies\n        \"session\": \"abc123\",\n        \"theme\": \"dark\"\n    },\n    \"remoteAddr\": \"127.0.0.1:12345\",  // Client address\n    \"userAgent\": \"Mozilla/5.0...\",     // User agent string\n    \"referer\": \"https://example.com\"   // Referer header\n}\n</code></pre>"},{"location":"stdlib/http/server/#accessing-request-data","title":"Accessing Request Data","text":"<pre><code>import http\nimport json\nimport fmt\n\nfunction requestInfoHandler(request map, response map) {\n    var method = request[\"method\"]\n    var path = request[\"path\"]\n    var query = request[\"query\"]\n    var headers = request[\"headers\"]\n    var body = request[\"body\"]\n\n    fmt.Printf(\"Method: %s\\n\", method)\n    fmt.Printf(\"Path: %s\\n\", path)\n    fmt.Printf(\"User-Agent: %s\\n\", headers[\"User-Agent\"])\n\n    // Process query parameters\n    var page = query[\"page\"]\n    var limit = query[\"limit\"]\n\n    if page != None {\n        fmt.Printf(\"Page: %s\\n\", page)\n    }\n\n    // Process JSON body\n    if method == \"POST\" and headers[\"Content-Type\"] == \"application/json\" {\n        var data, parseErr = json.Unmarshal(body)\n        if parseErr == None {\n            fmt.Printf(\"JSON data received: %s\\n\", data)\n        }\n    }\n\n    var responseData = {\n        \"received\": {\n            \"method\": method,\n            \"path\": path,\n            \"queryParams\": query,\n            \"hasBody\": body != \"\",\n            \"contentType\": headers[\"Content-Type\"]\n        }\n    }\n\n    var jsonResponse, _ = json.Marshal(responseData)\n    http.WriteResponse(response, 200, \"application/json\", jsonResponse)\n}\n</code></pre>"},{"location":"stdlib/http/server/#server-configuration","title":"Server Configuration","text":""},{"location":"stdlib/http/server/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>import http\n\nfunction createProductionServer(port string) {\n    var server = http.NewServer(\":\" + port)[0]\n\n    // Configure timeouts for production\n    server = http.SetServerConfig(server, {\n        \"readTimeout\": 30,      // 30 seconds\n        \"writeTimeout\": 30,     // 30 seconds  \n        \"idleTimeout\": 300,     // 5 minutes\n        \"maxHeaderBytes\": 1048576  // 1MB\n    })[0]\n\n    return server\n}\n</code></pre>"},{"location":"stdlib/http/server/#tls-configuration","title":"TLS Configuration","text":"<pre><code>import http\n\nfunction createSecureServer(port string) {\n    var server = http.NewServer(\":\" + port)[0]\n\n    // Configure TLS\n    server = http.SetTLSConfig(server, {\n        \"certFile\": \"/path/to/cert.pem\",\n        \"keyFile\": \"/path/to/key.pem\",\n        \"minVersion\": \"TLS1.2\",\n        \"cipherSuites\": [\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"]\n    })[0]\n\n    return server\n}\n</code></pre>"},{"location":"stdlib/http/server/#error-handling","title":"Error Handling","text":""},{"location":"stdlib/http/server/#server-error-handling","title":"Server Error Handling","text":"<pre><code>import http\nimport fmt\n\nfunction errorHandlingServer() {\n    var server = http.NewServer(\":8080\")[0]\n    var mux = http.NewMux()[0]\n\n    // Add error handling middleware\n    var errorMux = http.WithErrorHandling(mux, errorHandler)[0]\n\n    http.HandleFunc(errorMux, \"/\", homeHandler)\n    http.HandleFunc(errorMux, \"/error\", triggerErrorHandler)\n\n    http.SetHandler(server, errorMux)\n    http.ListenAndServe(server)\n}\n\nfunction errorHandler(error string, request map, response map) {\n    fmt.Printf(\"Server error: %s\\n\", error)\n\n    var errorResponse = {\n        \"error\": \"Internal server error\",\n        \"message\": \"Something went wrong\",\n        \"timestamp\": \"2024-01-01T12:00:00Z\"\n    }\n\n    var jsonData, _ = json.Marshal(errorResponse)\n    http.WriteResponse(response, 500, \"application/json\", jsonData)\n}\n\nfunction triggerErrorHandler(request map, response map) {\n    // Simulate an error\n    panic(\"Something went wrong!\")\n}\n</code></pre>"},{"location":"stdlib/http/server/#best-practices","title":"Best Practices","text":""},{"location":"stdlib/http/server/#1-always-set-content-type","title":"1. Always Set Content-Type","text":"<pre><code>// Good\nhttp.WriteResponse(response, 200, \"application/json\", jsonData)\n\n// Bad\nhttp.WriteResponse(response, 200, \"\", jsonData)\n</code></pre>"},{"location":"stdlib/http/server/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<pre><code>function safeHandler(request map, response map) {\n    var data, err = processRequest(request)\n    if err != None {\n        http.WriteResponse(response, 500, \"application/json\", \"{\\\"error\\\": \\\"Processing failed\\\"}\")\n        return\n    }\n\n    var jsonData, jsonErr = json.Marshal(data)\n    if jsonErr != None {\n        http.WriteResponse(response, 500, \"application/json\", \"{\\\"error\\\": \\\"JSON encoding failed\\\"}\")\n        return\n    }\n\n    http.WriteResponse(response, 200, \"application/json\", jsonData)\n}\n</code></pre>"},{"location":"stdlib/http/server/#3-use-appropriate-status-codes","title":"3. Use Appropriate Status Codes","text":"<pre><code>// Success responses\nhttp.WriteResponse(response, 200, contentType, data)  // OK\nhttp.WriteResponse(response, 201, contentType, data)  // Created\nhttp.WriteResponse(response, 204, \"\", \"\")             // No Content\n\n// Client error responses\nhttp.WriteResponse(response, 400, contentType, error) // Bad Request\nhttp.WriteResponse(response, 401, contentType, error) // Unauthorized\nhttp.WriteResponse(response, 404, contentType, error) // Not Found\n\n// Server error responses\nhttp.WriteResponse(response, 500, contentType, error) // Internal Server Error\n</code></pre>"},{"location":"stdlib/http/server/#4-set-security-headers","title":"4. Set Security Headers","text":"<pre><code>function secureHandler(request map, response map) {\n    // Security headers\n    http.SetResponseHeader(response, \"X-Content-Type-Options\", \"nosniff\")\n    http.SetResponseHeader(response, \"X-Frame-Options\", \"DENY\")\n    http.SetResponseHeader(response, \"X-XSS-Protection\", \"1; mode=block\")\n    http.SetResponseHeader(response, \"Strict-Transport-Security\", \"max-age=31536000\")\n\n    // Your handler logic here\n    http.WriteResponse(response, 200, \"text/html\", \"&lt;h1&gt;Secure Page&lt;/h1&gt;\")\n}\n</code></pre>"},{"location":"stdlib/http/server/#5-log-requests","title":"5. Log Requests","text":"<pre><code>import log\n\nfunction loggedHandler(request map, response map) {\n    var method = request[\"method\"]\n    var path = request[\"path\"]\n    var userAgent = request[\"headers\"][\"User-Agent\"]\n\n    log.Printf(\"Request: %s %s from %s\", method, path, userAgent)\n\n    // Your handler logic here\n    http.WriteResponse(response, 200, \"application/json\", \"{\\\"status\\\": \\\"ok\\\"}\")\n}\n</code></pre>"},{"location":"stdlib/http/server/#next-steps","title":"Next Steps","text":"<ul> <li>Routing &amp; Mux - Learn about URL routing and request multiplexing</li> <li>Middleware - Implement middleware for cross-cutting concerns</li> <li>Authentication - Handle authentication and authorization</li> <li>Cookies &amp; Sessions - Manage cookies and user sessions</li> </ul>"}]}